{"version":3,"sources":["../src/format/date.js","../src/util/date.js","../src/data/nest.js","../src/domain/datumFilter.js","../src/domain/generalMetadata.js","../src/domain/securityPolicy.js","../src/util/multiMap.js","../src/util/configuration.js","../src/net/environment.js","../src/net/urlQuery.js","../src/net/authV2.js","../src/util/logger.js","../src/data/array.js","../src/util/enum.js","../src/util/comparableEnum.js","../src/domain/aggregation.js","../src/domain/authTokenStatus.js","../src/domain/authTokenType.js","../src/domain/combiningType.js","../src/domain/datumAuxiliaryType.js","../src/domain/pagination.js","../src/domain/sortDescriptor.js","../src/util/propMap.js","../src/domain/location.js","../src/domain/datumReadingType.js","../src/util/bitmaskEnum.js","../src/domain/deviceOperatingState.js","../src/domain/instructionState.js","../src/domain/locationPrecision.js","../src/domain/skyCondition.js","../src/net/httpHeaders.js","../src/net/urlHelper.js","../src/net/locationUrlHelperMixin.js","../src/net/queryUrlHelperMixin.js","../src/net/locationDatumMetadataUrlHelperMixin.js","../src/net/locationDatumUrlHelperMixin.js","../src/net/nodeUrlHelperMixin.js","../src/net/nodeDatumMetadataUrlHelperMixin.js","../src/net/nodeDatumUrlHelperMixin.js","../src/net/userUrlHelperMixin.js","../src/net/nodeInstructionUrlHelperMixin.js","../src/net/nodeMetadataUrlHelperMixin.js","../src/net/userAuthTokenUrlHelperMixin.js","../src/net/userDatumAuxiliaryUrlHelperMixin.js","../src/net/userMetadataUrlHelperMixin.js","../src/format/scale.js","../src/net/authTokenUrlHelperMixin.js"],"names":["iso8601Date","date","includeTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","datumDate","d","localDate","dateTimeParse","localTime","created","timestampParse","dateTimeUrlParse","normalizeNestedStackDataByDate","layerData","fillTemplate","fillFn","j","k","dummy","prop","copyIndex","i","jMax","length","max","map","e","values","undefined","getTime","sourceId","key","hasOwnProperty","splice","idMapQueryParameterValue","Map","size","result","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","next","done","value","Set","push","Array","from","join","datumFilterUriEncodingPropertyMapper","NodeIdsKey","LocationIdsKey","SourceIdsKey","UserIdsKey","isArray","substring","StartDateKey","EndDateKey","dateTimeUrlFormat","MostRecentKey","NodeIdMapsKey","SourceIdMapsKey","p","stringMapToObject","strMap","obj","Object","create","_ref2","v","objectToStringMap","_step2","keys","_iteratorNormalCompletion2","_iterator2","set","_typeof","setOrNull","mergedSets","set1","set2","s1","s2","add","addValue","replace","keyLc","toLowerCase","mapping","mappings","val","mappingNames","len","createGetter","me","createSetter","createProperty","defineProperty","normalizedProtocol","normalizedConfig","config","assign","protocol","port","host","hostname","urlQueryParse","search","multiValueKeys","pairs","pair","params","match","split","decodeURIComponent","has","caseInsensitiveEqualsFn","valueLc","toString","lowercaseSortedArray","items","sortedItems","sort","_hexEscapeChar","c","charCodeAt","toUpperCase","_encodeURIComponent","str","encodeURIComponent","consoleLog","level","logLevel","console","logFn","error","warn","info","log","args","_len","_key","arguments","array","freeze","data","aggregate","aggMillseconds","currTime","expectedNextTime","nextTime","fill","fillTime","f","getPrototypeOf","getOwnPropertyDescriptors","Date","prototype","apply","Enum","name","_name","this","constructor","enums","reduce","enumValues","ComparableEnum","_value","_this","other","minEnum","cache","get","agg","compareTo","Aggregation","AggregationValues","Number","MAX_SAFE_INTEGER","Aggregations","enumsValue","timestampFormat","utcFormat","dateTimeFormat","dateFormat","utcParse","aggregateTimeCount","endDate","exclusiveEndDate","interval","ceil","offset","timeCountValue","propName","isNaN","end","start","timeUnit","timeCount","Hour","utcMinute","precision","Math","min","setUTCMinutes","utcHour","Month","equals","Year","utcMonth","utcYear","floor","Day","utcDay","nest$1","resultKey","copyProperties","sumProperties","staticProperties","dataLength","clone","layerCount","copyPropLength","sumPropLength","metricName","sourceIdMap","aggFn","metricExtractorFn","rollupFn","sum","nest","sortKeys","ascending","rollup","r","metricKey","entries","layer","combined","forEach","AuthTokenStatus","_Enum","AuthTokenStatusValues","AuthTokenStatuses","AuthTokenType","AuthTokenTypeValues","AuthTokenTypes","CombiningType","CombiningTypeValues","CombiningTypes","DatumAuxiliaryType","DatumAuxiliaryTypeValues","DatumAuxiliaryTypes","Pagination","_max","_offset","SortDescriptor","descending","_descending","index","propertyName","PropMap","props","properties","newValue","newProps","callbackFn","forceMultiKey","kv","toUriEncoding","_k","sorts","pagination","paginationParams","Location","loc","DatumFilter","nodeIds","nodeId","locationIds","locationId","sourceIds","userIds","userId","path","t","DatumReadingType","DatumReadingTypeValues","DatumReadingTypes","BitmaskEnum","bitNumber","_bitNumber","bitmaskBitNumber","maskables","mask","bitmaskBitOffset","clazz","setForBitmask","_step3","_iteratorNormalCompletion3","_iterator3","b","DeviceOperatingState","code","enumForBitNumber","DeviceOperatingStateValues","DeviceOperatingStates","GeneralMetadata","propertyInfo","tags","JSON","stringify","json","m","pm","parse","InstructionState","InstructionStateValues","InstructionStates","LocationPrecision","LocationPrecisionValues","LocationPrecisions","SecurityPolicy","aggregations","minAggregation","locationPrecisions","minLocationPrecision","nodeMetadataPaths","userMetadataPaths","_nodeIds","_sourceIds","_aggregations","_minAggregation","_locationPrecisions","_minLocationPrecision","_nodeMetadataPaths","_userMetadataPaths","MIN_AGGREGATION_CACHE","MIN_LOCATION_PRECISION_CACHE","SecurityPolicyBuilder","policy","withAggregations","withMinAggregation","withLocationPrecisions","withMinLocationPrecision","withNodeIds","withSourceIds","withNodeMetadataPaths","withUserMetadataPaths","addAggregations","addLocationPrecisions","addNodeIds","addSourceIds","addNodeMetadataPaths","addUserMetadataPaths","minimumEnumSet","buildAggregations","buildLocationPrecisions","SkyCondition","SkyConditionValues","SkyConditions","MultiMap","putAll","indexOf","Configuration","initialMap","enabled","newMap","Environment","HttpMethod","HttpContentType","HttpHeaders","defineProperties","urlQuery","parameters","encoderFn","handleValue","encoder","AuthorizationV2Builder","token","environment","tokenId","forceHostPort","reset","contentDigest","httpHeaders","signedHeaderNames","method","GET","tokenSecret","signingKey","computeSigningKey","signingKeyExpiration","requestDate","httpMethod","put","HOST","requestPath","url","uri","uriParse","scheme","query","queryParams","CONTENT_TYPE","useSnDate","headerName","headerValue","headers","digest","Hex","content","SHA256","contentSHA256","header","Base64","keySet","first","vals","valsLen","sortedLowercaseHeaderNames","toUTCString","firstValue","trim","EMPTY_STRING_SHA256_HEX","X_SN_DATE","DATE","containsKey","CONTENT_MD5","DIGEST","computeCanonicalRequestData","canonicalHeaderNames","canonicalQueryParameters","canonicalHeaders","canonicalSignedHeaderNames","canonicalContentSHA256","secretKey","datestring","HmacSHA256","canonicalRequestData","sortedHeaderNames","canonicalReq","signatureData","computeSignatureData","signature","buildWithKey","now","signedHeaders","findIndex","existingIndex","concat","remove","UrlHelper","env","_parameters","_environment","tls","useTls","hostUrl","template","resolveTemplateUrl","variableName","variableValue","LocationUrlHelperMixin","superclass","filter","baseUrl","toUriEncodingWithSorting","parameter","QueryUrlHelperMixin","isPubPath","publicQuery","LocationDatumMetadataUrlHelperMixin","baseLocationDatumMetadataUrl","source","locationDatumMetadataUrlWithSource","LocationDatumMetadataUrlHelper","LocationDatumUrlHelperMixin","startDate","datumFilter","LocationDatumUrlHelper","NodeUrlHelperMixin","NodeDatumMetadataUrlHelperMixin","baseNodeDatumMetadataUrl","nodeDatumMetadataUrlWithSource","userParam","userMetadataUrl","NodeDatumMetadataUrlHelper","NodeDatumUrlHelperMixin","sources","readingType","tolerance","NodeDatumUrlHelper","UserUrlHelperMixin","babelHelpers.get","archived","NodeInstructionUrlHelperMixin","instructionId","state","topic","urlEncodeInstructionParameters","NodeInstructionUrlHelper","instructionParameter","NodeMetadataUrlHelperMixin","viewNodeMetadataUrl","NodeMetadataUrlHelper","UserAuthTokenUrlHelperMixin","type","authTokenUrl","status","UserAuthTokenUrlHelper","UserDatumAuxiliaryUrlHelperMixin","userDatumAuxiliaryBaseUrl","userDatumAuxiliaryIdQueryUrl","userDatumAuxiliaryIdUrl","UserDatumAuxiliaryUrlHelper","UserMetadataUrlHelperMixin","UserMetadataUrlHelper","logLevels","Logger","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","isoParse","num","abs","baseUnit","scale"],"mappings":"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","file":"lib/solarnetwork-api-core.min.js.map","sourcesContent":["import { utcFormat, utcParse, isoParse } from \"d3-time-format\";\n\n/**\n * Format a date into a SolarNet UTC timestamp format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd HH:mm:ss.SSS'Z'`\n * @alias module:format~timestampFormat\n */\nexport const timestampFormat = utcFormat(\"%Y-%m-%d %H:%M:%S.%LZ\");\n\n/**\n * Format a date into a SolarNet UTC date/time format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd HH:mm`\n * @alias module:format~dateTimeFormat\n */\nexport const dateTimeFormat = utcFormat(\"%Y-%m-%d %H:%M\");\n\n/**\n * Format a date into a SolarNet URL UTC date/time format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd'T'HH:mm`\n * @alias module:format~dateTimeUrlFormat\n */\nexport const dateTimeUrlFormat = utcFormat(\"%Y-%m-%dT%H:%M\");\n\n/**\n * Format a date into a SolarNet UTC date format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd`\n * @alias module:format~dateFormat\n */\nexport const dateFormat = utcFormat(\"%Y-%m-%d\");\n\n/**\n * Parse a SolarNet UTC timestamp value.\n * @function\n * @param {string} str the string to parse - `yyyy-MM-dd HH:mm:ss.SSS'Z'\n * @returns {Date} the parsed date, or `null`\n * @alias module:format~timestampParse\n */\nexport const timestampParse = utcParse(\"%Y-%m-%d %H:%M:%S.%LZ\");\n\n/**\n * Parse a SolarNet UTC date/time.\n * @function\n * @param {string} str the string to parse - `yyyy-MM-dd HH:mm\n * @returns {Date} the parsed date, or `null`\n * @alias module:format~dateTimeParse\n */\nexport const dateTimeParse = utcParse(\"%Y-%m-%d %H:%M\");\n\nexport {\n\t/**\n\t * Parse a SolarNet URL UTC date/time value.\n\t * @function\n\t * @param {string} str the string to parse - `yyyy-MM-dd'T'HH:mm`\n\t * @returns {Date} the parsed date, or `null`\n\t * @alias module:format~dateTimeUrlParse\n\t */\n\tisoParse as dateTimeUrlParse,\n\t/**\n\t * Parse a SolarNet UTC date value.\n\t * @function\n\t * @param {string} str the string to parse - `yyyy-MM-dd`\n\t * @returns {Date} the parsed date, or `null`\n\t * @alias module:format~dateParse\n\t */\n\tisoParse as dateParse\n} from \"d3-time-format\";\n\n/**\n * Parse a UTC date string, from a variety of supported formats.\n *\n * @param {String} str the string to parse into a date\n * @returns {Date} the parsed `Date`, or `null` if the date can't be parsed\n * @alias module:format~dateParser\n */\nexport function dateParser(str) {\n\tvar date = isoParse(str) || timestampParse(str) || dateTimeParse(str);\n\treturn date;\n}\n\n/**\n * Format a date into an ISO 8601 timestamp or date string, in the UTC time zone.\n *\n * @param {Date} date the date to format\n * @param {boolean} [includeTime=false] `true` to format as a timestamp, `false` as just a date\n * @returns {string} the formatted date string\n * @alias module:format~iso8601Date\n */\nexport function iso8601Date(date, includeTime) {\n\treturn (\n\t\t\"\" +\n\t\tdate.getUTCFullYear() +\n\t\t(date.getUTCMonth() < 9 ? \"0\" : \"\") +\n\t\t(date.getUTCMonth() + 1) +\n\t\t(date.getUTCDate() < 10 ? \"0\" : \"\") +\n\t\tdate.getUTCDate() +\n\t\t(includeTime\n\t\t\t? \"T\" +\n\t\t\t  (date.getUTCHours() < 10 ? \"0\" : \"\") +\n\t\t\t  date.getUTCHours() +\n\t\t\t  (date.getUTCMinutes() < 10 ? \"0\" : \"\") +\n\t\t\t  date.getUTCMinutes() +\n\t\t\t  (date.getUTCSeconds() < 10 ? \"0\" : \"\") +\n\t\t\t  date.getUTCSeconds() +\n\t\t\t  \"Z\"\n\t\t\t: \"\")\n\t);\n}\n\n/**\n * Get a UTC season constant for a date. Seasons are groups of 3 months, e.g.\n * Spring, Summer, Autumn, Winter.\n *\n * The returned value will be a number between 0 and 3, where:\n *\n *  * (Mar, Apr, May) = `0`\n *  * (Jun, Jul, Aug) = `1`\n *  * (Sep, Oct, Nov) = `2`\n *  * (Dec, Jan, Feb) = `3`\n *\n * @param {Date|number} date either a date to get the season for, or a number representing the UTC month of a date\n * @returns {number} a season constant number, from 0 - 3\n * @alias module:format~seasonForDate\n */\nexport function seasonForDate(date) {\n\tconst m = date.getUTCMonth ? date.getUTCMonth() : Number(date);\n\tif (m < 2 || m === 11) {\n\t\treturn 3;\n\t} else if (m < 5) {\n\t\treturn 0;\n\t} else if (m < 8) {\n\t\treturn 1;\n\t} else {\n\t\treturn 2;\n\t}\n}\n","import { utcMinute, utcHour, utcDay, utcMonth, utcYear } from \"d3-time\";\nimport Aggregations from \"../domain/aggregation\";\nimport { dateTimeParse, dateTimeUrlParse, timestampParse } from \"../format/date\";\n\n/**\n * An object that defines levels of date range configuration.\n *\n * @typedef {Object} module:util~DateRangeConfiguration\n * @property {number} [numHours] the number of hours to use\n * @property {number} [numDays] the number of days to use\n * @property {number} [numMonths] the number of months to use\n * @property {number} [numYears] the number of years to use\n */\n\n/**\n * An object that defines a date range.\n *\n * @typedef {Object} module:util~DateRange\n * @property {Date} start the starting date\n * @property {Date} end the ending date\n * @property {module:domain~Aggregation} timeUnit the time unit used by the date range\n * @property {number} timeCount the number of time units in the date range\n * @property {module:domain~Aggregation} aggregate the aggregate to query with\n */\n\n/**\n * Get a query range appropriate for a given aggregate level.\n *\n * Returns an object with `start` and `end` Date properties, using the given `endDate`\n * parameter as the basis for calculating the start as an offset backwards in time\n * based on the given `aggregate` level.\n *\n * When `aggregateTimeCount` will be treated as a \"next higher\" aggregate level from\n * `aggregate`, like this:\n *\n *  * < `Hour`: `numHours`\n *  * `Hour` : `numDays`\n *  * `Day` : `numMonths`\n *  * `Month` : `numYears`\n *\n * For example, you might like to render a chart using `TenMinute` aggregate data for the\n * last 24 hours. You'd call this function like this:\n *\n * ```\n * const range = rollingQueryDateRange(Aggregates.TenMinute, 24);\n *\n * // or, passing a DateRangeConfiguration\n * const range = rollingQueryDateRange(Aggregates.TenMinute, {numHours:24});\n * ```\n *\n * @param {module:domain~Aggregation} aggregate the aggregate level to get a query range for\n * @param {number|module:util~DateRangeConfiguration} aggregateTimeCount the number of aggregate time units to use\n * @param {Date} [endDate] the ending date; if not provided the current date will be used\n * @returns {module:util~DateRange} the calculated date range\n * @alias module:util~rollingQueryDateRange\n */\nexport function rollingQueryDateRange(aggregate, aggregateTimeCount, endDate) {\n\tendDate = endDate || new Date();\n\n\tfunction exclusiveEndDate(interval, date) {\n\t\tvar result = interval.ceil(date);\n\t\tif (result.getTime() === date.getTime()) {\n\t\t\t// already on exact aggregate, so round up to next\n\t\t\tresult = interval.offset(result, 1);\n\t\t}\n\t\treturn result;\n\t}\n\n\tfunction timeCountValue(propName) {\n\t\tvar result;\n\t\tif (isNaN(Number(aggregateTimeCount))) {\n\t\t\tif (aggregateTimeCount[propName] !== undefined) {\n\t\t\t\tresult = Number(aggregateTimeCount[propName]);\n\t\t\t} else {\n\t\t\t\tresult = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = aggregateTimeCount;\n\t\t}\n\t\tif (typeof result !== \"number\") {\n\t\t\tresult = 1;\n\t\t}\n\t\treturn result;\n\t}\n\n\tvar end, start, timeUnit, timeCount;\n\n\tif (aggregate.compareTo(Aggregations.Hour) < 0) {\n\t\ttimeCount = timeCountValue(\"numHours\");\n\t\ttimeUnit = Aggregations.Hour;\n\t\tend = exclusiveEndDate(utcMinute, endDate);\n\t\tlet precision = Math.min(30, aggregate.level / 60);\n\t\tend.setUTCMinutes(\n\t\t\tend.getUTCMinutes() + precision - (end.getUTCMinutes() % precision),\n\t\t\t0,\n\t\t\t0\n\t\t);\n\t\tstart = utcHour.offset(end, -timeCount);\n\t} else if (Aggregations.Month.equals(aggregate)) {\n\t\ttimeCount = timeCountValue(\"numYears\");\n\t\ttimeUnit = Aggregations.Year;\n\t\tend = exclusiveEndDate(utcMonth, endDate);\n\t\tstart = utcYear.offset(utcMonth.floor(endDate), -timeCount);\n\t} else if (Aggregations.Day.equals(aggregate)) {\n\t\ttimeCount = timeCountValue(\"numMonths\");\n\t\ttimeUnit = Aggregations.Month;\n\t\tend = exclusiveEndDate(utcDay, endDate);\n\t\tstart = utcMonth.offset(utcDay.floor(endDate), -timeCount);\n\t} else {\n\t\t// assume Hour\n\t\ttimeCount = timeCountValue(\"numDays\");\n\t\ttimeUnit = Aggregations.Day;\n\t\tend = exclusiveEndDate(utcHour, endDate);\n\t\tstart = utcDay.offset(utcHour.floor(end), -timeCount);\n\t}\n\treturn {\n\t\tstart: start,\n\t\tend: end,\n\t\ttimeUnit: timeUnit,\n\t\ttimeCount: timeCount,\n\t\taggregate: aggregate\n\t};\n}\n\n/**\n * Get a date associated with a \"datum\" style object.\n *\n * This function will return a `Date` instance found via a property on `d` according to these rules:\n *\n *  1. `date` - assumed to be a `Date` object already and returned directly\n *  2. `localDate` - a string in `yyyy-MM-dd` form, optionally with a string\n *     `localTime` property for an associated time in `HH:mm` form, treated as UTC\n *  3. `created` - a string in `yyyy-MM-dd HH:mm:ss.SSS'Z'` or `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'` form\n *\n * These properties are commonly returned in results from the SolarNetwork API, and thus\n * this method is a handy way to get the dates for those objects.\n *\n * **Note** that the `localDate` and `localTime` values are parsed as UTC. When formatted the\n * date for display they should be formatted in UTC as well to preserve the expected value.\n *\n * @param {Object} d the datum object to extract a date from\n * @returns {Date} the extracted date, or `null` if no date could be extracted\n * @alias module:util~datumDate\n */\nexport function datumDate(d) {\n\tif (!d) {\n\t\treturn null;\n\t}\n\tif (d.date) {\n\t\treturn d.date;\n\t} else if (d.localDate) {\n\t\treturn dateTimeParse(d.localDate + (d.localTime ? \" \" + d.localTime : \" 00:00\"));\n\t} else if (d.created) {\n\t\treturn timestampParse(d.created) || dateTimeUrlParse(d.created);\n\t}\n}\n\nexport default Object.freeze({\n\tdatumDate: datumDate,\n\trollingQueryDateRange: rollingQueryDateRange\n});\n","import { ascending, max, sum } from \"d3-array\";\nimport { nest } from \"d3-collection\";\n\nimport { datumDate } from \"../util/date\";\n\n/**\n * A callback function that operates on a nested data layer datum object.\n *\n * @callback module:data~NestedDataOperatorFunction\n * @param {object} datum the datum object being operated on\n * @param {string} key the layer key the datum object is a member of\n * @param {object} [prevDatum] the previous datum object in the layer, if available\n * @returns {void}\n */\n\n/**\n * Normalize the data arrays resulting from a `d3.nest` operation so that all group\n * value arrays have the same number of elements, based on a Date property named\n * `date`.\n *\n * The data values are assumed to be sorted by `date` already, and are modified in-place.\n * This makes the data suitable to passing to `d3.stack`, which expects all stack data\n * arrays to have the same number of values, for the same keys. When querying for data\n * in SolarNetwork there might be gaps in the results, so this function can be used to\n * \"fill in\" those gaps with \"dummy\" values so that there are no more gaps.\n *\n * Filled-in data objects are automatically populated with an appropriate `date` property\n * and a `sourceId` property taken from the `key` of the layer the gap if found in. You\n * can pass a `fillTemplate` object with static properties to also include on all filled-in\n * data objects. You can also pass a `fillFn` function to populate the filled-in objects\n * with dynamic data.\n *\n * For example, given:\n *\n * ```\n * const layerData = [\n *   { key : 'A', values : [{date : new Date('2011-12-02 12:00')}, {date : new Date('2011-12-02 12:10')}] },\n *   { key : 'B', values : [{date : new Date('2011-12-02 12:00')}] }\n * ];\n *\n * normalizeNestedStackDataByDate(layerData);\n * ```\n *\n * The `layerData` would be modified in-place and look like this (notice the filled in second data value in the **B** group):\n *\n * ```\n * [\n *   { key : 'A', values : [{date : new Date('2011-12-02 12:00')}, {date : new Date('2011-12-02 12:10')}] },\n *   { key : 'B', values : [{date : new Date('2011-12-02 12:00')}, {date : new Date('2011-12-02 12:10'), sourceId : 'B'}] }\n * ]\n * ```\n *\n * @param {object[]} layerData - An array of objects with `key` and `values` properties, as returned from `d3.nest().entries()`\n * @param {string} layerData.key - The layer's key value.\n * @param {object[]} layerData.values - The layer's value array.\n * @param {object} [fillTemplate] - An object to use as a template for any filled-in data objects.\n *                                  The `date` property will be populated automatically, and a `sourceId`\n *                                  property will be populated by the layer's `key`.\n * @param {module:data~NestedDataOperatorFunction} [fillFn] - An optional function to populate filled-in data objects with.\n *                                                            This function is invoked **after** populating any `fillTemplate` values.\n * @returns {void}\n * @alias module:data~normalizeNestedStackDataByDate\n */\nexport function normalizeNestedStackDataByDate(layerData, fillTemplate, fillFn) {\n\tvar i = 0,\n\t\tj,\n\t\tk,\n\t\tjMax = layerData.length - 1,\n\t\tdummy,\n\t\tprop,\n\t\tcopyIndex;\n\t// fill in \"holes\" for each stack, if more than one stack. we assume data already sorted by date\n\tif (jMax > 0) {\n\t\twhile (\n\t\t\ti <\n\t\t\tmax(\n\t\t\t\tlayerData.map(function(e) {\n\t\t\t\t\treturn e.values.length;\n\t\t\t\t})\n\t\t\t)\n\t\t) {\n\t\t\tdummy = undefined;\n\t\t\tfor (j = 0; j <= jMax; j++) {\n\t\t\t\tif (layerData[j].values.length <= i) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif (j < jMax) {\n\t\t\t\t\tk = j + 1;\n\t\t\t\t} else {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tif (\n\t\t\t\t\tlayerData[k].values.length <= i ||\n\t\t\t\t\tlayerData[j].values[i].date.getTime() < layerData[k].values[i].date.getTime()\n\t\t\t\t) {\n\t\t\t\t\tdummy = { date: layerData[j].values[i].date, sourceId: layerData[k].key };\n\t\t\t\t\tif (fillTemplate) {\n\t\t\t\t\t\tfor (prop in fillTemplate) {\n\t\t\t\t\t\t\tif (fillTemplate.hasOwnProperty(prop)) {\n\t\t\t\t\t\t\t\tdummy[prop] = fillTemplate[prop];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (fillFn) {\n\t\t\t\t\t\tcopyIndex = layerData[k].values.length > i ? i : i > 0 ? i - 1 : null;\n\t\t\t\t\t\tfillFn(\n\t\t\t\t\t\t\tdummy,\n\t\t\t\t\t\t\tlayerData[k].key,\n\t\t\t\t\t\t\tcopyIndex !== null ? layerData[k].values[copyIndex] : undefined\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\tlayerData[k].values.splice(i, 0, dummy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (dummy === undefined) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Combine the layers resulting from a `d3.nest` operation into a single, aggregated\n * layer.\n *\n * This can be used to combine all sources of a single data type, for example\n * to show all \"power\" sources as a single layer of chart data. The resulting object\n * has the same structure as the input `layerData` parameter, with just a\n * single layer of data.\n *\n * For example:\n *\n * ```\n * const layerData = [\n *   { key : 'A', values : [{watts : 123, foo : 1}, {watts : 234, foo : 2}] },\n *   { key : 'B', values : [{watts : 345, foo : 3}, {watts : 456, foo : 4}] }\n * ];\n *\n * const result = aggregateNestedDataLayers(layerData,\n *     'A and B', ['foo'], ['watts'], {'combined' : true});\n * ```\n *\n * Then `result` would look like this:\n *\n * ```\n * [\n *   { key : 'A and B', values : [{watts : 468, foo : 1, combined : true},\n *                                {watts : 690, foo : 2, combined : true}] }\n * ]\n * ```\n *\n * @param {object[]} layerData - An array of objects with `key` and `values` properties, as returned from `d3.nest().entries()`\n * @param {string} layerData.key - The layer's key value.\n * @param {object[]} layerData.values - The layer's value array.\n * @param {string} resultKey - The `key` property to assign to the returned layer.\n * @param {string[]} copyProperties - An array of string property names to copy as-is from the **first** layer's data values.\n * @param {string[]} sumProperties - An array of string property names to add together from **all** layer data.\n * @param {object} staticProperties - Static properties to copy as-is to **all** output data values.\n * @return {object[]} An array of objects with `key` and `value` properties, the same structure as the provided `layerData` argument\n * @alias module:data~aggregateNestedDataLayers\n */\nexport function aggregateNestedDataLayers(\n\tlayerData,\n\tresultKey,\n\tcopyProperties,\n\tsumProperties,\n\tstaticProperties\n) {\n\t// combine all layers into a single source\n\tvar layerCount = layerData.length,\n\t\tdataLength,\n\t\ti,\n\t\tj,\n\t\tk,\n\t\tcopyPropLength = copyProperties ? copyProperties.length : 0,\n\t\tsumPropLength = sumProperties ? sumProperties.length : 0,\n\t\td,\n\t\tval,\n\t\tclone,\n\t\tarray;\n\n\tdataLength = layerData[0].values.length;\n\tif (dataLength > 0) {\n\t\tarray = [];\n\t\tfor (i = 0; i < dataLength; i += 1) {\n\t\t\td = layerData[0].values[i];\n\t\t\tclone = {};\n\t\t\tif (staticProperties !== undefined) {\n\t\t\t\tfor (val in staticProperties) {\n\t\t\t\t\tif (staticProperties.hasOwnProperty(val)) {\n\t\t\t\t\t\tclone[val] = staticProperties[val];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor (k = 0; k < copyPropLength; k += 1) {\n\t\t\t\tclone[copyProperties[k]] = d[copyProperties[k]];\n\t\t\t}\n\t\t\tfor (k = 0; k < sumPropLength; k += 1) {\n\t\t\t\tclone[sumProperties[k]] = 0;\n\t\t\t}\n\t\t\tfor (j = 0; j < layerCount; j += 1) {\n\t\t\t\tfor (k = 0; k < sumPropLength; k += 1) {\n\t\t\t\t\tval = layerData[j].values[i][sumProperties[k]];\n\t\t\t\t\tif (val !== undefined) {\n\t\t\t\t\t\tclone[sumProperties[k]] += val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray.push(clone);\n\t\t}\n\t\tlayerData = [{ key: resultKey, values: array }];\n\t}\n\n\treturn layerData;\n}\n\n/**\n * Transform raw SolarNetwork timeseries data by combining datum from multiple sources into a single\n * data per time key.\n *\n * This method produces a single array of objects with metric properties derived by grouping\n * that property within a single time slot across one or more source IDs. Conceptually this is\n * similar to {@link module:data~aggregateNestedDataLayers} except groups of source IDs can be\n * produced in the final result.\n *\n * The data will be passed through {@link module:data~normalizeNestedStackDataByDate} so that every\n * result object will contain every configured output group, but missing data will result in a\n * `null` value.\n *\n * Here's an example where two sources `A` and `B` are combined into a single group `Generation`\n * and a third source `C` is passed through as another group `Consumption`:\n *\n * ```\n * const queryData = [\n *     {localDate: '2018-05-05', localTime: '11:00', sourceId: 'A', watts : 123},\n *     {localDate: '2018-05-05', localTime: '11:00', sourceId: 'B', watts : 234},\n *     {localDate: '2018-05-05', localTime: '11:00', sourceId: 'C', watts : 345},\n *     {localDate: '2018-05-05', localTime: '12:00', sourceId: 'A', watts : 456},\n *     {localDate: '2018-05-05', localTime: '12:00', sourceId: 'B', watts : 567},\n *     {localDate: '2018-05-05', localTime: '12:00', sourceId: 'C', watts : 678},\n * ];\n * const sourceMap = new Map([\n *     ['A', 'Generation'],\n *     ['B', 'Generation'],\n *     ['C', 'Consumption'],\n * ]);\n *\n * const result = groupedBySourceMetricDataArray(queryData, 'watts', sourceMap);\n * ```\n *\n * Then `result` would look like this:\n *\n * ```\n * [\n *     {date : new Date('2018-05-05T11:00Z'), Generation : 357, Consumption: 345},\n *     {date : new Date('2018-05-05T12:00Z'), Generation : 1023, Consumption: 678}\n * ]\n * ```\n *\n * @param {object[]} data the raw data returned from SolarNetwork\n * @param {string} metricName the datum property name to extract\n * @param {Map} [sourceIdMap] an optional mapping of input source IDs to output source IDs; this can be used\n *                            to control the grouping of data, by mapping multiple input source IDs to the same\n *                            output source ID\n * @param {function} [aggFn] an optional aggregate function to apply to the metric values;\n *                           defaults to `d3.sum`; **note** that the function will be passed an array of input\n *                           data objects, not metric values\n * @returns {object[]} array of datum objects, each with a date and one metric value per source ID\n * @alias module:data~groupedBySourceMetricDataArray\n */\nexport function groupedBySourceMetricDataArray(data, metricName, sourceIdMap, aggFn) {\n\tconst metricExtractorFn = function metricExtractor(d) {\n\t\treturn d[metricName];\n\t};\n\tconst rollupFn = typeof aggFn === \"function\" ? aggFn : sum;\n\tconst layerData = nest()\n\t\t// group first by source\n\t\t.key(d => {\n\t\t\treturn sourceIdMap && sourceIdMap.has(d.sourceId)\n\t\t\t\t? sourceIdMap.get(d.sourceId)\n\t\t\t\t: d.sourceId;\n\t\t})\n\t\t.sortKeys(ascending)\n\t\t// group second by date\n\t\t.key(d => {\n\t\t\treturn d.localDate + \" \" + d.localTime;\n\t\t})\n\t\t// sum desired property in date group\n\t\t.rollup(values => {\n\t\t\tconst r = {\n\t\t\t\tdate: datumDate(values[0])\n\t\t\t};\n\t\t\tlet metricKey = values[0].sourceId;\n\t\t\tif (sourceIdMap && sourceIdMap.has(metricKey)) {\n\t\t\t\tmetricKey = sourceIdMap.get(metricKey);\n\t\t\t}\n\t\t\tr[metricKey] = rollupFn(values, metricExtractorFn);\n\t\t\treturn r;\n\t\t})\n\t\t// un-nest to single group by source\n\t\t.entries(data)\n\t\t.map(function(layer) {\n\t\t\treturn {\n\t\t\t\tkey: layer.key,\n\t\t\t\tvalues: layer.values.map(function(d) {\n\t\t\t\t\treturn d.value;\n\t\t\t\t})\n\t\t\t};\n\t\t});\n\n\t// ensure all layers have the same time keys\n\tnormalizeNestedStackDataByDate(layerData, null, (d, key) => {\n\t\t// make sure filled-in data has the metric property defined\n\t\td[key] = null;\n\t});\n\n\t// reduce to single array with multiple metric properties\n\treturn layerData.reduce(function(combined, layer) {\n\t\tif (!combined) {\n\t\t\treturn layer.values;\n\t\t}\n\t\tcombined.forEach(function(d, i) {\n\t\t\tconst v = layer.values[i][layer.key];\n\t\t\td[layer.key] = v;\n\t\t});\n\t\treturn combined;\n\t}, null);\n}\n\nexport default Object.freeze({\n\taggregateNestedDataLayers: aggregateNestedDataLayers,\n\tgroupedBySourceMetricDataArray: groupedBySourceMetricDataArray,\n\tnormalizeNestedStackDataByDate: normalizeNestedStackDataByDate\n});\n","import { Aggregation } from \"./aggregation\";\nimport { CombiningType } from \"./combiningType\";\nimport Location from \"./location\";\nimport PropMap from \"../util/propMap\";\n\nimport { dateTimeUrlFormat } from \"../format/date\";\n\nconst AggregationKey = \"aggregation\";\nconst CombiningTypeKey = \"combiningType\";\nconst DataPathKey = \"dataPath\";\nconst EndDateKey = \"endDate\";\nconst LocationIdsKey = \"locationIds\";\nconst LocationKey = \"location\";\nconst MetadataFilterKey = \"metadataFilter\";\nconst MostRecentKey = \"mostRecent\";\nconst NodeIdMapsKey = \"nodeIdMaps\";\nconst NodeIdsKey = \"nodeIds\";\nconst QueryKey = \"query\";\nconst SourceIdMapsKey = \"sourceIdMaps\";\nconst SourceIdsKey = \"sourceIds\";\nconst StartDateKey = \"startDate\";\nconst TagsKey = \"tags\";\nconst UserIdsKey = \"userIds\";\nconst WithoutTotalResultsCountKey = \"withoutTotalResultsCount\";\n\n/**\n * Combine an ID map into a query parameter.\n * @param {Map<*, Set<*>>} map ID mapping\n * @returns {String[]} the query parameter value, or `null` if no mapping available\n * @private\n */\nfunction idMapQueryParameterValue(map) {\n\tif (!(map instanceof Map && map.size > 0)) {\n\t\treturn null;\n\t}\n\tvar result = [];\n\tfor (let e of map) {\n\t\tif (!(e[1] instanceof Set)) {\n\t\t\tcontinue;\n\t\t}\n\t\tresult.push(`${e[0]}:${Array.from(e[1]).join(\",\")}`);\n\t}\n\treturn result;\n}\n\n/**\n * A filter criteria object for datum.\n *\n * <p>This filter is used to query both node datum and location datum. Not all properties are\n * applicable to both types. Be sure to consult the SolarNet API documentation on the\n * supported properties for each type.</p>\n *\n * @extends module:util~PropMap\n * @alias module:domain~DatumFilter\n */\nclass DatumFilter extends PropMap {\n\t/**\n\t * Constructor.\n\t * @param {object} [props] initial property values\n\t */\n\tconstructor(props) {\n\t\tsuper(props);\n\t}\n\n\t/**\n\t * A node ID.\n\t *\n\t * This manages the first available node ID from the `nodeIds` property.\n\t *\n\t * @type {number}\n\t */\n\tget nodeId() {\n\t\tconst nodeIds = this.nodeIds;\n\t\treturn Array.isArray(nodeIds) && nodeIds.length > 0 ? nodeIds[0] : null;\n\t}\n\n\tset nodeId(nodeId) {\n\t\tif (nodeId) {\n\t\t\tthis.nodeIds = [nodeId];\n\t\t} else {\n\t\t\tthis.nodeIds = null;\n\t\t}\n\t}\n\n\t/**\n\t * An array of node IDs.\n\t * @type {number[]}\n\t */\n\tget nodeIds() {\n\t\treturn this.prop(NodeIdsKey);\n\t}\n\n\tset nodeIds(nodeIds) {\n\t\tthis.prop(NodeIdsKey, Array.isArray(nodeIds) ? nodeIds : null);\n\t}\n\n\t/**\n\t * A location ID.\n\t *\n\t * This manages the first available location ID from the `locationIds` property.\n\t *\n\t * @type {number}\n\t */\n\tget locationId() {\n\t\tconst locationIds = this.locationIds;\n\t\treturn Array.isArray(locationIds) && locationIds.length > 0 ? locationIds[0] : null;\n\t}\n\n\tset locationId(locationId) {\n\t\tif (locationId) {\n\t\t\tthis.locationIds = [locationId];\n\t\t} else {\n\t\t\tthis.locationIds = null;\n\t\t}\n\t}\n\n\t/**\n\t * An array of location IDs.\n\t * @type {number[]}\n\t */\n\tget locationIds() {\n\t\treturn this.prop(LocationIdsKey);\n\t}\n\n\tset locationIds(locationIds) {\n\t\tthis.prop(LocationIdsKey, Array.isArray(locationIds) ? locationIds : null);\n\t}\n\n\t/**\n\t * A source ID.\n\t *\n\t * This manages the first available source ID from the `sourceIds` property.\n\t *\n\t * @type {string}\n\t */\n\tget sourceId() {\n\t\tconst sourceIds = this.sourceIds;\n\t\treturn Array.isArray(sourceIds) && sourceIds.length > 0 ? sourceIds[0] : null;\n\t}\n\n\tset sourceId(sourceId) {\n\t\tif (sourceId) {\n\t\t\tthis.sourceIds = [sourceId];\n\t\t} else {\n\t\t\tthis.sourceIds = null;\n\t\t}\n\t}\n\n\t/**\n\t * An array of source IDs.\n\t * @type {string[]}\n\t */\n\tget sourceIds() {\n\t\treturn this.prop(SourceIdsKey);\n\t}\n\n\tset sourceIds(sourceIds) {\n\t\tthis.prop(SourceIdsKey, Array.isArray(sourceIds) ? sourceIds : null);\n\t}\n\n\t/**\n\t * A user ID.\n\t *\n\t * This manages the first available location ID from the `userIds` property.\n\t *\n\t * @type {number}\n\t */\n\tget userId() {\n\t\tconst userIds = this.userIds;\n\t\treturn Array.isArray(userIds) && userIds.length > 0 ? userIds[0] : null;\n\t}\n\n\tset userId(userId) {\n\t\tif (userId) {\n\t\t\tthis.userIds = [userId];\n\t\t} else {\n\t\t\tthis.userIds = null;\n\t\t}\n\t}\n\n\t/**\n\t * An array of user IDs.\n\t * @type {number[]}\n\t */\n\tget userIds() {\n\t\treturn this.prop(UserIdsKey);\n\t}\n\n\tset userIds(userIds) {\n\t\tthis.prop(UserIdsKey, Array.isArray(userIds) ? userIds : null);\n\t}\n\n\t/**\n\t * The \"most recent\" flag.\n\t * @type {boolean}\n\t */\n\tget mostRecent() {\n\t\treturn !!this.prop(MostRecentKey);\n\t}\n\n\tset mostRecent(value) {\n\t\tthis.prop(MostRecentKey, !!value);\n\t}\n\n\t/**\n\t * A minimumin date.\n\t * @type {Date}\n\t */\n\tget startDate() {\n\t\treturn this.prop(StartDateKey);\n\t}\n\n\tset startDate(date) {\n\t\tthis.prop(StartDateKey, date);\n\t}\n\n\t/**\n\t * A maximum date.\n\t * @type {Date}\n\t */\n\tget endDate() {\n\t\treturn this.prop(EndDateKey);\n\t}\n\n\tset endDate(date) {\n\t\tthis.prop(EndDateKey, date);\n\t}\n\n\t/**\n\t * A data path, in dot-delimited notation like `i.watts`.\n\t * @type {string}\n\t */\n\tget dataPath() {\n\t\treturn this.prop(DataPathKey);\n\t}\n\n\tset dataPath(path) {\n\t\tthis.prop(DataPathKey, path);\n\t}\n\n\t/**\n\t * An aggregation.\n\t *\n\t * Including this in a filter will cause SolarNet to return aggregated results, rather\n\t * than raw results.\n\t *\n\t * @type {module:domain~Aggregation}\n\t */\n\tget aggregation() {\n\t\treturn this.prop(AggregationKey);\n\t}\n\n\tset aggregation(agg) {\n\t\tthis.prop(AggregationKey, agg instanceof Aggregation ? agg : null);\n\t}\n\n\t/**\n\t * An array of tags.\n\t * @type {string[]}\n\t */\n\tget tags() {\n\t\treturn this.prop(TagsKey);\n\t}\n\n\tset tags(val) {\n\t\tthis.prop(TagsKey, Array.isArray(val) ? val : null);\n\t}\n\n\t/**\n\t * A location, used as an example-based search criteria.\n\t * @type {module:domain~Location}\n\t */\n\tget location() {\n\t\treturn this.prop(LocationKey);\n\t}\n\n\tset location(val) {\n\t\tthis.prop(LocationKey, val instanceof Location ? val : null);\n\t}\n\n\t/**\n\t * A general full-text style query string.\n\t * @type {string}\n\t */\n\tget query() {\n\t\treturn this.prop(QueryKey);\n\t}\n\n\tset query(val) {\n\t\tthis.prop(QueryKey, val);\n\t}\n\n\t/**\n\t * A metadata filter (LDAP style search criteria).\n\t * @type {string}\n\t */\n\tget metadataFilter() {\n\t\treturn this.prop(MetadataFilterKey);\n\t}\n\n\tset metadataFilter(val) {\n\t\tthis.prop(MetadataFilterKey, val);\n\t}\n\n\t/**\n\t * Get the _without total results_ flag.\n\t * @type {boolean}\n\t */\n\tget withoutTotalResultsCount() {\n\t\treturn this.prop(WithoutTotalResultsCountKey);\n\t}\n\n\tset withoutTotalResultsCount(val) {\n\t\tthis.prop(WithoutTotalResultsCountKey, !!val);\n\t}\n\n\t/**\n\t * Get the combining type.\n\t *\n\t * Use this to combine nodes and/or sources into virtual groups. Requires some combination\n\t * of {@link #nodeIdMaps} or {@link #sourceIdMaps} also be specified.\n\t *\n\t * @type {module:domain~CombiningType}\n\t */\n\tget combiningType() {\n\t\treturn this.prop(CombiningTypeKey);\n\t}\n\n\tset combiningType(t) {\n\t\tthis.prop(CombiningTypeKey, t instanceof CombiningType ? t : null);\n\t}\n\n\t/**\n\t * A mapping of virtual node IDs to sets of real node IDs to combine.\n\t *\n\t * @type {Map<Number, Set<Number>>}\n\t */\n\tget nodeIdMaps() {\n\t\treturn this.prop(NodeIdMapsKey);\n\t}\n\n\tset nodeIdMaps(map) {\n\t\tthis.prop(NodeIdMapsKey, map instanceof Map ? map : null);\n\t}\n\n\t/**\n\t * A mapping of virtual source IDs to sets of real source IDs to combine.\n\t *\n\t * @type {Map<String, Set<String>>}\n\t */\n\tget sourceIdMaps() {\n\t\treturn this.prop(SourceIdMapsKey);\n\t}\n\n\tset sourceIdMaps(map) {\n\t\tthis.prop(SourceIdMapsKey, map instanceof Map ? map : null);\n\t}\n\n\t/**\n\t * Get this object as a standard URI encoded (query parameters) string value.\n\t *\n\t * @override\n\t * @inheritdoc\n\t */\n\ttoUriEncoding(propertyName, callbackFn) {\n\t\treturn super.toUriEncoding(\n\t\t\tpropertyName,\n\t\t\tcallbackFn || datumFilterUriEncodingPropertyMapper\n\t\t);\n\t}\n}\n\n/**\n * Map DatumFilter properties for URI encoding.\n *\n * @param {string} key the property key\n * @param {*} value the property value\n * @returns {*} 2 or 3-element array for mapped key+value+forced-multi-key, `null` to skip, or `key` to keep as-is\n * @private\n */\nfunction datumFilterUriEncodingPropertyMapper(key, value) {\n\tif (\n\t\tkey === NodeIdsKey ||\n\t\tkey === LocationIdsKey ||\n\t\tkey === SourceIdsKey ||\n\t\tkey === UserIdsKey\n\t) {\n\t\t// check for singleton array value, and re-map to singular property by chopping of \"s\"\n\t\tif (Array.isArray(value) && value.length === 1) {\n\t\t\treturn [key.substring(0, key.length - 1), value[0]];\n\t\t}\n\t} else if (key === StartDateKey || key === EndDateKey) {\n\t\treturn [key, dateTimeUrlFormat(value)];\n\t} else if (key === MostRecentKey && !value) {\n\t\treturn null;\n\t} else if (key === NodeIdMapsKey || key === SourceIdMapsKey) {\n\t\tlet p = idMapQueryParameterValue(value);\n\t\treturn p ? [key, p, true] : null;\n\t}\n\treturn key;\n}\n\nexport default DatumFilter;\n","/**\n * General metadata with a basic structure.\n *\n * This metadata can be associated with a variety of objects within SolarNetwork, such\n * as users, nodes, and datum.\n *\n * @alias module:domain~GeneralMetadata\n */\nclass GeneralMetadata {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {Map<string, *>} [info] the general metadata map\n\t * @param {Map<string, Map<string, *>>} [propertyInfo] the property metadata map\n\t * @param {Set<string>} [tags] the tags\n\t */\n\tconstructor(info, propertyInfo, tags) {\n\t\tthis.info = info || null;\n\t\tthis.propertyInfo = propertyInfo || null;\n\t\tthis.tags = tags instanceof Set ? tags : Array.isArray(tags) ? new Set(tags) : null;\n\t}\n\n\t/**\n\t * Get this object as a standard JSON encoded string value.\n\t *\n\t * @return {string} the JSON encoded string\n\t */\n\ttoJsonEncoding() {\n\t\tconst result = {};\n\t\tconst info = this.info;\n\t\tif (info) {\n\t\t\tresult[\"m\"] = stringMapToObject(info);\n\t\t}\n\t\tconst propertyInfo = this.propertyInfo;\n\t\tif (propertyInfo) {\n\t\t\tresult[\"pm\"] = stringMapToObject(propertyInfo);\n\t\t}\n\t\tconst tags = this.tags;\n\t\tif (tags) {\n\t\t\tresult[\"t\"] = Array.from(tags);\n\t\t}\n\n\t\treturn JSON.stringify(result);\n\t}\n\n\t/**\n\t * Parse a JSON string into a {@link module:domain~GeneralMetadata} instance.\n\t *\n\t * The JSON must be encoded the same way {@link module:domain~GeneralMetadata#toJsonEncoding} does.\n\t *\n\t * @param {string} json the JSON to parse\n\t * @returns {module:domain~GeneralMetadata} the metadata instance\n\t */\n\tstatic fromJsonEncoding(json) {\n\t\tlet m, pm, t;\n\t\tif (json) {\n\t\t\tconst obj = JSON.parse(json);\n\t\t\tm = obj[\"m\"] ? objectToStringMap(obj[\"m\"]) : null;\n\t\t\tpm = obj[\"pm\"] ? objectToStringMap(obj[\"pm\"]) : null;\n\t\t\tt = Array.isArray(obj[\"t\"]) ? new Set(obj[\"t\"]) : null;\n\t\t}\n\t\treturn new GeneralMetadata(m, pm, t);\n\t}\n}\n\n/**\n * Convert a `Map` into a simple object.\n *\n * The keys are assumed to be strings. Values that are themselves `Map` instances\n * will be converted to simple objects as well.\n *\n * @param {Map<string, *>} strMap a Map with string keys; nested Map objects are also handled\n * @returns {object} a simple object\n * @see {@link objectToStringMap} for the reverse conversion\n * @alias module:domain~stringMapToObject\n */\nfunction stringMapToObject(strMap) {\n\tconst obj = Object.create(null);\n\tif (strMap) {\n\t\tfor (const [k, v] of strMap) {\n\t\t\tobj[k] = v instanceof Map ? stringMapToObject(v) : v;\n\t\t}\n\t}\n\treturn obj;\n}\n\n/**\n * Convert a simple object into a `Map` instance.\n *\n * Property values that are themselves objects will be converted into `Map`\n * instances as well.\n *\n * @param {object} obj a simple object\n * @returns {Map<string, *>} a Map with string keys; nested Map objects are also handled\n * @see {@link module:domain~stringMapToObject} for the reverse conversion\n * @alias module:domain~objectToStringMap\n */\nfunction objectToStringMap(obj) {\n\tconst strMap = new Map();\n\tif (obj) {\n\t\tfor (const k of Object.keys(obj)) {\n\t\t\tconst v = obj[k];\n\t\t\tstrMap.set(k, typeof v === \"object\" ? objectToStringMap(v) : v);\n\t\t}\n\t}\n\treturn strMap;\n}\n\nexport default GeneralMetadata;\nexport { stringMapToObject, objectToStringMap };\n","import { Aggregation } from \"./aggregation\";\nimport { LocationPrecision } from \"./locationPrecision\";\n\n/**\n * Get a Set from a Set or array or object, returning `null` if the set would be empty.\n *\n * @param {Object[]|Set<*>} obj the array, Set, or singleton object to get as a Set\n * @returns {Set<*>} the Set, or `null`\n * @private\n */\nfunction setOrNull(obj) {\n\tlet result = null;\n\tif (obj instanceof Set) {\n\t\tresult = obj.size > 0 ? obj : null;\n\t} else if (Array.isArray(obj)) {\n\t\tresult = obj.length > 0 ? new Set(obj) : null;\n\t} else if (obj) {\n\t\tresult = new Set([obj]);\n\t}\n\treturn result;\n}\n\n/**\n * Merge two sets.\n *\n * @param {Object[]|Set<*>} [set1] the first set\n * @param {Object[]|Set<*>} [set2] the second set\n * @returns {Set<*>} the merged Set, or `null` if neither arguments are sets or\n *                   neither argument have any values\n * @private\n */\nfunction mergedSets(set1, set2) {\n\tlet s1 = setOrNull(set1);\n\tlet s2 = setOrNull(set2);\n\tif (s1 === null && s2 === null) {\n\t\treturn null;\n\t} else if (s2 === null) {\n\t\treturn s1;\n\t} else if (s1 === null) {\n\t\treturn s2;\n\t} else {\n\t\tfor (let v of s2.values()) {\n\t\t\ts1.add(v);\n\t\t}\n\t\treturn s1;\n\t}\n}\n\n/**\n * An immutable set of security restrictions that can be attached to other objects, like auth tokens.\n *\n * Use the {@link module:domain~SecurityPolicyBuilder} to create instances of this class with a fluent API.\n * @alias module:domain~SecurityPolicy\n */\nclass SecurityPolicy {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {number[]|Set<number>} [nodeIds] the node IDs to restrict to, or `null` for no restriction\n\t * @param {string[]|Set<string>} [sourceIds] the source ID to restrict to, or `null` for no restriction\n\t * @param {module:domain~Aggregation[]|Set<module:domain~Aggregation>} [aggregations] the aggregation names to restrict to, or `null` for no restriction\n\t * @param {module:domain~Aggregation} [minAggregation] if specified, a minimum aggregation level that is allowed\n\t * @param {Set<module:domain~LocationPrecision>} [locationPrecisions] the location precision names to restrict to, or `null` for no restriction\n\t * @param {module:domain~LocationPrecision} [minLocationPrecision] if specified, a minimum location precision that is allowed\n\t * @param {Set<string>} [nodeMetadataPaths] the `SolarNodeMetadata` paths to restrict to, or `null` for no restriction\n\t * @param {Set<string>} [userMetadataPaths] the `UserNodeMetadata` paths to restrict to, or `null` for no restriction\n\t */\n\tconstructor(\n\t\tnodeIds,\n\t\tsourceIds,\n\t\taggregations,\n\t\tminAggregation,\n\t\tlocationPrecisions,\n\t\tminLocationPrecision,\n\t\tnodeMetadataPaths,\n\t\tuserMetadataPaths\n\t) {\n\t\tthis._nodeIds = setOrNull(nodeIds);\n\t\tthis._sourceIds = setOrNull(sourceIds);\n\t\tthis._aggregations = setOrNull(aggregations);\n\t\tthis._minAggregation = minAggregation instanceof Aggregation ? minAggregation : null;\n\t\tthis._locationPrecisions = setOrNull(locationPrecisions);\n\t\tthis._minLocationPrecision =\n\t\t\tminLocationPrecision instanceof LocationPrecision ? minLocationPrecision : null;\n\t\tthis._nodeMetadataPaths = setOrNull(nodeMetadataPaths);\n\t\tthis._userMetadataPaths = setOrNull(userMetadataPaths);\n\t\tif (this.constructor === SecurityPolicy) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the node IDs.\n\t *\n\t * @returns {Set<number>} the node IDs, or `null`\n\t */\n\tget nodeIds() {\n\t\treturn this._nodeIds;\n\t}\n\n\t/**\n\t * Get the source IDs.\n\t *\n\t * @returns {Set<string>} the source IDs, or `null`\n\t */\n\tget sourceIds() {\n\t\treturn this._sourceIds;\n\t}\n\n\t/**\n\t * Get the aggregations.\n\t *\n\t * @returns {Set<module:domain~Aggregation>} the aggregations, or `null`\n\t */\n\tget aggregations() {\n\t\treturn this._aggregations;\n\t}\n\n\t/**\n\t * Get the location precisions.\n\t *\n\t * @returns {Set<module:domain~LocationPrecision>} the precisions, or `null`\n\t */\n\tget locationPrecisions() {\n\t\treturn this._locationPrecisions;\n\t}\n\n\t/**\n\t * Get the minimum aggregation.\n\t *\n\t * @returns {module:domain~Aggregation} the minimum aggregation, or `null`\n\t */\n\tget minAggregation() {\n\t\treturn this._minAggregation;\n\t}\n\n\t/**\n\t * Get the minimum location precision.\n\t *\n\t * @returns {module:domain~LocationPrecision} the minimum precision, or `null`\n\t */\n\tget minLocationPrecision() {\n\t\treturn this._minLocationPrecision;\n\t}\n\n\t/**\n\t * Get the node metadata paths.\n\t *\n\t * @returns {Set<string>} the node metadata paths, or `null`\n\t */\n\tget nodeMetadataPaths() {\n\t\treturn this._nodeMetadataPaths;\n\t}\n\n\t/**\n\t * Get the user metadata paths.\n\t *\n\t * @returns {Set<string>} the user metadata paths, or `null`\n\t */\n\tget userMetadataPaths() {\n\t\treturn this._userMetadataPaths;\n\t}\n\n\t/**\n\t * Get this object as a standard JSON encoded string value.\n\t *\n\t * @return {string} the JSON encoded string\n\t */\n\ttoJsonEncoding() {\n\t\tlet result = {};\n\t\tlet val = this.nodeIds;\n\t\tif (val) {\n\t\t\tresult.nodeIds = Array.from(val);\n\t\t}\n\n\t\tval = this.sourceIds;\n\t\tif (val) {\n\t\t\tresult.sourceIds = Array.from(val);\n\t\t}\n\n\t\tval = this.aggregations;\n\t\tif (val) {\n\t\t\tresult.aggregations = Array.from(val).map(e => e.name);\n\t\t}\n\n\t\tval = this.locationPrecisions;\n\t\tif (val) {\n\t\t\tresult.locationPrecisions = Array.from(val).map(e => e.name);\n\t\t}\n\n\t\tval = this.minAggregation;\n\t\tif (val) {\n\t\t\tif (result.length > 0) {\n\t\t\t\tresult += \"&\";\n\t\t\t}\n\t\t\tresult.minAggregation = val.name;\n\t\t}\n\n\t\tval = this.minLocationPrecision;\n\t\tif (val) {\n\t\t\tresult.minLocationPrecision = val.name;\n\t\t}\n\n\t\tval = this.nodeMetadataPaths;\n\t\tif (val) {\n\t\t\tresult.nodeMetadataPaths = Array.from(val);\n\t\t}\n\n\t\tval = this.userMetadataPaths;\n\t\tif (val) {\n\t\t\tresult.userMetadataPaths = Array.from(val);\n\t\t}\n\n\t\treturn JSON.stringify(result);\n\t}\n}\n\nconst MIN_AGGREGATION_CACHE = new Map(); // Map<string, Set<Aggregation>>\nconst MIN_LOCATION_PRECISION_CACHE = new Map(); // Map<string, Set<LocationPrecision>>\n\n/**\n * A mutable builder object for {@link module:domain~SecurityPolicy} instances.\n * @alias module:domain~SecurityPolicyBuilder\n */\nclass SecurityPolicyBuilder {\n\t/**\n\t * Apply all properties from another SecurityPolicy.\n\t *\n\t * @param {module:domain~SecurityPolicy} policy the SecurityPolicy to apply\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithPolicy(policy) {\n\t\tif (policy) {\n\t\t\tthis.withAggregations(policy.aggregations)\n\t\t\t\t.withMinAggregation(policy.minAggregation)\n\t\t\t\t.withLocationPrecisions(policy.locationPrecisions)\n\t\t\t\t.withMinLocationPrecision(policy.minLocationPrecision)\n\t\t\t\t.withNodeIds(policy.nodeIds)\n\t\t\t\t.withSourceIds(policy.sourceIds)\n\t\t\t\t.withNodeMetadataPaths(policy.nodeMetadataPaths)\n\t\t\t\t.withUserMetadataPaths(policy.userMetadataPaths);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Merge all properties from another SecurityPolicy.\n\t *\n\t * @param {module:domain~SecurityPolicy} policy the SecurityPolicy to merge\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddPolicy(policy) {\n\t\tif (policy) {\n\t\t\tthis.addAggregations(policy.aggregations)\n\t\t\t\t.addLocationPrecisions(policy.locationPrecisions)\n\t\t\t\t.addNodeIds(policy.nodeIds)\n\t\t\t\t.addSourceIds(policy.sourceIds)\n\t\t\t\t.addNodeMetadataPaths(policy.nodeMetadataPaths)\n\t\t\t\t.addUserMetadataPaths(policy.userMetadataPaths);\n\t\t\tif (policy.minAggregation) {\n\t\t\t\tthis.withMinAggregation(policy.minAggregation);\n\t\t\t}\n\t\t\tif (policy.minLocationPrecision) {\n\t\t\t\tthis.withMinLocationPrecision(policy.minLocationPrecision);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the node IDs.\n\t *\n\t * @param {number[]|Set<number>} nodeIds the node IDs to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithNodeIds(nodeIds) {\n\t\tthis.nodeIds = setOrNull(nodeIds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a set of node IDs.\n\t *\n\t * @param {number[]|Set<number>} nodeIds the node IDs to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddNodeIds(nodeIds) {\n\t\treturn this.withNodeIds(mergedSets(this.nodeIds, nodeIds));\n\t}\n\n\t/**\n\t * Set the node metadata paths.\n\t *\n\t * @param {string[]|Set<string>} nodeMetadataPaths the path expressions to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithNodeMetadataPaths(nodeMetadataPaths) {\n\t\tthis.nodeMetadataPaths = setOrNull(nodeMetadataPaths);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a set of node metadata paths.\n\t *\n\t * @param {string[]|Set<string>} nodeMetadataPaths the path expressions to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddNodeMetadataPaths(nodeMetadataPaths) {\n\t\treturn this.withNodeMetadataPaths(mergedSets(this.nodeMetadataPaths, nodeMetadataPaths));\n\t}\n\n\t/**\n\t * Set the user metadata paths.\n\t *\n\t * @param {string[]|Set<string>} userMetadataPaths the path expressions to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithUserMetadataPaths(userMetadataPaths) {\n\t\tthis.userMetadataPaths = setOrNull(userMetadataPaths);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a set of user metadata paths.\n\t *\n\t * @param {string[]|Set<string>} userMetadataPaths the path expressions to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddUserMetadataPaths(userMetadataPaths) {\n\t\treturn this.withUserMetadataPaths(mergedSets(this.userMetadataPaths, userMetadataPaths));\n\t}\n\n\t/**\n\t * Set the source IDs.\n\t *\n\t * @param {string[]|Set<string>} sourceIds the source IDs to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithSourceIds(sourceIds) {\n\t\tthis.sourceIds = setOrNull(sourceIds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add source IDs.\n\t *\n\t * @param {string[]|Set<string>} sourceIds the source IDs to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddSourceIds(sourceIds) {\n\t\treturn this.withSourceIds(mergedSets(this.sourceIds, sourceIds));\n\t}\n\n\t/**\n\t * Set the aggregations.\n\t *\n\t * @param {module:domain~Aggregation[]|Set<module:domain~Aggregation>} aggregations the aggregations to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithAggregations(aggregations) {\n\t\tthis.aggregations = setOrNull(aggregations);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the aggregations.\n\t *\n\t * @param {module:domain~Aggregation[]|Set<module:domain~Aggregation>} aggregations the aggregations to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddAggregations(aggregations) {\n\t\treturn this.withAggregations(mergedSets(this.aggregations, aggregations));\n\t}\n\n\t/**\n\t * Set the location precisions.\n\t *\n\t * @param {module:domain~LocationPrecision[]|Set<module:domain~LocationPrecision>} locationPrecisions the precisions to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithLocationPrecisions(locationPrecisions) {\n\t\tthis.locationPrecisions = setOrNull(locationPrecisions);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add location precisions.\n\t *\n\t * @param {module:domain~LocationPrecision[]|Set<module:domain~LocationPrecision>} locationPrecisions the precisions to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddLocationPrecisions(locationPrecisions) {\n\t\treturn this.withLocationPrecisions(mergedSets(this.locationPrecisions, locationPrecisions));\n\t}\n\n\t/**\n\t * Set a minimum aggregation level.\n\t *\n\t * @param {module:domain~Aggregation} minAggregation the minimum aggregation level to set\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithMinAggregation(minAggregation) {\n\t\tthis.minAggregation = minAggregation;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the effective aggregation level set from the policy settings.\n\t *\n\t * This computes a set of aggregation levels based on the configured `minAggregation`\n\t * and `aggregations` values.\n\t *\n\t * @returns {Set<module:domain~Aggregation>} the aggregation set\n\t * @private\n\t */\n\tbuildAggregations() {\n\t\tconst minAggregation = this.minAggregation;\n\t\tconst aggregations = this.aggregations;\n\t\tif (!minAggregation && aggregations && aggregations.size > 0) {\n\t\t\treturn aggregations;\n\t\t} else if (!minAggregation) {\n\t\t\treturn null;\n\t\t}\n\t\treturn Aggregation.minimumEnumSet(minAggregation, MIN_AGGREGATION_CACHE);\n\t}\n\n\t/**\n\t * Treat the configured `locationPrecisions` set as a single\n\t * minimum value or a list of exact values.\n\t *\n\t * By default if `locationPrecisions` is configured with a single\n\t * value it will be treated as a <em>minimum</em> value, and any\n\t * {@link module:domain~LocationPrecision} with a {@link module:domain~LocationPrecision#precision} equal\n\t * to or higher than that value's level will be included in the generated\n\t * {@link module:domain~SecurityPolicy#locationPrecisions} set. Set this to\n\t * `null` to disable that behavior and treat\n\t * `locationPrecisions` as the exact values to include in the\n\t * generated {@link module:domain~SecurityPolicy#locationPrecisions} set.\n\t *\n\t * @param {module:domain~LocationPrecision|null} minLocationPrecision\n\t *        `null` to treat configured location precision values\n\t *        as-is, or else the minimum threshold\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithMinLocationPrecision(minLocationPrecision) {\n\t\tthis.minLocationPrecision = minLocationPrecision;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the effective aggregation level set from the policy settings.\n\t *\n\t * This computes a set of location precision levels based on the configured `minLocationPrecision`\n\t * and `locationPrecisions` values.\n\t *\n\t * @returns {Set<module:domain~LocationPrecision>} the precision set\n\t * @private\n\t */\n\tbuildLocationPrecisions() {\n\t\tconst minLocationPrecision = this.minLocationPrecision;\n\t\tconst locationPrecisions = this.locationPrecisions;\n\t\tif (!minLocationPrecision && locationPrecisions && locationPrecisions.size > 0) {\n\t\t\treturn locationPrecisions;\n\t\t} else if (!minLocationPrecision) {\n\t\t\treturn null;\n\t\t}\n\t\treturn LocationPrecision.minimumEnumSet(minLocationPrecision, MIN_LOCATION_PRECISION_CACHE);\n\t}\n\n\t/**\n\t * Create a new {@link SecurityPolicy} out of the properties configured on this builder.\n\t *\n\t * @returns {module:domain~SecurityPolicy} the new policy instance\n\t */\n\tbuild() {\n\t\treturn new SecurityPolicy(\n\t\t\tthis.nodeIds,\n\t\t\tthis.sourceIds,\n\t\t\tthis.buildAggregations(),\n\t\t\tthis.minAggregation,\n\t\t\tthis.buildLocationPrecisions(),\n\t\t\tthis.minLocationPrecision,\n\t\t\tthis.nodeMetadataPaths,\n\t\t\tthis.userMetadataPaths\n\t\t);\n\t}\n}\n\nexport default SecurityPolicy;\nexport { SecurityPolicyBuilder };\n","/**\n * A case-insensitive string key multi-value map object.\n *\n * This map supports `null` values but ignores attempts to add keys with `undefined` values.\n *\n * @alias module:util~MultiMap\n */\nclass MultiMap {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {*} [values] an object who's enumerable properties will be added to this map\n\t */\n\tconstructor(values) {\n\t\tthis.mappings = {}; // map of lower-case header names to {name:X, val:[]} values\n\t\tthis.mappingNames = []; // to keep insertion order\n\t\tif (values) {\n\t\t\tthis.putAll(values);\n\t\t}\n\t}\n\n\t/**\n\t * Add a value.\n\t *\n\t * This method will append values to existing keys.\n\t *\n\t * @param {string} key the key to use\n\t * @param {*} value the value to add; if `undefined` nothing will be added\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tadd(key, value) {\n\t\treturn addValue(this, key, value);\n\t}\n\n\t/**\n\t * Set a value.\n\t *\n\t * This method will replace any existing values with just `value`.\n\t *\n\t * @param {string} key the key to use\n\t * @param {*} value the value to set; if `undefined` nothing will be added\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tput(key, value) {\n\t\treturn addValue(this, key, value, true);\n\t}\n\n\t/**\n\t * Set multiple values.\n\t *\n\t * This method will replace any existing values with those provided on `values`.\n\t *\n\t * @param {*} values an object who's enumerable properties will be added to this map\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tputAll(values) {\n\t\tfor (let key in values) {\n\t\t\tif (values.hasOwnProperty(key)) {\n\t\t\t\taddValue(this, key, values[key], true);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the values associated with a key.\n\t *\n\t * @param {string} key the key of the values to get\n\t * @returns {object[]} the array of values associated with the key, or `undefined` if not available\n\t */\n\tvalue(key) {\n\t\tconst keyLc = key.toLowerCase();\n\t\tconst mapping = this.mappings[keyLc];\n\t\treturn mapping ? mapping.val : undefined;\n\t}\n\n\t/**\n\t * Get the first avaialble value assocaited with a key.\n\t *\n\t * @param {string} key the key of the value to get\n\t * @returns {*} the first available value associated with the key, or `undefined` if not available\n\t */\n\tfirstValue(key) {\n\t\tconst values = this.value(key);\n\t\treturn values && values.length > 0 ? values[0] : undefined;\n\t}\n\n\t/**\n\t * Remove all properties from this map.\n\t *\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tclear() {\n\t\tthis.mappingNames.length = 0;\n\t\tthis.mappings = {};\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all values associated with a key.\n\t *\n\t * @param {string} key the key of the values to remove\n\t * @returns {object[]} the removed values, or `undefined` if no values were present for the given key\n\t */\n\tremove(key) {\n\t\tconst keyLc = key.toLowerCase();\n\t\tconst index = this.mappingNames.indexOf(keyLc);\n\t\tconst result = this.mappings[keyLc];\n\t\tif (result) {\n\t\t\tdelete this.mappings[keyLc];\n\t\t\tthis.mappingNames.splice(index, 1);\n\t\t}\n\t\treturn result ? result.val : undefined;\n\t}\n\n\t/**\n\t * Get the number of entries in this map.\n\t *\n\t * @returns {number} the number of entries in the map\n\t */\n\tsize() {\n\t\treturn this.mappingNames.length;\n\t}\n\n\t/**\n\t * Test if the map is empty.\n\t *\n\t * @returns {boolean} `true` if there are no entries in this map\n\t */\n\tisEmpty() {\n\t\treturn this.size() < 1;\n\t}\n\n\t/**\n\t * Test if there are any values associated with a key.\n\t *\n\t * @param {string} key the key to test\n\t * @returns {boolean} `true` if there is at least one value associated with the key\n\t */\n\tcontainsKey(key) {\n\t\treturn this.value(key) !== undefined;\n\t}\n\n\t/**\n\t * Get an array of all keys in this map.\n\t *\n\t * @returns {string[]} array of keys in this map, or an empty array if the map is empty\n\t */\n\tkeySet() {\n\t\tconst result = [];\n\t\tconst len = this.size();\n\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\tresult.push(this.mappings[this.mappingNames[i]].key);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Add/replace values on a map.\n *\n * @param {module:util~MutliMap} map the map to mutate\n * @param {string} key the key to change\n * @param {*} value the value to add; if `undefined` then nothing will be added\n * @param {boolean} replace if `true` then replace all existing values;\n *                          if `false` append to any existing values\n * @returns {module:util~MutliMap} the passed in `map`\n * @private\n */\nfunction addValue(map, key, value, replace) {\n\tif (value === undefined) {\n\t\treturn map;\n\t}\n\tconst keyLc = key.toLowerCase();\n\tlet mapping = map.mappings[keyLc];\n\tif (!mapping) {\n\t\tmapping = { key: key, val: [] };\n\t\tmap.mappings[keyLc] = mapping;\n\t\tmap.mappingNames.push(keyLc);\n\t}\n\tif (replace) {\n\t\tmapping.val.length = 0;\n\t}\n\tif (Array.isArray(value)) {\n\t\tconst len = value.length;\n\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\tmapping.val.push(value[i]);\n\t\t}\n\t} else {\n\t\tmapping.val.push(value);\n\t}\n\treturn map;\n}\n\nexport default MultiMap;\n","function createGetter(me, prop) {\n\treturn function() {\n\t\treturn me.map[prop];\n\t};\n}\n\nfunction createSetter(me, prop) {\n\treturn function(value) {\n\t\tme.map[prop] = value;\n\t};\n}\n\nfunction createProperty(me, prop) {\n\tObject.defineProperty(me, prop, {\n\t\tenumerable: true,\n\t\tconfigurable: true,\n\t\tget: createGetter(me, prop),\n\t\tset: createSetter(me, prop)\n\t});\n}\n\n/**\n * A configuration utility object.\n *\n * Properties can be get/set by using the {@link module:util~Configuration#value} function.\n * @alias module:util~Configuration\n */\nclass Configuration {\n\t/**\n\t * Constructor.\n\t *\n\t * For any properties passed on `initialMap`, {@link module:util~Configuration#value} will\n\t * be called so those properties are defined on this instance.\n\t *\n\t * @param {object} initialMap the optional initial properties to store\n\t */\n\tconstructor(initialMap) {\n\t\tthis.map = {};\n\t\tif (initialMap !== undefined) {\n\t\t\tthis.values(initialMap);\n\t\t}\n\t}\n\n\t/**\n\t * Test if a key is truthy.\n\t *\n\t * @param {string} key the key to test\n\t * @returns {boolean} `true` if the key is enabled\n\t */\n\tenabled(key) {\n\t\tif (key === undefined) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !!this.map[key];\n\t}\n\n\t/**\n\t * Set or toggle the enabled status of a given key.\n\t *\n\t * <p>If the `enabled` parameter is not passed, then the enabled\n\t * status will be toggled to its opposite value.</p>\n\t *\n\t * @param {string} key they key to set\n\t * @param {boolean} enabled the optional enabled value to set\n\t * @returns {module:util~Configuration} this object to allow method chaining\n\t */\n\ttoggle(key, enabled) {\n\t\tvar val = enabled;\n\t\tif (key === undefined) {\n\t\t\treturn this;\n\t\t}\n\t\tif (val === undefined) {\n\t\t\t// in 1-argument mode, toggle current value\n\t\t\tval = this.map[key] === undefined;\n\t\t}\n\t\treturn this.value(key, val === true ? true : null);\n\t}\n\n\t/**\n\t * Get or set a configuration value.\n\t *\n\t * @param {string} key The key to get or set the value for\n\t * @param {object} [newValue] If defined, the new value to set for the given `key`.\n\t *                            If `null` then the value will be removed.\n\t * @returns {object} If called as a getter, the associated value for the given `key`,\n\t *                   otherwise this object.\n\t */\n\tvalue(key, newValue) {\n\t\tif (arguments.length === 1) {\n\t\t\treturn this.map[key];\n\t\t}\n\t\tif (newValue === null) {\n\t\t\tdelete this.map[key];\n\t\t\tif (this.hasOwnProperty(key)) {\n\t\t\t\tdelete this[key];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.map[key] = newValue;\n\t\t\tif (!this.hasOwnProperty(key)) {\n\t\t\t\tcreateProperty(this, key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set multiple properties.\n\t *\n\t * @param {object} [newMap] a map of values to set\n\t * @returns {object} if called as a getter, all properties of this object copied into a simple object;\n\t *                   otherwise this object\n\t */\n\tvalues(newMap) {\n\t\tif (newMap) {\n\t\t\tfor (let prop in newMap) {\n\t\t\t\tif (newMap.hasOwnProperty(prop)) {\n\t\t\t\t\tthis.value(prop, newMap[prop]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\treturn Object.assign({}, this.map);\n\t}\n}\n\nexport default Configuration;\n","import Configuration from \"../util/configuration\";\n\n/**\n * Normailze a protocol value.\n *\n * This method is used to normalize protocol values which might come from a `Location`\n * object and thus contain a trailing colon.\n *\n * @param {String} [val] the protocol value to normalize\n * @returns {String} the normalized protocol value\n * @alias module:net~normalizedProtocol\n */\nfunction normalizedProtocol(val) {\n\tif (!val) {\n\t\treturn \"https\";\n\t}\n\treturn val.replace(/:$/, \"\");\n}\n\n/**\n * Normalize the environment configuration.\n *\n * Passing a browser `Location` object, like `window.location`, is supported. The\n * `protocol`, `hostname`, and `port` values will be used.\n *\n * @param {Object} [config] the initial configuration\n * @returns {Object} a new object with normalized configuration values\n * @alias module:net~normalizedConfig\n */\nfunction normalizedConfig(config) {\n\tvar result = Object.assign(\n\t\t{\n\t\t\thost: \"data.solarnetwork.net\"\n\t\t},\n\t\tconfig\n\t);\n\tresult.protocol = normalizedProtocol(result.protocol || \"https\");\n\tresult.port = result.port || (result.protocol === \"https\" ? 443 : 80);\n\tresult.host = result.port && result.hostname ? result.hostname : result.host;\n\treturn result;\n}\n\n/**\n * An environment configuration utility object.\n *\n * This extends {@link module:util~Configuration} to add support for standard properties\n * needed to access the SolarNetwork API, such as host and protocol values.\n *\n * @extends module:util~Configuration\n * @alias module:net~Environment\n */\nclass Environment extends Configuration {\n\t/**\n\t * Constructor.\n\t *\n\t * This will define the following default properties, if not supplied on the\n\t * `config` argument:\n\t *\n\t * <dl>\n\t * <dt>host</dt><dd>`data.solarnetwork.net`</dd>\n\t * <dt>protocol</dt><dd>`https`</dd>\n\t * <dt>port</dt><dd>`443`</dd>\n\t * </dl>\n\t *\n\t * These properties correspond to those on the `window.location` object when\n\t * running in a browser. Thus to construct an environment based on the location\n\t * of the current page you can create an instance like this:\n\t *\n\t * ```\n\t * const env = new Environment(window.location);\n\t * ```\n\t *\n\t * @param {Object} [config] an optional set of properties to start with\n\t */\n\tconstructor(config) {\n\t\tsuper(normalizedConfig(config));\n\t}\n\n\t/**\n\t * Check if TLS is in use via the `https` protocol.\n\t *\n\t * @returns {boolean} `true` if the `protocol` is set to `https`\n\t */\n\tuseTls() {\n\t\treturn this.value(\"protocol\") === \"https\";\n\t}\n}\n\nexport default Environment;\n","/**\n * Parse the query portion of a URL string, and return a parameter object for the\n * parsed key/value pairs.\n *\n * <p>Multiple parameters of the same name will be stored as an array on the returned object.</p>\n *\n * @param {string} search the query portion of the URL, which may optionally include\n *                        the leading `?` character\n * @param {Set<String>} [multiValueKeys] if provided, a set of keys for which to always treat\n *                                       as a multi-value array, even if there is only one value\n * @return {object} the parsed query parameters, as a parameter object\n * @alias module:net~urlQueryParse\n */\nfunction urlQueryParse(search, multiValueKeys) {\n\tvar params = {};\n\tvar pairs;\n\tvar pair;\n\tvar i, len, k, v;\n\tif (search !== undefined && search.length > 0) {\n\t\t// remove any leading ? character\n\t\tif (search.match(/^\\?/)) {\n\t\t\tsearch = search.substring(1);\n\t\t}\n\t\tpairs = search.split(\"&\");\n\t\tfor (i = 0, len = pairs.length; i < len; i++) {\n\t\t\tpair = pairs[i].split(\"=\", 2);\n\t\t\tif (pair.length === 2) {\n\t\t\t\tk = decodeURIComponent(pair[0]);\n\t\t\t\tv = decodeURIComponent(pair[1]);\n\t\t\t\tif (params[k]) {\n\t\t\t\t\tif (!Array.isArray(params[k])) {\n\t\t\t\t\t\tparams[k] = [params[k]]; // turn into array;\n\t\t\t\t\t}\n\t\t\t\t\tparams[k].push(v);\n\t\t\t\t} else if (multiValueKeys && multiValueKeys.has(k)) {\n\t\t\t\t\tparams[k] = [v];\n\t\t\t\t} else {\n\t\t\t\t\tparams[k] = v;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn params;\n}\n\n/**\n * Encode the properties of an object as a URL query string.\n *\n * <p>If an object property has an array value, multiple URL parameters will be encoded for that property.</p>\n *\n * <p>The optional `encoderFn` argument is a function that accepts a string value\n * and should return a URI-safe string for that value.</p>\n *\n * @param {object} parameters an object to encode as URL parameters\n * @param {function} encoderFn an optional function to encode each URI component with;\n *                             if not provided the built-in `encodeURIComponent()` function\n *                             will be used\n * @return {string} the encoded query parameters\n * @alias module:net~urlQueryEncode\n */\nfunction urlQueryEncode(parameters, encoderFn) {\n\tvar result = \"\",\n\t\tprop,\n\t\tval,\n\t\ti,\n\t\tlen;\n\tconst encoder = encoderFn || encodeURIComponent;\n\tfunction handleValue(k, v) {\n\t\tif (result.length) {\n\t\t\tresult += \"&\";\n\t\t}\n\t\tresult += encoder(k) + \"=\" + encoder(v);\n\t}\n\tif (parameters) {\n\t\tfor (prop in parameters) {\n\t\t\tif (parameters.hasOwnProperty(prop)) {\n\t\t\t\tval = parameters[prop];\n\t\t\t\tif (Array.isArray(val)) {\n\t\t\t\t\tfor (i = 0, len = val.length; i < len; i++) {\n\t\t\t\t\t\thandleValue(prop, val[i]);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\thandleValue(prop, val);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nexport { urlQueryParse, urlQueryEncode };\n\nexport default {\n\turlQueryParse: urlQueryParse,\n\turlQueryEncode: urlQueryEncode\n};\n","import Base64 from \"crypto-js/enc-base64\";\nimport Hex from \"crypto-js/enc-hex\";\nimport HmacSHA256 from \"crypto-js/hmac-sha256\";\nimport SHA256 from \"crypto-js/sha256\";\nimport { parse as uriParse } from \"uri-js\";\n\nimport { iso8601Date } from \"../format/date\";\nimport MultiMap from \"../util/multiMap\";\nimport Environment from \"./environment\";\nimport { HttpMethod, default as HttpHeaders } from \"./httpHeaders\";\nimport { urlQueryParse } from \"./urlQuery\";\n\n/**\n * The number of milliseconds a signing key is valid for.\n * @type {number}\n * @private\n */\nconst SIGNING_KEY_VALIDITY = 7 * 24 * 60 * 60 * 1000;\n\n/**\n * A builder object for the SNWS2 HTTP authorization scheme.\n *\n * This builder can be used to calculate a one-off header value, for example:\n *\n * ```\n * let authHeader = new AuthorizationV2Builder(\"my-token\")\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .build(\"my-token-secret\");\n * ```\n *\n * Or the builder can be re-used for a given token:\n *\n * ```\n * // create a builder for a token\n * let builder = new AuthorizationV2Builder(\"my-token\");\n *\n * // elsewhere, re-use the builder for repeated requests\n * builder.reset()\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .build(\"my-token-secret\");\n * ```\n *\n * Additionally, a signing key can be generated and re-used for up to 7 days:\n *\n * ```\n * // create a builder for a token\n * let builder = new AuthorizationV2Builder(\"my-token\")\n *   .saveSigningKey(\"my-token-secret\");\n *\n * // elsewhere, re-use the builder for repeated requests\n * builder.reset()\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .buildWithSavedKey(); // note previously generated key used\n * ```\n *\n * ## Post requests\n *\n * For handling `POST` or `PUT` requests, you must make sure to configure the properties of\n * this class to match your actual HTTP request:\n *\n *  1. Use the {@link module:net~AuthorizationV2Builder#method} method to configure the HTTP verb (you can use the {@link module:net~HttpMethod} constants).\n *  2. Use the {@link module:net~AuthorizationV2Builder#contentType} method to configure the same value that will be used for the HTTP `Content-Type` header (you can use the {@link module:net~HttpContentType} constants).\n *  3. **If** the content type is `application/x-www-form-urlencoded` then you should use the {@link module:net~AuthorizationV2Builder#queryParams} method to configure the request parameters.\n *  4. **If** the content type is **not** `application/x-www-form-urlencoded` then you should use the {@link module:net~AuthorizationV2Builder#computeContentDigest} method to configure a HTTP `Digest` header.\n *\n * ```\n * // create a builder for a token\n * let builder = new AuthorizationV2Builder(\"my-token\")\n *   .saveSigningKey(\"my-token-secret\");\n *\n * // POST request with form data\n * builder.reset()\n *     .method(HttpHeaders.POST)\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .contentType(HttpContentType.FORM_URLENCODED_UTF8)\n *     .queryParams({foo:\"bar\"})\n *     .buildWithSavedKey();\n *\n * // PUT request with JSON data, with XHR style request\n * let reqJson = JSON.stringify({foo:\"bar\"});\n * builder.reset()\n *     .method(HttpHeaders.PUT)\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .contentType(HttpContentType.APPLICATION_JSON_UTF8)\n *     .computeContentDigest(reqJson);\n *\n * // when making actual HTTP request, re-use the computed HTTP Digest header:\n * xhr.setRequestHeader(\n *     HttpHeaders.DIGEST,\n *     builder.httpHeaders.firstValue(HttpHeaders.DIGEST)\n * );\n * xhr.setRequestHeader(HttpHeaders.X_SN_DATE, builder.requestDateHeaderValue);\n * xhr.setRequestHeader(HttpHeaders.AUTHORIZATION, builder.buildWithSavedKey());\n * ```\n * @alias module:net~AuthorizationV2Builder\n */\nclass AuthorizationV2Builder {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} token the auth token to use\n\t * @param {module:net~Environment} [environment] the environment to use; if not provided a default environment will be created\n\t */\n\tconstructor(token, environment) {\n\t\t/**\n\t\t * The SolarNet auth token value.\n\t\t * @member {string}\n\t\t */\n\t\tthis.tokenId = token;\n\n\t\t/**\n\t\t * The SolarNet environment.\n\t\t * @member {module:net~Environment}\n\t\t */\n\t\tthis.environment = environment || new Environment();\n\n\t\t/**\n\t\t * Force a port number to be added to host values, even if port would be implied.\n\t\t *\n\t\t * This can be useful when working with a server behind a proxy, where the\n\t\t * proxy is configured to always forward the port even if the port is implied\n\t\t * (i.e. HTTPS is used on the standard port 443).\n\t\t *\n\t\t * @member {boolean}\n\t\t */\n\t\tthis.forceHostPort = false;\n\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Reset to defalut property values.\n\t *\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\treset() {\n\t\tthis.contentDigest = null;\n\t\tthis.httpHeaders = new HttpHeaders();\n\t\tthis.parameters = new MultiMap();\n\t\tthis.signedHeaderNames = [];\n\t\tvar host = this.environment.host;\n\t\treturn this.method(HttpMethod.GET)\n\t\t\t.host(host)\n\t\t\t.path(\"/\")\n\t\t\t.date(new Date());\n\t}\n\n\t/**\n\t * Compute and cache the signing key.\n\t *\n\t * Signing keys are derived from the token secret and valid for 7 days, so\n\t * this method can be used to compute a signing key so that {@link module:net~AuthorizationV2Builder#build}\n\t * can be called later. The signing date will be set to whatever date is\n\t * currently configured via {@link module:net~AuthorizationV2Builder#date}, which defaults to the\n\t * current time for newly created builder instances.\n\t *\n\t * @param {string} tokenSecret the secret to sign the digest with\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tsaveSigningKey(tokenSecret) {\n\t\tthis.signingKey = this.computeSigningKey(tokenSecret);\n\t\tthis.signingKeyExpiration = new Date(this.requestDate.getTime() + SIGNING_KEY_VALIDITY);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Test if a signing key is present and not expired.\n\t * @readonly\n\t * @type {boolean}\n\t */\n\tget signingKeyValid() {\n\t\treturn this.signingKey &&\n\t\t\tthis.signingKeyExpiration instanceof Date &&\n\t\t\tDate.now() < this.signingKeyExpiration.getTime()\n\t\t\t? true\n\t\t\t: false;\n\t}\n\n\t/**\n\t * Set the HTTP method (verb) to use.\n\t *\n\t * @param {string} val the method to use; see the {@link HttpMethod} enum for possible values\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tmethod(val) {\n\t\tthis.httpMethod = val;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HTTP host.\n\t *\n\t * This is a shortcut for calling `HttpHeaders#put(HttpHeaders.HOST, val)`.\n\t *\n\t * @param {string} val the HTTP host value to use\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\thost(val) {\n\t\tif (this.forceHostPort && val.indexOf(\":\") < 0 && this.environment.port != 80) {\n\t\t\tval += \":\" + this.environment.port;\n\t\t}\n\t\tthis.httpHeaders.put(HttpHeaders.HOST, val);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HTTP request path to use.\n\t *\n\t * @param {string} val the request path to use\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tpath(val) {\n\t\tthis.requestPath = val;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the host, path, and query parameters via a URL string.\n\t *\n\t * @param {string} url the URL value to use\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\turl(url) {\n\t\tconst uri = uriParse(url);\n\t\tlet host = uri.host;\n\t\tif (\n\t\t\turi.port &&\n\t\t\t(((uri.scheme === \"https\" || uri.scheme === \"wss\") && uri.port !== 443) ||\n\t\t\t\t((uri.scheme === \"http\" || uri.scheme === \"ws\") && uri.port !== 80))\n\t\t) {\n\t\t\thost += \":\" + uri.port;\n\t\t}\n\t\tif (uri.query) {\n\t\t\tthis.queryParams(urlQueryParse(uri.query));\n\t\t}\n\t\treturn this.host(host).path(uri.path);\n\t}\n\n\t/**\n\t * Set the HTTP content type.\n\t *\n\t * This is a shortcut for calling {@link HttpHeaders#put} with the key {@link HttpHeaders#CONTENT_TYPE}.\n\t *\n\t * @param {string} val the HTTP content type value to use\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tcontentType(val) {\n\t\tthis.httpHeaders.put(HttpHeaders.CONTENT_TYPE, val);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the authorization request date.\n\t *\n\t * @param {Date} val the date to use; typically the current time, e.g. `new Date()`\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tdate(val) {\n\t\tthis.requestDate = val ? val : new Date();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The authorization request date as a HTTP header string value.\n\t *\n\t * @readonly\n\t * @type {string}\n\t */\n\tget requestDateHeaderValue() {\n\t\treturn this.requestDate.toUTCString();\n\t}\n\n\t/**\n\t * Control using the `X-SN-Date` HTTP header versus the `Date` header.\n\t *\n\t * <p>Set to `true` to use the `X-SN-Date` header, `false` to use\n\t * the `Date` header. This will return `true` if `X-SN-Date` has been\n\t * added to the `signedHeaderNames` property or has been added to the `httpHeaders`\n\t * property.</p>\n\t *\n\t * @type {boolean}\n\t */\n\tget useSnDate() {\n\t\tlet signedHeaders = this.signedHeaderNames;\n\t\tlet existingIndex = Array.isArray(signedHeaders)\n\t\t\t? signedHeaders.findIndex(caseInsensitiveEqualsFn(HttpHeaders.X_SN_DATE))\n\t\t\t: -1;\n\t\treturn existingIndex >= 0 || this.httpHeaders.containsKey(HttpHeaders.X_SN_DATE);\n\t}\n\n\tset useSnDate(enabled) {\n\t\tlet signedHeaders = this.signedHeaderNames;\n\t\tlet existingIndex = Array.isArray(signedHeaders)\n\t\t\t? signedHeaders.findIndex(caseInsensitiveEqualsFn(HttpHeaders.X_SN_DATE))\n\t\t\t: -1;\n\t\tif (enabled && existingIndex < 0) {\n\t\t\tsignedHeaders = signedHeaders\n\t\t\t\t? signedHeaders.concat(HttpHeaders.X_SN_DATE)\n\t\t\t\t: [HttpHeaders.X_SN_DATE];\n\t\t\tthis.signedHeaderNames = signedHeaders;\n\t\t} else if (!enabled && existingIndex >= 0) {\n\t\t\tsignedHeaders.splice(existingIndex, 1);\n\t\t\tthis.signedHeaderNames = signedHeaders;\n\t\t}\n\n\t\t// also clear from httpHeaders\n\t\tthis.httpHeaders.remove(HttpHeaders.X_SN_DATE);\n\t}\n\n\t/**\n\t * Set the `useSnDate` property.\n\t *\n\t * @param {boolean} enabled `true` to use the `X-SN-Date` header, `false` to use `Date`\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tsnDate(enabled) {\n\t\tthis.useSnDate = enabled;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a HTTP header value.\n\t *\n\t * This is a shortcut for calling `HttpHeaders#put(headerName, val)`.\n\t *\n\t * @param {string} headerName the header name to set\n\t * @param {string} headerValue the header value to set\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\theader(headerName, headerValue) {\n\t\tthis.httpHeaders.put(headerName, headerValue);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HTTP headers to use with the request.\n\t *\n\t * The headers object must include all headers necessary by the\n\t * authentication scheme, and any additional headers also configured via\n\t * {@link module:net~AuthorizationV2Builder#signedHttpHeaders}.\n\t *\n\t * @param {HttpHeaders} headers the HTTP headers to use\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\theaders(headers) {\n\t\tthis.httpHeaders = headers;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HTTP `GET` query parameters, or `POST` form-encoded\n\t * parameters.\n\t *\n\t * @param {MultiMap|Object} params the parameters to use, as either a {@link MultiMap} or simple `Object`\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tqueryParams(params) {\n\t\tif (params instanceof MultiMap) {\n\t\t\tthis.parameters = params;\n\t\t} else {\n\t\t\tthis.parameters.putAll(params);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set additional HTTP header names to sign with the authentication.\n\t *\n\t * @param {sring[]} signedHeaderNames additional HTTP header names to include in the signature\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tsignedHttpHeaders(signedHeaderNames) {\n\t\tthis.signedHeaderNames = signedHeaderNames;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the HTTP request body content SHA-256 digest value.\n\t *\n\t * @param {string|module:crypto-js/enc-hex~WordArray} digest the digest value to use; if a string it is assumed to be Hex encoded\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tcontentSHA256(digest) {\n\t\tvar contentDigest;\n\t\tif (typeof digest === \"string\") {\n\t\t\tcontentDigest = Hex.parse(digest);\n\t\t} else {\n\t\t\tcontentDigest = digest;\n\t\t}\n\t\tthis.contentDigest = contentDigest;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Compute the SHA-256 digest of the request body content and configure the result on this builder.\n\t *\n\t * This method will compute the digest and then save the result via the {@link module:net~AuthorizationV2Builder#contentSHA256}\n\t * method. In addition, it will set the `Digest` HTTP header value via {@link module:net~AuthorizationV2Builder#header}.\n\t * This means you _must_ also pass the `Digest` HTTP header with the request. After calling this\n\t * method, you can retrieve the `Digest` HTTP header value via the `httpHeaders`property.\n\t *\n\t * @param {string} content the request body content to compute a SHA-256 digest value from\n\t * @returns {module:net~AuthorizationV2Builder} this object\n\t */\n\tcomputeContentDigest(content) {\n\t\tvar digest = SHA256(content);\n\t\tthis.contentSHA256(digest);\n\t\tthis.header(\"Digest\", \"sha-256=\" + Base64.stringify(digest));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Compute the canonical query parameters.\n\t *\n\t * @returns {string} the canonical query parameters string value\n\t */\n\tcanonicalQueryParameters() {\n\t\tconst keys = this.parameters.keySet();\n\t\tif (keys.length < 1) {\n\t\t\treturn \"\";\n\t\t}\n\t\tkeys.sort();\n\t\tconst len = keys.length;\n\t\tvar first = true,\n\t\t\tresult = \"\";\n\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\tlet key = keys[i];\n\t\t\tlet vals = this.parameters.value(key);\n\t\t\tconst valsLen = vals.length;\n\t\t\tfor (let j = 0; j < valsLen; j += 1) {\n\t\t\t\tif (first) {\n\t\t\t\t\tfirst = false;\n\t\t\t\t} else {\n\t\t\t\t\tresult += \"&\";\n\t\t\t\t}\n\t\t\t\tresult += _encodeURIComponent(key) + \"=\" + _encodeURIComponent(vals[j]);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compute the canonical HTTP headers string value.\n\t *\n\t * @param {string[]} sortedLowercaseHeaderNames the sorted, lower-cased HTTP header names to include\n\t * @returns {string} the canonical headers string value\n\t */\n\tcanonicalHeaders(sortedLowercaseHeaderNames) {\n\t\tvar result = \"\",\n\t\t\theaderName,\n\t\t\theaderValue;\n\t\tconst len = sortedLowercaseHeaderNames.length;\n\t\tfor (let i = 0; i < len; i += 1) {\n\t\t\theaderName = sortedLowercaseHeaderNames[i];\n\t\t\tif (\"date\" === headerName || \"x-sn-date\" === headerName) {\n\t\t\t\theaderValue = this.requestDate.toUTCString();\n\t\t\t} else {\n\t\t\t\theaderValue = this.httpHeaders.firstValue(headerName);\n\t\t\t}\n\t\t\tresult += headerName + \":\" + (headerValue ? headerValue.trim() : \"\") + \"\\n\";\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compute the canonical signed header names value from an array of HTTP header names.\n\t *\n\t * @param {string[]} sortedLowercaseHeaderNames the sorted, lower-cased HTTP header names to include\n\t * @returns {string} the canonical signed header names string value\n\t * @private\n\t */\n\tcanonicalSignedHeaderNames(sortedLowercaseHeaderNames) {\n\t\treturn sortedLowercaseHeaderNames.join(\";\");\n\t}\n\n\t/**\n\t * Get the canonical request content SHA256 digest, hex encoded.\n\t *\n\t * @returns {string} the hex-encoded SHA256 digest of the request content\n\t */\n\tcanonicalContentSHA256() {\n\t\treturn this.contentDigest\n\t\t\t? Hex.stringify(this.contentDigest)\n\t\t\t: AuthorizationV2Builder.EMPTY_STRING_SHA256_HEX;\n\t}\n\n\t/**\n\t * Compute the canonical HTTP header names to include in the signature.\n\t *\n\t * @returns {string[]} the sorted, lower-cased HTTP header names to include\n\t */\n\tcanonicalHeaderNames() {\n\t\tconst httpHeaders = this.httpHeaders;\n\t\tconst signedHeaderNames = this.signedHeaderNames;\n\n\t\t// use a MultiMap to take advantage of case-insensitive keys\n\t\tconst map = new MultiMap();\n\n\t\tmap.put(HttpHeaders.HOST, true);\n\t\tif (this.useSnDate) {\n\t\t\tmap.put(HttpHeaders.X_SN_DATE, true);\n\t\t} else {\n\t\t\tmap.put(HttpHeaders.DATE, true);\n\t\t}\n\t\tif (httpHeaders.containsKey(HttpHeaders.CONTENT_MD5)) {\n\t\t\tmap.put(HttpHeaders.CONTENT_MD5, true);\n\t\t}\n\t\tif (httpHeaders.containsKey(HttpHeaders.CONTENT_TYPE)) {\n\t\t\tmap.put(HttpHeaders.CONTENT_TYPE, true);\n\t\t}\n\t\tif (httpHeaders.containsKey(HttpHeaders.DIGEST)) {\n\t\t\tmap.put(HttpHeaders.DIGEST, true);\n\t\t}\n\t\tif (signedHeaderNames && signedHeaderNames.length > 0) {\n\t\t\tsignedHeaderNames.forEach(e => map.put(e, true));\n\t\t}\n\t\treturn lowercaseSortedArray(map.keySet());\n\t}\n\n\t/**\n\t * Compute the canonical request data that will be included in the data to sign with the request.\n\t *\n\t * @returns {string} the canonical request data\n\t */\n\tbuildCanonicalRequestData() {\n\t\treturn this.computeCanonicalRequestData(this.canonicalHeaderNames());\n\t}\n\n\t/**\n\t * Compute the canonical request data that will be included in the data to sign with the request,\n\t * using a specific set of HTTP header names to sign.\n\t *\n\t * @param {string[]} sortedLowercaseHeaderNames the sorted, lower-cased HTTP header names to sign with the request\n\t * @returns {string} the canonical request data\n\t * @private\n\t */\n\tcomputeCanonicalRequestData(sortedLowercaseHeaderNames) {\n\t\t// 1: HTTP verb\n\t\tvar result = this.httpMethod + \"\\n\";\n\n\t\t// 2: Canonical URI\n\t\tresult += this.requestPath + \"\\n\";\n\n\t\t// 3: Canonical query string\n\t\tresult += this.canonicalQueryParameters() + \"\\n\";\n\n\t\t// 4: Canonical headers\n\t\tresult += this.canonicalHeaders(sortedLowercaseHeaderNames); // already includes newline\n\n\t\t// 5: Signed header names\n\t\tresult += this.canonicalSignedHeaderNames(sortedLowercaseHeaderNames) + \"\\n\";\n\n\t\t// 6: Content SHA256, hex encoded\n\t\tresult += this.canonicalContentSHA256();\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compute the signing key, from a secret key.\n\t *\n\t * @param {string} secretKey the secret key string\n\t * @returns {CryptoJS#Hash} the computed key\n\t * @private\n\t */\n\tcomputeSigningKey(secretKey) {\n\t\tconst datestring = iso8601Date(this.requestDate);\n\t\tconst key = HmacSHA256(\"snws2_request\", HmacSHA256(datestring, \"SNWS2\" + secretKey));\n\t\treturn key;\n\t}\n\n\t/**\n\t * Compute the data to be signed by the signing key.\n\t *\n\t * @param {string} canonicalRequestData the request data, returned from {@link module:net~AuthorizationV2Builder#buildCanonicalRequestData}\n\t * @returns {string} the data to sign\n\t * @private\n\t */\n\tcomputeSignatureData(canonicalRequestData) {\n\t\t/*- signature data is like:\n\n            SNWS2-HMAC-SHA256\\n\n            20170301T120000Z\\n\n            Hex(SHA256(canonicalRequestData))\n        */\n\t\treturn (\n\t\t\t\"SNWS2-HMAC-SHA256\\n\" +\n\t\t\tiso8601Date(this.requestDate, true) +\n\t\t\t\"\\n\" +\n\t\t\tHex.stringify(SHA256(canonicalRequestData))\n\t\t);\n\t}\n\n\t/**\n\t * Compute a HTTP `Authorization` header value from the configured properties\n\t * on the builder, using the provided signing key.\n\t *\n\t * @param {CryptoJS#Hash} signingKey the key to sign the computed signature data with\n\t * @returns {string} the SNWS2 HTTP Authorization header value\n\t * @private\n\t */\n\tbuildWithKey(signingKey) {\n\t\tconst sortedHeaderNames = this.canonicalHeaderNames();\n\t\tconst canonicalReq = this.computeCanonicalRequestData(sortedHeaderNames);\n\t\tconst signatureData = this.computeSignatureData(canonicalReq);\n\t\tconst signature = Hex.stringify(HmacSHA256(signatureData, signingKey));\n\t\tlet result =\n\t\t\t\"SNWS2 Credential=\" +\n\t\t\tthis.tokenId +\n\t\t\t\",SignedHeaders=\" +\n\t\t\tsortedHeaderNames.join(\";\") +\n\t\t\t\",Signature=\" +\n\t\t\tsignature;\n\t\treturn result;\n\t}\n\n\t/**\n\t * Compute a HTTP `Authorization` header value from the configured\n\t * properties on the builder, computing a new signing key based on the\n\t * configured {@link module:net~AuthorizationV2Builder#date}.\n\t *\n\t * @param {string} tokenSecret the secret to sign the authorization with\n\t * @return {string} the SNWS2 HTTP Authorization header value\n\t */\n\tbuild(tokenSecret) {\n\t\tconst signingKey = this.computeSigningKey(tokenSecret);\n\t\treturn this.buildWithKey(signingKey);\n\t}\n\n\t/**\n\t * Compute a HTTP `Authorization` header value from the configured\n\t * properties on the builder, using a signing key configured from a previous\n\t * call to {@link module:net~AuthorizationV2Builder#saveSigningKey}.\n\t *\n\t * @return {string} the SNWS2 HTTP Authorization header value.\n\t */\n\tbuildWithSavedKey() {\n\t\treturn this.buildWithKey(this.signingKey);\n\t}\n}\n\n/**\n * @function stringMatchFn\n * @param {string} e the element to test\n * @returns {boolean} `true` if the element matches\n * @private\n */\n\n/**\n * Create a case-insensitive string matching function.\n *\n * @param {string} value the string to perform the case-insensitive comparison against\n * @returns {stringMatchFn} a matching function that performs a case-insensitive comparison\n * @private\n */\nfunction caseInsensitiveEqualsFn(value) {\n\tconst valueLc = value.toLowerCase();\n\treturn e => valueLc === e.toString().toLowerCase();\n}\n\n/**\n * Create a new array of lower-cased and sorted strings from another array.\n *\n * @param {string[]} items the items to lower-case and sort\n * @returns {string[]} a new array of the lower-cased and sorted items\n * @private\n */\nfunction lowercaseSortedArray(items) {\n\tconst sortedItems = [];\n\tconst len = items.length;\n\tfor (let i = 0; i < len; i += 1) {\n\t\tsortedItems.push(items[i].toLowerCase());\n\t}\n\tsortedItems.sort();\n\treturn sortedItems;\n}\n\nfunction _hexEscapeChar(c) {\n\treturn (\n\t\t\"%\" +\n\t\tc\n\t\t\t.charCodeAt(0)\n\t\t\t.toString(16)\n\t\t\t.toUpperCase()\n\t);\n}\n\nfunction _encodeURIComponent(str) {\n\treturn encodeURIComponent(str).replace(/[!'()*]/g, _hexEscapeChar);\n}\n\nObject.defineProperties(AuthorizationV2Builder, {\n\t/**\n\t * The hex-encoded value for an empty SHA256 digest value.\n\t *\n\t * @memberof AuthorizationV2Builder\n\t * @readonly\n\t * @type {string}\n\t */\n\tEMPTY_STRING_SHA256_HEX: {\n\t\tvalue: \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n\t},\n\n\t/**\n\t * The SolarNetwork V2 authorization scheme.\n\t *\n\t * @memberof AuthorizationV2Builder\n\t * @readonly\n\t * @type {string}\n\t */\n\tSNWS2_AUTH_SCHEME: { value: \"SNWS2\" }\n});\n\nexport default AuthorizationV2Builder;\n","/* eslint no-console: 0 */\n\nlet logLevel = 2;\n\nfunction consoleLog(level, ...args) {\n\tif (level > logLevel) {\n\t\treturn;\n\t}\n\tif (!console) {\n\t\treturn;\n\t}\n\n\tlet logFn;\n\tswitch (level) {\n\t\tcase 1:\n\t\t\tlogFn = console.error;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tlogFn = console.warn;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tlogFn = console.info;\n\t\t\tbreak;\n\t}\n\tif (!logFn) {\n\t\tlogFn = console.log;\n\t}\n\tif (!logFn) {\n\t\treturn; // no console available\n\t}\n\tlogFn(...args); // TODO formatting like sn.format.fmt.apply(this, arguments)?\n}\n\nconst logLevels = Object.freeze({\n\tDEBUG: 4,\n\tINFO: 3,\n\tWARN: 2,\n\tERROR: 1,\n\tOFF: 0\n});\n\n/**\n * An application logger.\n *\n * Logging levels range from 0-4 and is controlled at the application level.\n * Level `0` is off, `1` is error, `2` is warn, `3` is info,  and `4` is debug.\n * The default level starts as `2`.\n */\nclass Logger {\n\tstatic debug(...args) {\n\t\tconsoleLog(4, ...args);\n\t}\n\n\tstatic info(...args) {\n\t\tconsoleLog(3, ...args);\n\t}\n\n\tstatic warn(...args) {\n\t\tconsoleLog(2, ...args);\n\t}\n\n\tstatic error(...args) {\n\t\tconsoleLog(1, ...args);\n\t}\n}\n\nObject.defineProperties(Logger, {\n\t/**\n\t * The global logging level. Set to `0` to disable all logging.\n\t *\n\t * @memberof module:util~Logger\n\t * @type {number}\n\t */\n\tlevel: {\n\t\tget: function() {\n\t\t\treturn logLevel;\n\t\t},\n\t\tset: function(v) {\n\t\t\tlogLevel = typeof v === \"number\" ? v : 0;\n\t\t}\n\t}\n});\n\nexport default Logger;\nexport { logLevels };\n","/**\n * Normalize a data array of time series data based on an aggregate time step.\n *\n * This method is useful for \"filling in\" gaps of data in situations where something expects\n * the data include placeholders for the gaps. Charting applications often expect this, for\n * example.\n *\n * Each element in the `data` array is expected to provide a `date` property that is a `Date`\n * object. When gaps are discovered in the array, \"filler\" objects will be inserted with\n * an approprate `date` value and all other properties copied from the previous element but\n * set to `null`.\n *\n * Here's an example where a new element is added to an array to fill in a missing time slot:\n *\n * ```\n * const queryData = [\n *     {date : new Date('2018-05-05T11:00Z'), Generation : 357, Consumption: 345},\n *     {date : new Date('2018-05-05T12:00Z'), Generation : 1023, Consumption: 678}\n * ]\n *\n * timeNormalizeDataArray(queryData, Aggregations.ThirtyMinute);\n * ```\n *\n * Then `queryData` would look like this:\n *\n * ```\n * [\n *     {date : new Date('2018-05-05T11:00Z'), Generation : 357, Consumption: 345},\n *     {date : new Date('2018-05-05T11:30Z'), Generation : null, Consumption: null},\n *     {date : new Date('2018-05-05T12:00Z'), Generation : 1023, Consumption: 678}\n * ]\n * ```\n *\n * @param {object[]} data the raw data returned from SolarNetwork; this array is modified in-place\n * @param {module:domain~Aggregation} aggregate the expected aggregate level of the data\n * @returns {void}\n * @alias module:data~timeNormalizeDataArray\n */\nexport function timeNormalizeDataArray(data, aggregate) {\n\tconst aggMillseconds = aggregate.level * 1000;\n\tif (!Array.isArray(data) || data.length < 2) {\n\t\treturn data;\n\t}\n\tvar i = 0;\n\twhile (i < data.length - 1) {\n\t\tconst d = data[i];\n\t\tconst currTime = d.date.getTime();\n\t\tconst expectedNextTime = currTime + aggMillseconds;\n\t\tlet nextTime = data[i + 1].date.getTime();\n\t\tif (nextTime > expectedNextTime) {\n\t\t\tlet fill = [i + 1, 0];\n\t\t\tfor (\n\t\t\t\tlet fillTime = currTime + aggMillseconds;\n\t\t\t\tfillTime < nextTime;\n\t\t\t\tfillTime += aggMillseconds\n\t\t\t) {\n\t\t\t\tlet f = Object.create(\n\t\t\t\t\tObject.getPrototypeOf(d),\n\t\t\t\t\tObject.getOwnPropertyDescriptors(d)\n\t\t\t\t);\n\t\t\t\tfor (let p in f) {\n\t\t\t\t\tf[p] = null;\n\t\t\t\t}\n\t\t\t\tf.date = new Date(fillTime);\n\t\t\t\tfill.push(f);\n\t\t\t}\n\t\t\tArray.prototype.splice.apply(data, fill);\n\t\t\ti += fill.length;\n\t\t}\n\t\ti += 1;\n\t}\n}\n\nexport default Object.freeze({\n\ttimeNormalizeDataArray: timeNormalizeDataArray\n});\n","/**\n * An enumerated object base class.\n *\n * This class is essentially abstract, and must be extended by another\n * class that overrides the {@link module:util~Enum.enumValues} method.\n *\n * @abstract\n * @alias module:util~Enum\n */\nclass Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t */\n\tconstructor(name) {\n\t\tthis._name = name;\n\t\tif (this.constructor === Enum) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the enum name.\n\t *\n\t * @returns {string} the  name\n\t */\n\tget name() {\n\t\treturn this._name;\n\t}\n\n\t/**\n\t * Test if a string is equal to this enum's name.\n\t *\n\t * As long as enum values are consistently obtained from the {@link module:util~Enum.enumValues}\n\t * array then enum instances can be compared with `===`. If unsure, this method can be used\n\t * to compare string values instead.\n\t *\n\t * If `value` is passed as an actual Enum instance, then if that enum is the same class\n\t * as this enum it's `name` is compared to this instance's `name`.\n\t *\n\t * @param {string|Enum} value the value to test\n\t * @returns {boolean} `true` if `value` is the same as this instance's `name` value\n\t */\n\tequals(value) {\n\t\tif (this.constructor === value.constructor) {\n\t\t\treturn value.name === this.name;\n\t\t}\n\t\treturn value === this.name;\n\t}\n\n\t/**\n\t * Get all enum values.\n\t *\n\t * This method must be overridden by subclasses to return something meaningful.\n\t * This implementation returns an empty array.\n\t *\n\t * @abstract\n\t * @returns {module:util~Enum[]} get all enum values\n\t */\n\tstatic enumValues() {\n\t\treturn [];\n\t}\n\n\t/**\n\t * This method takes an array of enums and turns them into a mapped object, using the enum\n\t * `name` as object property names.\n\t *\n\t * @param {module:util~Enum[]} enums the enum list to turn into a value object\n\t * @returns {object} an object with enum `name` properties with associated enum values\n\t */\n\tstatic enumsValue(enums) {\n\t\treturn Object.freeze(\n\t\t\tenums.reduce((obj, e) => {\n\t\t\t\tobj[e.name] = e;\n\t\t\t\treturn obj;\n\t\t\t}, {})\n\t\t);\n\t}\n\n\t/**\n\t * Get an enum instance from its name.\n\t *\n\t * This method searches the {@link module:util~Enum#enumVvalues} array for a matching value.\n\t *\n\t * @param {string} name the enum name to get an instnace for\n\t * @returns {module:util~Enum} the instance, or `undefined` if no instance exists for the given `name`\n\t */\n\tstatic valueOf(name) {\n\t\tconst enums = this.enumValues();\n\t\tif (!Array.isArray(enums)) {\n\t\t\treturn undefined;\n\t\t}\n\t\tfor (let i = 0, len = enums.length; i < len; i += 1) {\n\t\t\tif (name === enums[i].name) {\n\t\t\t\treturn enums[i];\n\t\t\t}\n\t\t}\n\t}\n\n\tstatic namesFor(set) {\n\t\tconst result = [];\n\t\tif (set) {\n\t\t\tfor (const e of set) {\n\t\t\t\tresult.push(e.name);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport default Enum;\n","import Enum from \"./enum\";\n\n/**\n * An immutable enum-like object with an associated comparable value.\n *\n * This class is essentially abstract, and must be extended by another\n * class that overrides the inerited {@link module:util~Enum.enumValues} method.\n *\n * @abstract\n * @extends module:util~Enum\n * @alias module:util~ComparableEnum\n */\nclass ComparableEnum extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t * @param {number} value the comparable value\n\t */\n\tconstructor(name, value) {\n\t\tsuper(name);\n\t\tthis._value = value;\n\t\tif (this.constructor === ComparableEnum) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the comparable value.\n\t *\n\t * @returns {number} the value\n\t */\n\tget value() {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * Compare two ComparableEnum objects based on their `value` values.\n\t *\n\t * @param {ComparableEnum} other the object to compare to\n\t * @returns {number} `-1` if `this.value` is less than `other.value`,\n\t *                   `1` if `this.value` is greater than `other.value`,\n\t *                   `0` otherwise (when the values are equal)\n\t */\n\tcompareTo(other) {\n\t\treturn this.value < other.value ? -1 : this.value > other.value ? 1 : 0;\n\t}\n\n\t/**\n\t * Compute a complete set of enum values based on a minimum enum and/or set of enums.\n\t *\n\t * If `cache` is provided, then results computed via `minAggregation`\n\t * will be cached there, and subsequent calls will returned the cached result when appropriate.\n\t *\n\t * @param {ComparableEnum} [minEnum] a minimum enum value\n\t * @param {Map<string, Set<ComparableEnum>>} [cache] a cache of computed values\n\t * @returns {Set<ComparableEnum>|null} the computed set, or `null` if no values match\n\t */\n\tstatic minimumEnumSet(minEnum, cache) {\n\t\tif (!minEnum) {\n\t\t\treturn null;\n\t\t}\n\t\tlet result = cache ? cache.get(minEnum.name) : undefined;\n\t\tif (result) {\n\t\t\treturn result;\n\t\t}\n\t\tresult = new Set();\n\t\tfor (const agg of minEnum.constructor.enumValues()) {\n\t\t\tif (agg.compareTo(minEnum) > -1) {\n\t\t\t\tresult.add(agg);\n\t\t\t}\n\t\t}\n\t\tif (cache) {\n\t\t\tcache.set(minEnum.name, result);\n\t\t}\n\t\treturn result.size > 0 ? result : null;\n\t}\n}\n\nexport default ComparableEnum;\n","import ComparableEnum from \"../util/comparableEnum\";\n\n/**\n * A named aggregation.\n *\n * @extends module:util~ComparableEnum\n * @alias module:domain~Aggregation\n */\nclass Aggregation extends ComparableEnum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the unique name for this precision\n\t * @param {number} level a relative aggregation level value\n\t */\n\tconstructor(name, level) {\n\t\tsuper(name, level);\n\t\tif (this.constructor === Aggregation) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the aggregate level value.\n\t *\n\t * This is an alias for {@link module:util~ComparableEnum#value}.\n\t */\n\tget level() {\n\t\treturn this.value;\n\t}\n\n\t/**\n\t * Get the {@link module:domain~Aggregations} values.\n\t *\n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn AggregationValues;\n\t}\n}\n\nconst AggregationValues = Object.freeze([\n\tnew Aggregation(\"Minute\", 60),\n\tnew Aggregation(\"FiveMinute\", 60 * 5),\n\tnew Aggregation(\"TenMinute\", 60 * 10),\n\tnew Aggregation(\"FifteenMinute\", 60 * 15),\n\tnew Aggregation(\"ThirtyMinute\", 60 * 30),\n\tnew Aggregation(\"Hour\", 3600),\n\tnew Aggregation(\"HourOfDay\", 3600),\n\tnew Aggregation(\"SeasonalHourOfDay\", 3600),\n\tnew Aggregation(\"Day\", 86400),\n\tnew Aggregation(\"DayOfWeek\", 86400),\n\tnew Aggregation(\"SeasonalDayOfWeek\", 86400),\n\tnew Aggregation(\"Week\", 604800),\n\tnew Aggregation(\"WeekOfYear\", 604800),\n\tnew Aggregation(\"Month\", 2419200),\n\tnew Aggregation(\"Year\", 31536000),\n\tnew Aggregation(\"RunningTotal\", Number.MAX_SAFE_INTEGER)\n]);\n\n/**\n * The enumeration of supported Aggregation values.\n *\n * @readonly\n * @enum {module:domain~Aggregation}\n * @property {module:domain~Aggregation} Minute minute\n * @property {module:domain~Aggregation} FiveMinute 5 minutes\n * @property {module:domain~Aggregation} TenMinute 10 minutes\n * @property {module:domain~Aggregation} FifeteenMinute 15 minutes\n * @property {module:domain~Aggregation} ThirtyMinute 30 minutes\n * @property {module:domain~Aggregation} Hour an hour\n * @property {module:domain~Aggregation} HourOfDay an hour of a day, e.g. 1-24\n * @property {module:domain~Aggregation} SeasonalHourOfDay an hour of a day, further grouped into 4 seasons\n * @property {module:domain~Aggregation} Day a day\n * @property {module:domain~Aggregation} DayOfWeek a day of the week, e.g. Monday - Sunday\n * @property {module:domain~Aggregation} SeasonalDayOfWeek a day of the week, further grouped into 4 seasons\n * @property {module:domain~Aggregation} Week a week\n * @property {module:domain~Aggregation} WeekOfYear the week within a year, e.g. 1 - 52\n * @property {module:domain~Aggregation} Month a month\n * @property {module:domain~Aggregation} Year a year\n * @property {module:domain~Aggregation} RunningTotal a complete running total over a time span\n * @alias module:domain~Aggregations\n */\nconst Aggregations = Aggregation.enumsValue(AggregationValues);\n\nexport default Aggregations;\nexport { Aggregation };\n","import Enum from \"../util/enum\";\n\n/**\n * An auth token status.\n *\n * @extends module:util~Enum\n * @alias module:domain~AuthTokenStatus\n */\nexport class AuthTokenStatus extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t */\n\tconstructor(name) {\n\t\tsuper(name);\n\t\tif (this.constructor === AuthTokenStatus) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the {@link module:domain~AuthTokenStatuses} values.\n\t *\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn AuthTokenStatusValues;\n\t}\n}\n\nconst AuthTokenStatusValues = Object.freeze([\n\tnew AuthTokenStatus(\"Active\"),\n\tnew AuthTokenStatus(\"Disabled\")\n]);\n\n/**\n * The enumeration of supported AuthTokenStatus values.\n *\n * @readonly\n * @enum {module:domain~AuthTokenStatus}\n * @property {module:domain~AuthTokenStatus} Active the token is active and usable\n * @property {module:domain~AuthTokenStatus} Disabled the token is disabled and not usable\n * @alias module:domain~AuthTokenStatuses\n */\nconst AuthTokenStatuses = AuthTokenStatus.enumsValue(AuthTokenStatusValues);\n\nexport default AuthTokenStatuses;\n","import Enum from \"../util/enum\";\n\n/**\n * A named auth token type.\n *\n * @extends module:util~Enum\n * @alias module:domain~AuthTokenType\n */\nexport class AuthTokenType extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t */\n\tconstructor(name) {\n\t\tsuper(name);\n\t\tif (this.constructor === AuthTokenType) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the {@link AuthTokenTypes} values.\n\t *\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn AuthTokenTypeValues;\n\t}\n}\n\nconst AuthTokenTypeValues = Object.freeze([\n\tnew AuthTokenType(\"ReadNodeData\"),\n\tnew AuthTokenType(\"User\")\n]);\n\n/**\n * The enumeration of supported AuthTokenType values.\n *\n * @readonly\n * @enum {module:domain~AuthTokenType}\n * @property {module:domain~AuthTokenType} ReadNodeData a read-only token for reading SolarNode data\n * @property {module:domain~AuthTokenType} User full access as the user that owns the token\n * @alias module:domain~AuthTokenTypes\n */\nconst AuthTokenTypes = AuthTokenType.enumsValue(AuthTokenTypeValues);\n\nexport default AuthTokenTypes;\n","import Enum from \"../util/enum\";\n\n/**\n * A named query combining action type.\n *\n * @extends module:util~Enum\n * @alias module:domain~CombiningType\n */\nexport class CombiningType extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the unique name for this type\n\t */\n\tconstructor(name) {\n\t\tsuper(name);\n\t\tif (this.constructor === CombiningType) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the {@link module:domain~CombiningTypes} values.\n\t *\n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn CombiningTypeValues;\n\t}\n}\n\nconst CombiningTypeValues = Object.freeze([new CombiningType(\"Average\"), new CombiningType(\"Sum\")]);\n\n/**\n * The enumeration of supported CombiningType values.\n *\n * @readonly\n * @enum {module:domain~CombiningType}\n * @property {module:domain~CombiningType} Average average\n * @property {module:domain~CombiningType} Sum sum\n * @alias module:domain~CombiningTypes\n */\nconst CombiningTypes = CombiningType.enumsValue(CombiningTypeValues);\n\nexport default CombiningTypes;\n","import Enum from \"../util/enum\";\n\n/**\n * A datum auxiliary type.\n *\n * @extends module:util~Enum\n * @alias module:domain~DatumAuxiliaryType\n */\nexport class DatumAuxiliaryType extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the unique name for this type\n\t */\n\tconstructor(name) {\n\t\tsuper(name);\n\t\tif (this.constructor === DatumAuxiliaryType) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the {@link module:domain~DatumAuxiliaryTypes} values.\n\t *\n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn DatumAuxiliaryTypeValues;\n\t}\n}\n\nconst DatumAuxiliaryTypeValues = Object.freeze([new DatumAuxiliaryType(\"Reset\")]);\n\n/**\n * The enumeration of supported DatumAuxiliaryType values.\n *\n * @readonly\n * @enum {module:domain~DatumAuxiliaryType}\n * @property {module:domain~DatumAuxiliaryType} Reset reset\n * @alias module:domain~DatumAuxiliaryTypes\n */\nconst DatumAuxiliaryTypes = DatumAuxiliaryType.enumsValue(DatumAuxiliaryTypeValues);\n\nexport default DatumAuxiliaryTypes;\n","/**\n * A pagination criteria object.\n * @alias module:domain~Pagination\n */\nclass Pagination {\n\t/**\n\t * Construct a pagination object.\n\t *\n\t * @param {number} max the maximum number of results to return\n\t * @param {number} [offset] the 0-based starting offset\n\t */\n\tconstructor(max, offset) {\n\t\tthis._max = max > 0 ? +max : 0;\n\t\tthis._offset = offset > 0 ? +offset : 0;\n\t}\n\n\t/**\n\t * Get the maximum number of results to return.\n\t *\n\t * @returns {number} the maximum number of results\n\t */\n\tget max() {\n\t\treturn this._max;\n\t}\n\n\t/**\n\t * Get the results starting offset.\n\t *\n\t * The first available result starts at offset <code>0</code>. Note this is\n\t * a raw offset value, not a \"page\" offset.\n\t *\n\t * @returns {number} the starting result offset\n\t */\n\tget offset() {\n\t\treturn this._offset;\n\t}\n\n\t/**\n\t * Copy constructor with a new <code>offset</code> value.\n\t *\n\t * @param {number} offset the new offset to use\n\t * @return {Pagination} a new instance\n\t */\n\twithOffset(offset) {\n\t\treturn new Pagination(this.max, offset);\n\t}\n\n\t/**\n\t * Get this object as a standard URI encoded (query parameters) string value.\n\t *\n\t * @return {string} the URI encoded string\n\t */\n\ttoUriEncoding() {\n\t\tlet result = \"\";\n\t\tif (this.max > 0) {\n\t\t\tresult += \"max=\" + this.max;\n\t\t}\n\t\tif (this.offset > 0) {\n\t\t\tif (result.length > 0) {\n\t\t\t\tresult += \"&\";\n\t\t\t}\n\t\t\tresult += \"offset=\" + this.offset;\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport default Pagination;\n","/**\n * A description of a sort applied to a property of a collection.\n * @alias module:domain~SortDescriptor\n */\nclass SortDescriptor {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} key the property to sort on\n\t * @param {boolean} [descending] `true` to sort in descending order, `false` for ascending\n\t */\n\tconstructor(key, descending) {\n\t\tthis._key = key;\n\t\tthis._descending = !!descending;\n\t}\n\n\t/**\n\t * Get the sort property name.\n\t *\n\t * @returns {string} the sort key\n\t */\n\tget key() {\n\t\treturn this._key;\n\t}\n\n\t/**\n\t * Get the sorting direction.\n\t *\n\t * @returns {boolean} `true` if descending order, `false` for ascending\n\t */\n\tget descending() {\n\t\treturn this._descending;\n\t}\n\n\t/**\n\t * Get this object as a standard URI encoded (query parameters) string value.\n\t *\n\t * If `index` is provided and non-negative, then the query parameters will\n\t * be encoded as an array property named `sorts`. Otherwise just\n\t * bare `key` and `descending` properties will be used. The\n\t * `descending` property is only added if it is `true`.\n\t *\n\t * @param {number} [index] an optional array property index\n\t * @param {string} [propertyName=sorts] an optional array property name, only used if `index` is also provided\n\t * @return {string} the URI encoded string\n\t */\n\ttoUriEncoding(index, propertyName) {\n\t\tlet result,\n\t\t\tpropName = propertyName || \"sorts\";\n\t\tif (index !== undefined && index >= 0) {\n\t\t\tresult = encodeURIComponent(propName + \"[\" + index + \"].key\") + \"=\";\n\t\t} else {\n\t\t\tresult = \"key=\";\n\t\t}\n\t\tresult += encodeURIComponent(this.key);\n\t\tif (this.descending) {\n\t\t\tif (index !== undefined && index >= 0) {\n\t\t\t\tresult +=\n\t\t\t\t\t\"&\" + encodeURIComponent(propName + \"[\" + index + \"].descending\") + \"=true\";\n\t\t\t} else {\n\t\t\t\tresult += \"&descending=true\";\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n}\n\nexport default SortDescriptor;\n","import Pagination from \"../domain/pagination\";\nimport SortDescriptor from \"../domain/sortDescriptor\";\nimport Enum from \"./enum\";\n\n/**\n * A basic map-like object.\n *\n * <p>This object includes some utility functions that make it well suited to using\n * as an API query object. For example, the {@link module:util~PropMap#toUriEncoding}\n * method provides a way to serialize this object into URL query parameters.</p>\n *\n * @alias module:util~PropMap\n */\nclass PropMap {\n\t/**\n\t * Constructor.\n\t * @param {PropMap|object} props the initial properties; if a `PropMap` instance is provided, the properties\n\t *                               of that object will be copied into this one; otherwise the object will be\n\t *                               used directly to hold property values\n\t */\n\tconstructor(props) {\n\t\t/**\n\t\t * The object that all properties are stored on.\n\t\t * @member {object}\n\t\t */\n\t\tthis.props =\n\t\t\tprops instanceof PropMap ? props.properties() : typeof props === \"object\" ? props : {};\n\t}\n\n\t/**\n\t * Get, set, or remove a property value.\n\t *\n\t * @param {string} key the key to get or set the value for\n\t * @param {*} [newValue] if defined, the new value to set for the given `key`;\n\t *                       if `null` then the `key` property will be removed\n\t * @returns {*} if called as a getter, the associated value for the given `key`,\n\t *              otherwise this object\n\t */\n\tprop(key, newValue) {\n\t\tif (arguments.length === 1) {\n\t\t\treturn this.props[key];\n\t\t}\n\t\tif (newValue === null) {\n\t\t\tdelete this.props[key];\n\t\t} else {\n\t\t\tthis.props[key] = newValue;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get, set, or remove multiple properties.\n\t *\n\t * @param {object} [newProps] the new values to set; if any value is `null` that property\n\t *                            will be deleted\n\t * @returns {object} if called as a getter, all properties of this object copied into a\n\t *                   simple object; otherwise this object\n\t */\n\tproperties(newProps) {\n\t\tif (newProps) {\n\t\t\tfor (const k of Object.keys(newProps)) {\n\t\t\t\tthis.prop(k, newProps[k]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\treturn Object.assign({}, this.props);\n\t}\n\n\t/**\n\t * Get this object as a standard URI encoded (query parameters) string value.\n\t *\n\t * All enumerable properties of the <code>props</code> property will be added to the\n\t * result. If any property value is an array, the values of the array will be joined\n\t * by a comma. Any {@link module:util~Enum} values will have their `name` property used.\n\t * Any value that has a `toUriEncoding()` function property will have that function\n\t * invoked, passing the associated property name as the first argument, and the returned\n\t * value will be used.\n\t *\n\t * @param {string} [propertyName] an optional object property prefix to add to all properties\n\t * @param {function} [callbackFn] An optional function that will be called for each property.\n\t *                   The function will be passed property name and value arguments, and must\n\t *                   return either `null` to skip the property, a 2 or 3-element array with the\n\t *                   property name and value to use, and an optional boolean to force array\n\t *                   values to use mutliple parameter keys. Any other return value causes the\n\t *                   property to be used as- is.\n\t * @return {string} the URI encoded string\n\t */\n\ttoUriEncoding(propertyName, callbackFn) {\n\t\tlet result = \"\";\n\t\tfor (let k of Object.keys(this.props)) {\n\t\t\tif (result.length > 0) {\n\t\t\t\tresult += \"&\";\n\t\t\t}\n\t\t\tlet v = this.props[k];\n\t\t\tlet forceMultiKey = false;\n\t\t\tif (callbackFn) {\n\t\t\t\tconst kv = callbackFn(k, v);\n\t\t\t\tif (kv === null) {\n\t\t\t\t\tcontinue;\n\t\t\t\t} else if (Array.isArray(kv) && kv.length > 1) {\n\t\t\t\t\tk = kv[0];\n\t\t\t\t\tv = kv[1];\n\t\t\t\t\tif (kv.length > 2) {\n\t\t\t\t\t\tforceMultiKey = !!kv[2];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (typeof v.toUriEncoding === \"function\") {\n\t\t\t\tresult += v.toUriEncoding(\n\t\t\t\t\tpropertyName ? encodeURIComponent(propertyName) + \".\" + k : k\n\t\t\t\t);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (propertyName) {\n\t\t\t\tresult += encodeURIComponent(propertyName) + \".\";\n\t\t\t}\n\t\t\tresult += encodeURIComponent(k) + \"=\";\n\t\t\tif (Array.isArray(v)) {\n\t\t\t\tv.forEach(function(e, i) {\n\t\t\t\t\tif (i > 0) {\n\t\t\t\t\t\tresult += forceMultiKey ? \"&\" + encodeURIComponent(k) + \"=\" : \",\";\n\t\t\t\t\t}\n\t\t\t\t\tif (e instanceof Enum) {\n\t\t\t\t\t\te = e.name;\n\t\t\t\t\t}\n\t\t\t\t\tresult += encodeURIComponent(e);\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\tif (v instanceof Enum) {\n\t\t\t\t\tv = v.name;\n\t\t\t\t}\n\t\t\t\tresult += encodeURIComponent(v);\n\t\t\t}\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get this object as a standard URI encoded (query parameters) string value with\n\t * sorting and pagination parameters.\n\t *\n\t * <p>This calls {@link module:util~PropMap#toUriEncoding} first, then encodes\n\t * the `sorts` and `pagination` parameters, if provided.\n\t *\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @param {string} [propertyName] an optional object property prefix to add to all properties\n\t * @param {function} [callbackFn] An optional function that will be called for each property.\n\t *                   The function will be passed property name and value arguments, and must\n\t *                   return either `null` to skip the property, a 2-element array with the property\n\t *                   name and value to use, or anything else to use the property as- is.\n\t * @return {string} the URI encoded string\n\t */\n\ttoUriEncodingWithSorting(sorts, pagination, propertyName, callbackFn) {\n\t\tlet params = this.toUriEncoding(propertyName, callbackFn);\n\t\tif (Array.isArray(sorts)) {\n\t\t\tsorts.forEach((sort, i) => {\n\t\t\t\tif (sort instanceof SortDescriptor) {\n\t\t\t\t\tif (params.length > 0) {\n\t\t\t\t\t\tparams += \"&\";\n\t\t\t\t\t}\n\t\t\t\t\tparams += sort.toUriEncoding(i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif (pagination instanceof Pagination) {\n\t\t\tconst paginationParams = pagination.toUriEncoding();\n\t\t\tif (paginationParams) {\n\t\t\t\tif (params.length > 0) {\n\t\t\t\t\tparams += \"&\";\n\t\t\t\t}\n\t\t\t\tparams += paginationParams;\n\t\t\t}\n\t\t}\n\t\treturn params;\n\t}\n}\n\nexport default PropMap;\n","import PropMap from \"../util/propMap\";\n\nconst CountryKey = \"country\";\nconst ElevationKey = \"elevation\";\nconst LatitudeKey = \"latitude\";\nconst IdKey = \"id\";\nconst LocalityKey = \"locality\";\nconst LongitudeKey = \"longitude\";\nconst NameKey = \"name\";\nconst PostalCodeKey = \"postalCode\";\nconst RegionKey = \"region\";\nconst StateOrProvinceKey = \"stateOrProvince\";\nconst StreetKey = \"street\";\nconst TimeZoneIdKey = \"timeZoneId\";\n\n/**\n * A geographic location.\n *\n * @extends module:util~PropMap\n * @alias module:domain~Location\n */\nclass Location extends PropMap {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {module:domain~Location|object} loc the location to copy properties from\n\t */\n\tconstructor(loc) {\n\t\tsuper(loc);\n\t}\n\n\t/**\n\t * A SolarNetwork assigned unique identifier.\n\t * @type {number}\n\t */\n\tget id() {\n\t\treturn this.prop(IdKey);\n\t}\n\n\tset id(val) {\n\t\tthis.prop(IdKey, val);\n\t}\n\n\t/**\n\t * A generalized name, can be used for \"virtual\" locations.\n\t * @type {string}\n\t */\n\tget name() {\n\t\treturn this.prop(NameKey);\n\t}\n\n\tset name(val) {\n\t\tthis.prop(NameKey, val);\n\t}\n\n\t/**\n\t * An ISO 3166-1 alpha-2 character country code.\n\t * @type {string}\n\t */\n\tget country() {\n\t\treturn this.prop(CountryKey);\n\t}\n\n\tset country(val) {\n\t\tthis.prop(CountryKey, val);\n\t}\n\n\t/**\n\t * A country-specific regional identifier.\n\t * @type {string}\n\t */\n\tget region() {\n\t\treturn this.prop(RegionKey);\n\t}\n\n\tset region(val) {\n\t\tthis.prop(RegionKey, val);\n\t}\n\n\t/**\n\t * A country-specific state or province identifier.\n\t * @type {string}\n\t */\n\tget stateOrProvince() {\n\t\treturn this.prop(StateOrProvinceKey);\n\t}\n\n\tset stateOrProvince(val) {\n\t\tthis.prop(StateOrProvinceKey, val);\n\t}\n\n\t/**\n\t * Get the locality (city, town).\n\t * @type {string}\n\t */\n\tget locality() {\n\t\treturn this.prop(LocalityKey);\n\t}\n\n\tset locality(val) {\n\t\tthis.prop(LocalityKey, val);\n\t}\n\n\t/**\n\t * A country-specific postal code.\n\t * @type {string}\n\t */\n\tget postalCode() {\n\t\treturn this.prop(PostalCodeKey);\n\t}\n\n\tset postalCode(val) {\n\t\tthis.prop(PostalCodeKey, val);\n\t}\n\n\t/**\n\t * The street address.\n\t * @type {string}\n\t */\n\tget street() {\n\t\treturn this.prop(StreetKey);\n\t}\n\n\tset street(val) {\n\t\tthis.prop(StreetKey, val);\n\t}\n\n\t/**\n\t * The decimal world latitude.\n\t * @type {number}\n\t */\n\tget latitude() {\n\t\treturn this.prop(LatitudeKey);\n\t}\n\n\tset latitude(val) {\n\t\tthis.prop(LatitudeKey, val);\n\t}\n\n\t/**\n\t * The decimal world longitude.\n\t * @type {number}\n\t */\n\tget longitude() {\n\t\treturn this.prop(LongitudeKey);\n\t}\n\n\tset longitude(val) {\n\t\tthis.prop(LongitudeKey, val);\n\t}\n\n\t/**\n\t * The elevation above sea level, in meters.\n\t * @type {number}\n\t */\n\tget elevation() {\n\t\treturn this.prop(ElevationKey);\n\t}\n\n\tset elevation(val) {\n\t\tthis.prop(ElevationKey, val);\n\t}\n\n\t/**\n\t * A time zone ID, for example `Pacific/Auckland`.\n\t * @type {string}\n\t */\n\tget timeZoneId() {\n\t\treturn this.prop(TimeZoneIdKey);\n\t}\n\n\tset timeZoneId(val) {\n\t\tthis.prop(TimeZoneIdKey, val);\n\t}\n}\n\nexport default Location;\n","import Enum from \"../util/enum\";\n\n/**\n * An enumeration of datum reading types.\n *\n * @extends module:util~Enum\n * @alias module:domain~DatumReadingType\n */\nexport class DatumReadingType extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the unique name for this type\n\t * @param {string} key the key value associated with this type\n\t */\n\tconstructor(name, key) {\n\t\tsuper(name);\n\t\tthis._key = key;\n\t\tif (this.constructor === DatumReadingType) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the key value.\n\t *\n\t * @returns {string} the key value\n\t */\n\tget key() {\n\t\treturn this._key;\n\t}\n\n\t/**\n\t * Get the {@link module:domain~DatumReadingType} values.\n\t *\n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn DatumReadingTypeValues;\n\t}\n}\n\nconst DatumReadingTypeValues = Object.freeze([\n\tnew DatumReadingType(\"CalculatedAt\", \"at\"),\n\tnew DatumReadingType(\"CalculatedAtDifference\", \"atd\"),\n\tnew DatumReadingType(\"NearestDifference\", \"diff\"),\n\tnew DatumReadingType(\"Difference\", \"delta\"),\n\tnew DatumReadingType(\"DifferenceWithin\", \"change\")\n]);\n\n/**\n * The enumeration of supported `DatumReadingType` values.\n *\n * @readonly\n * @enum {module:domain~DatumReadingType}\n * @property {module:domain~DatumReadingType} CalculatedAt Derive a single reading value based\n * from one datum the nearest before a specific time and one the nearest after.\n * @property {module:domain~DatumReadingType} CalculatedAtDifference Calculate the difference\n * between two reading values on two dates, using the `CalcualtedAt` style of deriving the start\n * and end readings.\n * @property {module:domain~DatumReadingType} Difference Find the difference between two datum\n * that are nearest in time on or before two dates, without any limits on how near to those dates\n * the datum are.\n * @property {module:domain~DatumReadingType} DifferenceWithin Find the difference between two\n * datum that are nearest in time and within two dates.\n * @property {module:domain~DatumReadingType} NearestDifference Find the difference between two\n * datum that are nearest in time on or before two dates, constrained by a maximum time tolerance.\n * @alias module:domain~DatumReadingTypes\n */\nconst DatumReadingTypes = DatumReadingType.enumsValue(DatumReadingTypeValues);\n\nexport default DatumReadingTypes;\n","import Enum from \"./enum\";\n\n/**\n * An immutable enum-like object with an associated bitmask support.\n *\n * This class is essentially abstract, and must be extended by another\n * class that overrides the inerited {@link module:util~Enum.enumValues} method.\n *\n * @abstract\n * @extends module:util~Enum\n * @alias module:util~BitmaskEnum\n */\nclass BitmaskEnum extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t * @param {number} bitNumber the bit offset, starting from `1` for the least significant bit\n\t */\n\tconstructor(name, bitNumber) {\n\t\tsuper(name);\n\t\tthis._bitNumber = bitNumber;\n\t\tif (this.constructor === BitmaskEnum) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the bit offset value, starting from `1` for the least significant bit.\n\t *\n\t * @returns {number} the value\n\t */\n\tget bitmaskBitNumber() {\n\t\treturn this._bitNumber;\n\t}\n\n\t/**\n\t * Get the bit offset value, starting from `0` for the least significant bit.\n\t *\n\t * @returns {number} the value\n\t */\n\tget bitmaskBitOffset() {\n\t\treturn this._bitNumber - 1;\n\t}\n\n\t/**\n\t * Get a `BitmaskEnum` objects for a bit number.\n\t *\n\t * @param {number} bitNumber\n\t *        a bit number value of the `BitmaskEnum` object to find\n\t * @param {Iterable<BitmaskEnum>} values\n\t *        the complete set of possible `BitmaskEnum` objects\n\t * @return {BitmaskEnum} the matching `BitmaskEnum`, or `null`\n\t */\n\tstatic enumForBitNumber(bitNumber, values) {\n\t\tfor (const c of values) {\n\t\t\tconst n = c.bitmaskBitNumber;\n\t\t\tif (n == bitNumber) {\n\t\t\t\treturn c;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Get a bitmask value for a set of {@code Bitmaskable} objects.\n\t *\n\t * @param {Iterable<BitmaskEnum>} maskables\n\t *        the set of `BitmaskEnum` objects\n\t * @return {number} a bitmask value of all {@link module:util~BitmaskEnum#bitmaskBitOffset()}\n\t *         values of the given `maskables`\n\t */\n\tstatic bitmaskValue(maskables) {\n\t\tvar mask = 0;\n\t\tif (maskables != null) {\n\t\t\tfor (const c of maskables) {\n\t\t\t\tif (c.bitmaskBitOffset >= 0) {\n\t\t\t\t\tmask |= 1 << c.bitmaskBitOffset;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn mask;\n\t}\n\n\t/**\n\t * Convert a bitmask value into a set of {@code Bitmaskable} objects.\n\t *\n\t * @param {number} mask\n\t *        a bitmask value of a set of {@code Bitmaskable} objects\n\t * @param {BitmaskEnum} clazz\n\t *        the class of an enumeration of `BitmaskEnum` objects\n\t * @return {Set<BitmaskEnum>} a set of `BitmaskEnum` objects\n\t */\n\tstatic setForBitmaskEnum(mask, clazz) {\n\t\treturn BitmaskEnum.setForBitmask(mask, clazz.enumValues());\n\t}\n\n\t/**\n\t * Convert a bitmask value into a set of `BitmaskEnum` objects.\n\t *\n\t * @param {number} mask\n\t *        a bitmask value of a set of `BitmaskEnum` objects\n\t * @param {Iterable<BitmaskEnum>} values\n\t *        the complete set of possible `BitmaskEnum` objects\n\t * @return {Set<BitmaskEnum>} a set of `BitmaskEnum` objects\n\t */\n\tstatic setForBitmask(mask, values) {\n\t\tif (mask < 1) {\n\t\t\treturn new Set();\n\t\t}\n\t\tvar set = new Set();\n\t\tfor (const c of values) {\n\t\t\tconst b = c.bitmaskBitOffset;\n\t\t\tif (b >= 0 && ((mask >> b) & 1) == 1) {\n\t\t\t\tset.add(c);\n\t\t\t}\n\t\t}\n\t\treturn set;\n\t}\n}\n\nexport default BitmaskEnum;\n","import BitmaskEnum from \"../util/bitmaskEnum\";\n\n/**\n * An enumeration of standardized device operating states.\n *\n * @extends module:util~Enum\n * @alias module:domain~DeviceOperatingState\n */\nclass DeviceOperatingState extends BitmaskEnum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t * @param {number} bitNumber the bit offset, starting from `1` for the least significant bit\n\t */\n\tconstructor(name, bitNumber) {\n\t\tsuper(name, bitNumber);\n\t\tif (this.constructor === DeviceOperatingState) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the state code value.\n\t *\n\t * @returns {number} the code\n\t */\n\tget code() {\n\t\treturn this.bitmaskBitNumber;\n\t}\n\n\t/**\n\t * Get an enum for a code value.\n\t *\n\t * @param {number} code the code to look for\n\t * @returns {DeviceOperatingState} the state, or `null` if not found\n\t */\n\tstatic forCode(code) {\n\t\treturn BitmaskEnum.enumForBitNumber(code, DeviceOperatingStateValues);\n\t}\n\n\t/**\n\t * Get the {@link module:domain~DeviceOperatingStates} values.\n\t *\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn DeviceOperatingStateValues;\n\t}\n}\n\nconst DeviceOperatingStateValues = Object.freeze([\n\tnew DeviceOperatingState(\"Unknown\", 0),\n\tnew DeviceOperatingState(\"Normal\", 1),\n\tnew DeviceOperatingState(\"Starting\", 2),\n\tnew DeviceOperatingState(\"Standby\", 3),\n\tnew DeviceOperatingState(\"Shutdown\", 4),\n\tnew DeviceOperatingState(\"Fault\", 5),\n\tnew DeviceOperatingState(\"Disabled\", 6),\n\tnew DeviceOperatingState(\"Recovery\", 7),\n\tnew DeviceOperatingState(\"Override\", 8)\n]);\n\n/**\n * The enumeration of supported DeviceOperatingState values.\n *\n * @readonly\n * @enum {module:domain~DeviceOperatingState}\n * @property {module:domain~DeviceOperatingState} Unknown an unknown state\n * @property {module:domain~DeviceOperatingState} Normal normal operating state\n * @property {module:domain~DeviceOperatingState} Starting a startup/initializing state\n * @property {module:domain~DeviceOperatingState} Standby a standby/low power mode\n * @property {module:domain~DeviceOperatingState} Shutdown a shutdown/off state\n * @property {module:domain~DeviceOperatingState} Fault a faulty or error condition\n * @property {module:domain~DeviceOperatingState} Disabled a disabled state\n * @property {module:domain~DeviceOperatingState} Recovery a recovery state\n * @property {module:domain~DeviceOperatingState} Override a manual or overridden state\n * @alias module:domain~DeviceOperatingStates\n */\nconst DeviceOperatingStates = DeviceOperatingState.enumsValue(DeviceOperatingStateValues);\n\nexport default DeviceOperatingStates;\nexport { DeviceOperatingState };\n","import Enum from \"../util/enum\";\n\n/**\n * A named instruction state.\n *\n * @extends module:util~Enum\n * @alias module:domain~InstructionState\n */\nclass InstructionState extends Enum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t */\n\tconstructor(name) {\n\t\tsuper(name);\n\t\tif (this.constructor === InstructionState) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the {@link module:domain~InstructionStates} values.\n\t *\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn InstructionStateValues;\n\t}\n}\n\nconst InstructionStateValues = Object.freeze([\n\tnew InstructionState(\"Unknown\"),\n\tnew InstructionState(\"Queued\"),\n\tnew InstructionState(\"Received\"),\n\tnew InstructionState(\"Executing\"),\n\tnew InstructionState(\"Declined\"),\n\tnew InstructionState(\"Completed\")\n]);\n\n/**\n * The enumeration of supported InstructionState values.\n *\n * @readonly\n * @enum {module:domain~InstructionState}\n * @property {module:domain~InstructionState} Unknown an unknown state\n * @property {module:domain~InstructionState} Queued the instruction has been received by SolarNet but not yet delivered to its destination\n * @property {module:domain~InstructionState} Received the instruction has been delivered to its destination but not yet acted upon\n * @property {module:domain~InstructionState} Executed the instruction is currently being acted upon\n * @property {module:domain~InstructionState} Declined the destination has declined to execute the instruction, or the execution failed\n * @property {module:domain~InstructionState} Completed the destination has executed successfully\n * @alias module:domain~InstructionStates\n */\nconst InstructionStates = InstructionState.enumsValue(InstructionStateValues);\n\nexport default InstructionStates;\nexport { InstructionState };\n","import ComparableEnum from \"../util/comparableEnum\";\n\n/**\n * A location precision object for use with defining named geographic precision.\n *\n * @extends module:util~ComparableEnum\n * @alias module:domain~LocationPrecision\n */\nclass LocationPrecision extends ComparableEnum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the unique name for this precision\n\t * @param {number} precision a relative precision value for this precision\n\t */\n\tconstructor(name, precision) {\n\t\tsuper(name, precision);\n\t\tif (this.constructor === LocationPrecision) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the relative precision value.\n\t *\n\t * This is an alias for {@link #name}.\n\t *\n\t * @returns {number} the precision\n\t */\n\tget precision() {\n\t\treturn this.value;\n\t}\n\n\t/**\n\t * Get the {@link module:domain~LocationPrecisions} values.\n\t *\n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn LocationPrecisionValues;\n\t}\n}\n\nconst LocationPrecisionValues = Object.freeze([\n\tnew LocationPrecision(\"LatLong\", 1),\n\tnew LocationPrecision(\"Block\", 5),\n\tnew LocationPrecision(\"Street\", 10),\n\tnew LocationPrecision(\"PostalCode\", 20),\n\tnew LocationPrecision(\"Locality\", 30),\n\tnew LocationPrecision(\"StateOrProvince\", 40),\n\tnew LocationPrecision(\"Region\", 50),\n\tnew LocationPrecision(\"TimeZone\", 60),\n\tnew LocationPrecision(\"Country\", 70)\n]);\n\n/**\n * The enumeration of supported LocationPrecision values.\n *\n * @readonly\n * @enum {module:domain~LocationPrecision}\n * @property {module:domain~LocationPrecision} LatLong GPS coordinates\n * @property {module:domain~LocationPrecision} Block a city block\n * @property {module:domain~LocationPrecision} Street a street\n * @property {module:domain~LocationPrecision} PostalCode a postal code (or \"zip code\")\n * @property {module:domain~LocationPrecision} Locality a town or city\n * @property {module:domain~LocationPrecision} StateOrProvince a state or province\n * @property {module:domain~LocationPrecision} Region a large region\n * @property {module:domain~LocationPrecision} TimeZone a time zone\n * @property {module:domain~LocationPrecision} Country a country\n * @alias module:domain~LocationPrecisions\n */\nconst LocationPrecisions = LocationPrecision.enumsValue(LocationPrecisionValues);\n\nexport default LocationPrecisions;\nexport { LocationPrecision };\n","import BitmaskEnum from \"../util/bitmaskEnum\";\n\n/**\n * A named sky condition/observation.\n *\n * @extends module:util~BitmaskEnum\n * @alias module:domain~SkyCondition\n */\nclass SkyCondition extends BitmaskEnum {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {string} name the name\n\t * @param {number} bitNumber the bit offset, starting from `1` for the least significant bit\n\t */\n\tconstructor(name, bitNumber) {\n\t\tsuper(name, bitNumber);\n\t\tif (this.constructor === SkyCondition) {\n\t\t\tObject.freeze(this);\n\t\t}\n\t}\n\n\t/**\n\t * Get the state code value.\n\t *\n\t * @returns {number} the code\n\t */\n\tget code() {\n\t\treturn this.bitmaskBitNumber;\n\t}\n\n\t/**\n\t * Get an enum for a code value.\n\t *\n\t * @param {number} code the code to look for\n\t * @returns {DeviceOperatingState} the state, or `null` if not found\n\t */\n\tstatic forCode(code) {\n\t\treturn BitmaskEnum.enumForBitNumber(code, SkyConditionValues);\n\t}\n\n\t/**\n\t * Get the {@link module:domain~SkyConditions} values.\n\t *\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn SkyConditionValues;\n\t}\n}\n\nconst SkyConditionValues = Object.freeze([\n\tnew SkyCondition(\"Clear\", 1),\n\tnew SkyCondition(\"ScatteredClouds\", 2),\n\tnew SkyCondition(\"Cloudy\", 3),\n\tnew SkyCondition(\"Fog\", 4),\n\tnew SkyCondition(\"Drizzle\", 5),\n\tnew SkyCondition(\"ScatteredShowers\", 6),\n\tnew SkyCondition(\"Showers\", 7),\n\tnew SkyCondition(\"Rain\", 8),\n\tnew SkyCondition(\"Hail\", 9),\n\tnew SkyCondition(\"ScatteredSnow\", 10),\n\tnew SkyCondition(\"Snow\", 11),\n\tnew SkyCondition(\"Storm\", 12),\n\tnew SkyCondition(\"SevereStorm\", 13),\n\tnew SkyCondition(\"Thunder\", 14),\n\tnew SkyCondition(\"Windy\", 15),\n\tnew SkyCondition(\"Hazy\", 16),\n\tnew SkyCondition(\"Tornado\", 17),\n\tnew SkyCondition(\"Hurricane\", 18),\n\tnew SkyCondition(\"Dusty\", 19)\n]);\n\n/**\n * The enumeration of supported SkyCondition values.\n *\n * @readonly\n * @enum {module:domain~SkyCondition}\n * @property {module:domain~SkyCondition} Clear clear sky\n * @property {module:domain~SkyCondition} ScatteredClouds scattered/few clouds\n * @property {module:domain~SkyCondition} Fog fog\n * @property {module:domain~SkyCondition} Drizzle drizzle, light rain\n * @property {module:domain~SkyCondition} ScatteredShowers scattered/few showers\n * @property {module:domain~SkyCondition} Showers showers, light rain\n * @property {module:domain~SkyCondition} Rain rain\n * @property {module:domain~SkyCondition} Hail hail\n * @property {module:domain~SkyCondition} ScatteredSnow scattered/light snow\n * @property {module:domain~SkyCondition} Snow snow\n * @property {module:domain~SkyCondition} Storm storm\n * @property {module:domain~SkyCondition} SevereStorm severe storm\n * @property {module:domain~SkyCondition} Thunder thunder, lightning\n * @property {module:domain~SkyCondition} Windy windy\n * @property {module:domain~SkyCondition} Hazy hazy\n * @property {module:domain~SkyCondition} Tornado tornado\n * @property {module:domain~SkyCondition} Hurricane hurrican\n * @property {module:domain~SkyCondition} Dusty dusty\n * @alias module:domain~SkyConditions\n */\nconst SkyConditions = SkyCondition.enumsValue(SkyConditionValues);\n\nexport default SkyConditions;\nexport { SkyCondition };\n","import MultiMap from \"../util/multiMap\";\n\nconst HttpMethod = Object.freeze(\n\t/**\n\t * Enumeration of HTTP methods (verbs).\n\t * @enum {string}\n\t * @alias module:net~HttpMethod\n\t * @constant\n\t */\n\t{\n\t\tGET: \"GET\",\n\t\tHEAD: \"HEAD\",\n\t\tPOST: \"POST\",\n\t\tPUT: \"PUT\",\n\t\tPATCH: \"PATCH\",\n\t\tDELETE: \"DELETE\",\n\t\tOPTIONS: \"OPTIONS\",\n\t\tTRACE: \"TRACE\"\n\t}\n);\n\nconst HttpContentType = Object.freeze(\n\t/**\n\t * Enumeration of common HTTP `Content-Type` values.\n\t * @enum {string}\n\t * @alias module:net~HttpContentType\n\t * @constant\n\t */\n\t{\n\t\tAPPLICATION_JSON: \"application/json\",\n\t\tAPPLICATION_JSON_UTF8: \"application/json; charset=UTF-8\",\n\t\tFORM_URLENCODED: \"application/x-www-form-urlencoded\",\n\t\tFORM_URLENCODED_UTF8: \"application/x-www-form-urlencoded; charset=UTF-8\"\n\t}\n);\n\n/**\n * Support for HTTP headers.\n *\n * @extends module:util~MultiMap\n * @alias module:net~HttpHeaders\n */\nclass HttpHeaders extends MultiMap {\n\tconstructor() {\n\t\tsuper();\n\t}\n}\n\nObject.defineProperties(HttpHeaders, {\n\t/**\n\t * The `Accept` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tACCEPT: { value: \"Accept\" },\n\n\t/**\n\t * The `Authorization` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tAUTHORIZATION: { value: \"Authorization\" },\n\n\t/**\n\t * The `Content-MD5` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tCONTENT_MD5: { value: \"Content-MD5\" },\n\n\t/**\n\t * The `Content-Type` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tCONTENT_TYPE: { value: \"Content-Type\" },\n\n\t/**\n\t * The `Date` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tDATE: { value: \"Date\" },\n\n\t/**\n\t * The `Digest` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tDIGEST: { value: \"Digest\" },\n\n\t/**\n\t * The `Host` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tHOST: { value: \"Host\" },\n\n\t/**\n\t * The `X-SN-Date` header.\n\t *\n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\tX_SN_DATE: { value: \"X-SN-Date\" }\n});\n\nexport default HttpHeaders;\nexport { HttpContentType, HttpMethod };\n","import Configuration from \"../util/configuration\";\nimport Environment from \"./environment\";\n\n/**\n * A utility class for helping to compose SolarNet URLs for the REST API.\n *\n * This class is essentially abstract and meant to have mixin helper objects extend it.\n * @alias module:net~UrlHelper\n */\nclass UrlHelper {\n\t/**\n\t * Constructor.\n\t *\n\t * @param {module:net~Environment|object} [environment] the optional initial environment to use;\n\t *        if a non-`Environment` object is passed then the properties of that object will\n\t *        be used to construct a new `Environment` instance\n\t */\n\tconstructor(environment) {\n\t\tlet env = environment instanceof Environment ? environment : new Environment(environment);\n\n\t\t/**\n\t\t * The environment associated with this helper.\n\t\t * @member {module:net~Environment}\n\t\t */\n\t\tthis.environment = env;\n\n\t\tthis._parameters = new Configuration();\n\t}\n\n\t/**\n\t * Get a parameters object that can be used to hold URL variables.\n\t *\n\t * @readonly\n\t * @type {module:util~Configuration}\n\t */\n\tget parameters() {\n\t\treturn this._parameters;\n\t}\n\n\t/**\n\t * Get or set an environment parameter.\n\t *\n\t * This is a shortcut for calling {@link module:net~Configuration#value} on the\n\t * `environment` object.\n\t *\n\t * @param {string} key the environment parameter name to get\n\t * @param {object} [val] the optional value to set\n\t * @returns {object} when called as a getter, the environment parameter value;\n\t *                   when called as a setter, the environment parameters object\n\t */\n\tenv(...args) {\n\t\treturn this.environment.value(...args);\n\t}\n\n\t/**\n\t * Get or set a parameter.\n\t *\n\t * This is a shortcut for calling {@link module:net~Configuration#value} on the\n\t * `parameters` object.\n\t *\n\t * @param {string} key the parameter name to get\n\t * @param {Object} [val] the optional value to set\n\t * @returns {Object} when called as a getter, the parameter value;\n\t *                   when called as a setter, the parameters object\n\t */\n\tparameter(...args) {\n\t\treturn this._parameters.value(...args);\n\t}\n\n\t/**\n\t * Get a URL for just the SolarNet host, without any path.\n\t *\n\t * @returns {string} the URL to the SolarNet host\n\t */\n\thostUrl() {\n\t\tconst tls = this.environment.useTls();\n\t\tconst port = +this.environment.value(\"port\");\n\t\tlet url = \"http\" + (tls ? \"s\" : \"\") + \"://\" + this.environment.value(\"host\");\n\t\tif ((tls && port > 0 && port !== 443) || (!tls && port > 0 && port !== 80)) {\n\t\t\turl += \":\" + port;\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Get a URL for just the SolarNet host using the WebSocket protocol, without any path.\n\t *\n\t * @returns {string} the URL to the SolarNet host WebSocket\n\t */\n\thostWebSocketUrl() {\n\t\tconst tls = this.environment.useTls();\n\t\tconst port = +this.environment.value(\"port\");\n\t\tlet url = \"ws\" + (tls ? \"s\" : \"\") + \"://\" + this.environment.value(\"host\");\n\t\tif ((tls && port > 0 && port !== 443) || (!tls && port > 0 && port !== 80)) {\n\t\t\turl += \":\" + port;\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Get the base URL to the REST API.\n\t *\n\t * This implementation is a stub, meant for subclasses to override. This implementation\n\t * simply returns {@link module:net~UrlHelper#hostUrl}.\n\t *\n\t * @abstract\n\t * @returns {string} the base URL to the REST API\n\t */\n\tbaseUrl() {\n\t\treturn this.hostUrl();\n\t}\n\n\t/**\n\t * Replace occurances of URL template variables with values from the `parameters`\n\t * property and append to the host URL.\n\t *\n\t * This method provides a way to resolve an absolute URL based on the configured\n\t * environment and parameters on this object.\n\t *\n\t * @param {string} template a URL path template\n\t * @returns {string} an absolute URL\n\t * @see module:net~UrlHelper#resolveTemplateUrl\n\t */\n\tresolveTemplatePath(template) {\n\t\treturn this.hostUrl() + this.resolveTemplateUrl(template);\n\t}\n\n\t/**\n\t * Replace occurances of URL template variables with values from the `parameters`\n\t * property.\n\t *\n\t * URL template variables are specified as `{<em>name</em>}`. The variable\n\t * will be replaced by the value associated with property `name` in the\n\t * `parameters` object. The value will be URI encoded.\n\t *\n\t * @param {string} template a URL template\n\t * @returns {string} the URL with template variables resolved\n\t */\n\tresolveTemplateUrl(template) {\n\t\treturn UrlHelper.resolveTemplateUrl(template, this._parameters);\n\t}\n\n\t/**\n\t * Replace occurances of URL template variables with values from a parameter object.\n\t *\n\t * URL template variables are specified as `{<em>name</em>}`. The variable\n\t * will be replaced by the value associated with property `name` in the\n\t * provided parameter object. The value will be URI encoded.\n\t *\n\t * @param {string} template a URL template\n\t * @param {object} params an object whose properties should serve as template variables\n\t * @returns {string} the URL\n\t */\n\tstatic resolveTemplateUrl(template, params) {\n\t\treturn template.replace(/\\{([^}]+)\\}/g, function(match, variableName) {\n\t\t\tlet variableValue = params[variableName];\n\t\t\treturn variableValue !== undefined ? encodeURIComponent(variableValue) : \"\";\n\t\t});\n\t}\n}\n\nexport default UrlHelper;\n","const LocationIdsKey = \"locationIds\";\nconst SourceIdsKey = \"sourceIds\";\n\n/**\n * Create a LocationUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~LocationUrlHelperMixin} the mixin class\n */\nconst LocationUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds support for SolarLocation properties to a {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~LocationUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * The first available location ID from the `locationIds` property.\n\t\t * Setting this replaces any existing location IDs with an array of just that value.\n\t\t * @type {number}\n\t\t */\n\t\tget locationId() {\n\t\t\tconst locationIds = this.locationIds;\n\t\t\treturn Array.isArray(locationIds) && locationIds.length > 0 ? locationIds[0] : null;\n\t\t}\n\n\t\tset locationId(locationId) {\n\t\t\tthis.parameter(LocationIdsKey, locationId ? [locationId] : null);\n\t\t}\n\n\t\t/**\n\t\t * An array of location IDs, set on the `locationIds` parameter\n\t\t * @type {number[]}\n\t\t */\n\t\tget locationIds() {\n\t\t\treturn this.parameter(LocationIdsKey);\n\t\t}\n\n\t\tset locationIds(locationIds) {\n\t\t\tthis.parameter(LocationIdsKey, locationIds);\n\t\t}\n\n\t\t/**\n\t\t * The first available source ID from the `sourceIds` property.\n\t\t * Setting this replaces any existing location IDs with an array of just that value.\n\t\t * @type {string}\n\t\t */\n\t\tget sourceId() {\n\t\t\tconst sourceIds = this.sourceIds;\n\t\t\treturn Array.isArray(sourceIds) && sourceIds.length > 0 ? sourceIds[0] : null;\n\t\t}\n\n\t\tset sourceId(sourceId) {\n\t\t\tthis.parameter(SourceIdsKey, sourceId ? [sourceId] : sourceId);\n\t\t}\n\n\t\t/**\n\t\t * An array of source IDs, set on the `sourceIds` parameter\n\t\t * @type {string[]}\n\t\t */\n\t\tget sourceIds() {\n\t\t\treturn this.parameter(SourceIdsKey);\n\t\t}\n\n\t\tset sourceIds(sourceIds) {\n\t\t\tthis.parameter(SourceIdsKey, sourceIds);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to find locations based on a search criteria.\n\t\t *\n\t\t * @param {module:domain~Location} filter the search criteria\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the generated URL\n\t\t */\n\t\tfindLocationsUrl(filter, sorts, pagination) {\n\t\t\treturn (\n\t\t\t\tthis.baseUrl() + \"/location?\" + filter.toUriEncodingWithSorting(sorts, pagination)\n\t\t\t);\n\t\t}\n\t};\n\nexport default LocationUrlHelperMixin;\n","/**\n * The SolarQuery default path.\n * @type {string}\n * @alias module:net~SolarQueryDefaultPath\n */\nexport const SolarQueryDefaultPath = \"/solarquery\";\n\n/**\n * The {@link module:net~UrlHelper#parameters} key for the SolarQuery path.\n * @type {string}\n * @alias module:net~SolarQueryPathKey\n */\nexport const SolarQueryPathKey = \"solarQueryPath\";\n\n/**\n * The SolarQuery REST API path.\n * @type {string}\n * @alias module:net~SolarQueryApiPathV1\n */\nexport const SolarQueryApiPathV1 = \"/api/v1\";\n\n/**\n * The {@link module:net~UrlHelper#parameters} key that holds a `boolean` flag to\n * use the public path scheme (`/pub`) when constructing URLs.\n * @type {string}\n * @alias module:net~SolarQueryPublicPathKey\n */\nexport const SolarQueryPublicPathKey = \"publicQuery\";\n\n/**\n * Create a QueryUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~QueryUrlHelperMixin} the mixin class\n */\nconst QueryUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarQuery specific support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~QueryUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Flag to set the `publicQuery` environment parameter.\n\t\t * @type {boolean}\n\t\t */\n\t\tget publicQuery() {\n\t\t\treturn !!this.env(SolarQueryPublicPathKey);\n\t\t}\n\n\t\tset publicQuery(value) {\n\t\t\tthis.env(SolarQueryPublicPathKey, !!value);\n\t\t}\n\n\t\t/**\n\t\t * Get the base URL to the SolarQuery v1 REST API.\n\t\t *\n\t\t * The returned URL uses the configured environment to resolve\n\t\t * the `hostUrl`, the `solarQueryPath` context path,\n\t\t * and the `publicQuery` boolean flag. If the context path is not\n\t\t * available, it will default to `/solarquery`.\n\t\t *\n\t\t * @returns {string} the base URL to SolarQuery\n\t\t */\n\t\tbaseUrl() {\n\t\t\tconst path = this.env(SolarQueryPathKey) || SolarQueryDefaultPath;\n\t\t\tconst isPubPath = this.publicQuery;\n\t\t\treturn this.hostUrl() + path + SolarQueryApiPathV1 + (isPubPath ? \"/pub\" : \"/sec\");\n\t\t}\n\t};\n\nexport default QueryUrlHelperMixin;\n","import UrlHelper from \"./urlHelper\";\nimport LocationUrlHelperMixin from \"./locationUrlHelperMixin\";\nimport QueryUrlHelperMixin from \"./queryUrlHelperMixin\";\n\n/**\n * Create a LocationDatumMetadataUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~LocationDatumMetadataUrlHelperMixin} the mixin class\n */\nconst LocationDatumMetadataUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarNode datum metadata support to {@link module:net~UrlHelper}.\n\t *\n\t * <p>Location datum metadata is metadata associated with a specific location and source, i.e.\n\t * a `locationId` and a `sourceId`.\n\t *\n\t * @mixin\n\t * @alias module:net~LocationDatumMetadataUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Get a base URL for location datum metadata operations using a specific location ID.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t\t * @returns {string} the base URL\n\t\t * @private\n\t\t */\n\t\tbaseLocationDatumMetadataUrl(locationId) {\n\t\t\treturn this.baseUrl() + \"/location/meta/\" + (locationId || this.locationId);\n\t\t}\n\n\t\tlocationDatumMetadataUrlWithSource(locationId, sourceId) {\n\t\t\tlet result = this.baseLocationDatumMetadataUrl(locationId);\n\t\t\tlet source = sourceId || this.sourceId;\n\t\t\tif (sourceId !== null && source) {\n\t\t\t\tresult += \"?sourceId=\" + encodeURIComponent(source);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing datum metadata.\n\t\t *\n\t\t * If no `sourceId` is provided, then the API will return all available datum metadata for all sources.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use;\n\t\t *                            if not provided the `sourceId` property of this class will be used;\n\t\t *                            if `null` then ignore any `sourceId` property of this class\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewLocationDatumMetadataUrl(locationId, sourceId) {\n\t\t\treturn this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for adding (merging) datum metadata via a `POST` request.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use; if not provided the `sourceId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\taddLocationDatumMetadataUrl(locationId, sourceId) {\n\t\t\treturn this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for setting datum metadata via a `PUT` request.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use; if not provided the `sourceId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\treplaceLocationDatumMetadataUrl(locationId, sourceId) {\n\t\t\treturn this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for deleting datum metadata via a `DELETE` request.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use; if not provided the `sourceId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tdeleteLocationDatumMetadataUrl(locationId, sourceId) {\n\t\t\treturn this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for searching for location metadata.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} [filter] a search filter; the `locationIds`, `sourceIds`, `tags`,\n\t\t *                                    `query`, and `location` properties are supported\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tfindLocationDatumMetadataUrl(filter, sorts, pagination) {\n\t\t\tlet result = this.baseUrl() + \"/location/meta\";\n\t\t\tlet params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~LocationDatumMetadataUrlHelperMixin},\n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~LocationUrlHelperMixin} mixins.\n *\n * @mixes module:net~LocationDatumMetadataUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~LocationUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~LocationDatumMetadataUrlHelper\n */\nclass LocationDatumMetadataUrlHelper extends LocationDatumMetadataUrlHelperMixin(\n\tQueryUrlHelperMixin(LocationUrlHelperMixin(UrlHelper))\n) {}\n\nexport default LocationDatumMetadataUrlHelperMixin;\nexport { LocationDatumMetadataUrlHelper };\n","import { dateTimeUrlFormat } from \"../format/date\";\nimport UrlHelper from \"./urlHelper\";\nimport LocationUrlHelperMixin from \"./locationUrlHelperMixin\";\nimport QueryUrlHelperMixin from \"./queryUrlHelperMixin\";\n\n/**\n * Create a LocationDatumUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~LocationDatumUrlHelperMixin} the mixin class\n */\nconst LocationDatumUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarLocation datum query support to {@link module:net~UrlHelper}.\n\t *\n\t * <p>This mixin is commonly mixed with the {@link module:net~QueryUrlHelperMixin} to pick\n\t * up support for the SolarQuery base URL.</p>\n\t *\n\t * <p>This mixin is commonly mixed with the {@link module:net~LocationUrlHelperMixin} to\n\t * pick up support for `locationId` and `sourceId` properties.</p>\n\t *\n\t * @mixin\n\t * @alias module:net~LocationDatumUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL for the \"reportable interval\" for a location, optionally limited to a specific source ID.\n\t\t *\n\t\t * If no source IDs are provided, then the reportable interval query will return an interval for\n\t\t * all available sources.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to limit query to;\n\t\t *                 if not provided the `sourceId` property of this class will be used;\n\t\t *                 if `null` the `sourceId` property of this class will be ignored\n\t\t * @returns {string} the URL\n\t\t */\n\t\treportableIntervalUrl(locationId, sourceId) {\n\t\t\tlet url =\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/location/datum/interval?locationId=\" +\n\t\t\t\t(locationId || this.locationId);\n\t\t\tlet source = sourceId || this.sourceId;\n\t\t\tif (sourceId !== null && source) {\n\t\t\t\turl += \"&sourceId=\" + encodeURIComponent(source);\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for finding the available source IDs for a location or metadata filter.\n\t\t *\n\t\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId`\n\t\t *                              property of this class will be used\n\t\t * @param {Date} [startDate] a start date to limit the search to\n\t\t * @param {Date} [endDate] an end date to limit the search to\n\t\t * @returns {string} the URL\n\t\t */\n\t\tavailableSourcesUrl(locationId, startDate, endDate) {\n\t\t\tlet result =\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/location/datum/sources?locationId=\" +\n\t\t\t\t(locationId || this.locationId);\n\t\t\tif (startDate instanceof Date) {\n\t\t\t\tresult += \"&start=\" + encodeURIComponent(dateTimeUrlFormat(startDate));\n\t\t\t}\n\t\t\tif (endDate instanceof Date) {\n\t\t\t\tresult += \"&end=\" + encodeURIComponent(dateTimeUrlFormat(endDate));\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for querying for location datum, in either raw or aggregate form.\n\t\t *\n\t\t * If the `datumFilter` has an `aggregate` value set, then aggregate results will be\n\t\t * returned by SolarNet.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tlistDatumUrl(datumFilter, sorts, pagination) {\n\t\t\tlet result = this.baseUrl() + \"/location/datum/list\";\n\t\t\tlet params = datumFilter ? datumFilter.toUriEncodingWithSorting(sorts, pagination) : \"\";\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for querying for the most recent datum.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tmostRecentDatumUrl(datumFilter, sorts, pagination) {\n\t\t\tlet result = this.baseUrl() + \"/location/datum/mostRecent\";\n\t\t\tlet params = datumFilter ? datumFilter.toUriEncodingWithSorting(sorts, pagination) : \"\";\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~LocationDatumUrlHelperMixin},\n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~LocationUrlHelperMixin} mixins.\n *\n * @mixes module:net~LocationDatumUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~LocationUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~LocationDatumUrlHelper\n */\nclass LocationDatumUrlHelper extends LocationDatumUrlHelperMixin(\n\tQueryUrlHelperMixin(LocationUrlHelperMixin(UrlHelper))\n) {}\n\nexport default LocationDatumUrlHelperMixin;\nexport { LocationDatumUrlHelper };\n","const NodeIdsKey = \"nodeIds\";\nconst SourceIdsKey = \"sourceIds\";\n\n/**\n * Create a NodeUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeUrlHelperMixin} the mixin class\n */\nconst NodeUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds support for SolarNode properties to a {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~NodeUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * The first available node ID from the `nodeIds` property.\n\t\t * Setting this replaces any existing node IDs with an array of just that value.\n\t\t * @type {number}\n\t\t */\n\t\tget nodeId() {\n\t\t\tconst nodeIds = this.nodeIds;\n\t\t\treturn Array.isArray(nodeIds) && nodeIds.length > 0 ? nodeIds[0] : null;\n\t\t}\n\n\t\tset nodeId(nodeId) {\n\t\t\tthis.parameter(NodeIdsKey, nodeId ? [nodeId] : null);\n\t\t}\n\n\t\t/**\n\t\t * An array of node IDs, set on the `nodeIds` parameter\n\t\t * @type {number[]}\n\t\t */\n\t\tget nodeIds() {\n\t\t\treturn this.parameter(NodeIdsKey);\n\t\t}\n\n\t\tset nodeIds(nodeIds) {\n\t\t\tthis.parameter(NodeIdsKey, nodeIds);\n\t\t}\n\n\t\t/**\n\t\t * The first available source ID from the `sourceIds` property.\n\t\t * Setting this replaces any existing node IDs with an array of just that value.\n\t\t * @type {string}\n\t\t */\n\t\tget sourceId() {\n\t\t\tconst sourceIds = this.sourceIds;\n\t\t\treturn Array.isArray(sourceIds) && sourceIds.length > 0 ? sourceIds[0] : null;\n\t\t}\n\n\t\tset sourceId(sourceId) {\n\t\t\tthis.parameter(SourceIdsKey, sourceId ? [sourceId] : sourceId);\n\t\t}\n\n\t\t/**\n\t\t * An array of source IDs, set on the `sourceIds` parameter\n\t\t * @type {string[]}\n\t\t */\n\t\tget sourceIds() {\n\t\t\treturn this.parameter(SourceIdsKey);\n\t\t}\n\n\t\tset sourceIds(sourceIds) {\n\t\t\tthis.parameter(SourceIdsKey, sourceIds);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to get a list of all active node IDs available to the requesting user.\n\t\t *\n\t\t * **Note** this method only works against the `/sec` version of the API endpoint.\n\t\t *\n\t\t * @return {string} the URL to access the node IDs the requesting user has access to\n\t\t */\n\t\tlistAllNodeIdsUrl() {\n\t\t\treturn this.baseUrl() + \"/nodes\";\n\t\t}\n\t};\n\nexport default NodeUrlHelperMixin;\n","import Pagination from \"../domain/pagination\";\nimport SortDescriptor from \"../domain/sortDescriptor\";\nimport UrlHelper from \"./urlHelper\";\nimport NodeUrlHelperMixin from \"./nodeUrlHelperMixin\";\nimport QueryUrlHelperMixin from \"./queryUrlHelperMixin\";\n\n/**\n * Create a NodeDatumUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeDatumMetadataUrlHelperMixin} the mixin class\n */\nconst NodeDatumMetadataUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarNode datum metadata support to {@link module:net~UrlHelper}.\n\t *\n\t * <p>Datum metadata is metadata associated with a specific node and source, i.e.\n\t * a <code>nodeId</code> and a <code>sourceId</code>.\n\t *\n\t * @mixin\n\t * @alias module:net~NodeDatumMetadataUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Get a base URL for datum metadata operations using a specific node ID.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @returns {string} the base URL\n\t\t * @private\n\t\t */\n\t\tbaseNodeDatumMetadataUrl(nodeId) {\n\t\t\treturn this.baseUrl() + \"/datum/meta/\" + (nodeId || this.nodeId);\n\t\t}\n\n\t\tnodeDatumMetadataUrlWithSource(nodeId, sourceId) {\n\t\t\tlet result = this.baseNodeDatumMetadataUrl(nodeId);\n\t\t\tlet source = sourceId || this.sourceId;\n\t\t\tif (sourceId !== null && source) {\n\t\t\t\tresult += \"?sourceId=\" + encodeURIComponent(source);\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing datum metadata.\n\t\t *\n\t\t * If no <code>sourceId</code> is provided, then the API will return all available datum metadata for all sources.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use;\n\t\t *                            if not provided the <code>sourceId</code> property of this class will be used;\n\t\t *                            if <code>null</code> then ignore any <code>sourceId</code> property of this class\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewNodeDatumMetadataUrl(nodeId, sourceId) {\n\t\t\treturn this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for adding (merging) datum metadata via a <code>POST</code> request.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use; if not provided the <code>sourceId</code> property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\taddNodeDatumMetadataUrl(nodeId, sourceId) {\n\t\t\treturn this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for setting datum metadata via a <code>PUT</code> request.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use; if not provided the <code>sourceId</code> property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\treplaceNodeDatumMetadataUrl(nodeId, sourceId) {\n\t\t\treturn this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for deleting datum metadata via a <code>DELETE</code> request.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use; if not provided the <code>sourceId</code> property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tdeleteNodeDatumMetadataUrl(nodeId, sourceId) {\n\t\t\treturn this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for searching for datum metadata.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @param {string} [sourceId] a specific source ID to use;\n\t\t *                            if not provided the <code>sourceId</code> property of this class will be used;\n\t\t *                            if <code>null</code> then ignore any <code>sourceId</code> property of this class\n\t\t * @param {SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tfindNodeDatumMetadataUrl(nodeId, sourceId, sorts, pagination) {\n\t\t\tlet result = this.baseNodeDatumMetadataUrl(nodeId);\n\t\t\tlet params = \"\";\n\t\t\tlet source = sourceId || this.sourceId;\n\t\t\tif (sourceId !== null && source) {\n\t\t\t\tparams += \"sourceId=\" + encodeURIComponent(source);\n\t\t\t}\n\t\t\tif (Array.isArray(sorts)) {\n\t\t\t\tsorts.forEach((sort, i) => {\n\t\t\t\t\tif (sort instanceof SortDescriptor) {\n\t\t\t\t\t\tif (params.length > 0) {\n\t\t\t\t\t\t\tparams += \"&\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparams += sort.toUriEncoding(i);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (pagination instanceof Pagination) {\n\t\t\t\tif (params.length > 0) {\n\t\t\t\t\tparams += \"&\";\n\t\t\t\t}\n\t\t\t\tparams += pagination.toUriEncoding();\n\t\t\t}\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tuserMetadataUrl(userId) {\n\t\t\tlet result = this.baseUrl() + \"/users/meta\";\n\t\t\tlet userParam = userId || this.userId;\n\t\t\tif (Array.isArray(userParam)) {\n\t\t\t\tif (userParam.length > 0) {\n\t\t\t\t\tuserParam = userParam[0];\n\t\t\t\t} else {\n\t\t\t\t\tuserParam = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (userParam && userId !== null) {\n\t\t\t\tresult += \"/\" + userParam;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing a specific user's metadata via a `GET` request.\n\t\t *\n\t\t * Note this URL is similar to {@link module:net~UserMetadataUrlHelperMixin#viewUserMetadataUrl}\n\t\t * but is for the read-only SolarQuery API, rather than the read-write SolarUser API.\n\t\t *\n\t\t * @param {number|null} [userId] a specific user ID;\n\t\t *                               if not provided the `userId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewUserMetadataUrl(userId) {\n\t\t\treturn this.userMetadataUrl(userId);\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~NodeDatumMetadataUrlHelperMixin},\n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n *\n * @mixes module:net~NodeDatumMetadataUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeDatumMetadataUrlHelper\n */\nclass NodeDatumMetadataUrlHelper extends NodeDatumMetadataUrlHelperMixin(\n\tQueryUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))\n) {}\n\nexport default NodeDatumMetadataUrlHelperMixin;\nexport { NodeDatumMetadataUrlHelper };\n","import DatumFilter from \"../domain/datumFilter\";\nimport UrlHelper from \"./urlHelper\";\nimport NodeUrlHelperMixin from \"./nodeUrlHelperMixin\";\nimport QueryUrlHelperMixin from \"./queryUrlHelperMixin\";\n\n/**\n * Create a NodeDatumUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeDatumUrlHelperMixin} the mixin class\n */\nconst NodeDatumUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarNode datum query support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~NodeDatumUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL for the \"reportable interval\" for a node, optionally limited to a specific set of source IDs.\n\t\t *\n\t\t * If no source IDs are provided, then the reportable interval query will return an interval for\n\t\t * all available sources.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t\t * @param {string[]} [sourceIds] an array of source IDs to limit query to; if not provided the `sourceIds` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\treportableIntervalUrl(nodeId, sourceIds) {\n\t\t\tlet url = this.baseUrl() + \"/range/interval?nodeId=\" + (nodeId || this.nodeId);\n\t\t\tlet sources = sourceIds || this.sourceIds;\n\t\t\tif (Array.isArray(sources) && sources.length > 0) {\n\t\t\t\turl += \"&sourceIds=\" + sources.map(e => encodeURIComponent(e)).join(\",\");\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for finding the available source IDs for a node or metadata filter.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} datumFilter the search criteria, which can define `nodeId`, `startDate`, `endDate`,\n\t\t *                                                and `metadataFilter` properties to limit the results to; if `nodeId` not\n\t\t *                                                provided the `nodeIds` property of this class will be used\n\t\t * @param {boolean} withNodeIds if `true` then force the response to include node IDs along with source IDs, instead of\n\t\t *                              just source IDs\n\t\t * @returns {string} the URL\n\t\t */\n\t\tavailableSourcesUrl(datumFilter, withNodeIds) {\n\t\t\tconst filter = datumFilter ? new DatumFilter(datumFilter) : this.datumFilter();\n\t\t\tif (withNodeIds !== undefined) {\n\t\t\t\tfilter.prop(\"withNodeIds\", !!withNodeIds);\n\t\t\t}\n\t\t\tlet result = this.baseUrl() + \"/range/sources\";\n\t\t\tconst params = filter.toUriEncoding();\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for querying for datum, in either raw or aggregate form.\n\t\t *\n\t\t * If the `datumFilter` has an `aggregate` value set, then aggregate results will be\n\t\t * returned by SolarNet.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tlistDatumUrl(datumFilter, sorts, pagination) {\n\t\t\tlet result = this.baseUrl() + \"/datum/list\";\n\t\t\tconst filter = datumFilter || this.datumFilter();\n\t\t\tconst params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for querying for datum _reading_ values.\n\t\t *\n\t\t * The `datumFilter` must provide the required date(s) to use for the\n\t\t * reading type. If the reading type only requires one date, then the\n\t\t * {@link module:domain~DatumFilter#startDate} or\n\t\t * {@link module:domain~DatumFilter#endDate} value should be provided.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t\t * @param {module:domain~DatumReadingType} readingType the type of reading to find\n\t\t * @param {string} [tolerance] optional query tolerance to use\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t * @see https://github.com/SolarNetwork/solarnetwork/wiki/SolarQuery-API#datum-reading\n\t\t */\n\t\tdatumReadingUrl(datumFilter, readingType, tolerance, sorts, pagination) {\n\t\t\tlet result = this.baseUrl() + \"/datum/reading\";\n\t\t\tconst filter = new DatumFilter(datumFilter) || this.datumFilter();\n\t\t\tfilter.prop(\"readingType\", readingType.name);\n\t\t\tif (tolerance) {\n\t\t\t\tfilter.prop(\"tolerance\", tolerance);\n\t\t\t}\n\t\t\tconst params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Get a new {@link module:domain~DatumFilter} configured with properties of this instance.\n\t\t *\n\t\t * This will configure the following properties:\n\t\t *\n\t\t *  * `nodeIds`\n\t\t *  * `sourceIds`\n\t\t *\n\t\t * @returns {module:domain~DatumFilter} the filter\n\t\t */\n\t\tdatumFilter() {\n\t\t\tconst filter = new DatumFilter();\n\t\t\tlet v;\n\n\t\t\tv = this.nodeIds;\n\t\t\tif (v) {\n\t\t\t\tfilter.nodeIds = v;\n\t\t\t}\n\n\t\t\tv = this.sourceIds;\n\t\t\tif (v) {\n\t\t\t\tfilter.sourceIds = v;\n\t\t\t}\n\n\t\t\treturn filter;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for querying for the most recent datum.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tmostRecentDatumUrl(datumFilter, sorts, pagination) {\n\t\t\tlet result = this.baseUrl() + \"/datum/mostRecent\";\n\t\t\tconst filter = datumFilter || this.datumFilter();\n\t\t\tconst params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~NodeDatumUrlHelperMixin},\n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n *\n * @mixes module:net~NodeDatumUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeDatumUrlHelper\n */\nclass NodeDatumUrlHelper extends NodeDatumUrlHelperMixin(\n\tQueryUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))\n) {}\n\nexport default NodeDatumUrlHelperMixin;\nexport { NodeDatumUrlHelper };\n","/**\n * The SolarUser default path.\n * @type {string}\n * @alias module:net~SolarUserDefaultPath\n */\nexport const SolarUserDefaultPath = \"/solaruser\";\n\n/**\n * The {@link module:net~UrlHelper} parameters key for the SolarUser path.\n * @type {string}\n * @alias module:net~SolarUserPathKey\n */\nexport const SolarUserPathKey = \"solarUserPath\";\n\n/**\n * The SolarUser REST API path.\n * @type {string}\n * @alias module:net~SolarUserApiPathV1\n */\nexport const SolarUserApiPathV1 = \"/api/v1/sec\";\n\nconst UserIdsKey = \"userIds\";\n\n/**\n * Create a UserUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserUrlHelperMixin} the mixin class\n */\nconst UserUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarUser specific support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~UserUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Get the default user ID.\n\t\t *\n\t\t * This gets the first available user ID from the `userIds` property.\n\t\t *\n\t\t * @returns {number} the default user ID, or `null`\n\t\t */\n\t\tget userId() {\n\t\t\tconst userIds = this.parameter(UserIdsKey);\n\t\t\treturn Array.isArray(userIds) && userIds.length > 0 ? userIds[0] : null;\n\t\t}\n\n\t\t/**\n\t\t * Set the user ID.\n\t\t *\n\t\t * This will set the `userIds` property to a new array of just the given value.\n\t\t *\n\t\t * @param {number} userId the user ID to set\n\t\t */\n\t\tset userId(userId) {\n\t\t\tthis.parameter(UserIdsKey, [userId]);\n\t\t}\n\n\t\tget userIds() {\n\t\t\treturn this.parameter(UserIdsKey);\n\t\t}\n\n\t\tset userIds(userIds) {\n\t\t\tthis.parameter(UserIdsKey, userIds);\n\t\t}\n\n\t\t/**\n\t\t * Get the base URL to the SolarUser v1 REST API.\n\t\t *\n\t\t * The returned URL uses the configured environment to resolve\n\t\t * the `hostUrl` and a `solarUserPath` context path.\n\t\t * If the context path is not available, it will default to\n\t\t * `/solaruser`.\n\t\t *\n\t\t * @returns {string} the base URL to SolarUser\n\t\t */\n\t\tbaseUrl() {\n\t\t\tconst path = this.env(SolarUserPathKey) || SolarUserDefaultPath;\n\t\t\treturn super.baseUrl() + path + SolarUserApiPathV1;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to get information about the requesting authenticated user.\n\t\t *\n\t\t * @return {string} the URL to view information about the authenticated user\n\t\t */\n\t\twhoamiUrl() {\n\t\t\treturn this.baseUrl() + \"/whoami\";\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to get a list of all active nodes for the user account.\n\t\t *\n\t\t * @return {string} the URL to access the user's active nodes\n\t\t */\n\t\tviewNodesUrl() {\n\t\t\treturn this.baseUrl() + \"/nodes\";\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to get a list of all pending nodes for the user account.\n\t\t *\n\t\t * @return {string} the URL to access the user's pending nodes\n\t\t */\n\t\tviewPendingNodesUrl() {\n\t\t\treturn this.baseUrl() + \"/nodes/pending\";\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to get a list of all archived nodes for the user account.\n\t\t *\n\t\t * @return {string} the URL to access the user's archived nodes\n\t\t */\n\t\tviewArchivedNodesUrl() {\n\t\t\treturn this.baseUrl() + \"/nodes/archived\";\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to update the archived status of a set of nodes via a `POST` request.\n\t\t *\n\t\t * @param {number|number[]|null} nodeId a specific node ID, or array of node IDs, to update; if not provided the\n\t\t *                                      `nodeIds` property of this class will be used\n\t\t * @param {boolean} archived `true` to mark the nodes as archived; `false` to un-mark\n\t\t *                           and return to normal status\n\t\t * @return {string} the URL to update the nodes archived status\n\t\t */\n\t\tupdateNodeArchivedStatusUrl(nodeId, archived) {\n\t\t\tconst nodeIds = Array.isArray(nodeId) ? nodeId : nodeId ? [nodeId] : this.nodeIds;\n\t\t\tlet result =\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/nodes/archived?nodeIds=\" +\n\t\t\t\tnodeIds.join(\",\") +\n\t\t\t\t\"&archived=\" +\n\t\t\t\t(archived ? \"true\" : \"false\");\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL to get a Node Image Maker (NIM) session key.\n\t\t *\n\t\t * @return {string} the URL to obtain a NIM session key\n\t\t */\n\t\tnimAuthorizeUrl() {\n\t\t\treturn this.baseUrl() + \"/user/nim/authorize\";\n\t\t}\n\t};\n\nexport default UserUrlHelperMixin;\n","import UrlHelper from \"./urlHelper\";\nimport NodeUrlHelperMixin from \"./nodeUrlHelperMixin\";\nimport UserUrlHelperMixin from \"./userUrlHelperMixin\";\n\n/**\n * Create a NodeInstructionUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeInstructionUrlHelperMixin} the mixin class\n */\nconst NodeInstructionUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarNode instruction support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~NodeInstructionUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL to get all details for a specific instruction.\n\t\t *\n\t\t * @param {number} instructionId the instruction ID to get\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewInstructionUrl(instructionId) {\n\t\t\treturn this.baseUrl() + \"/instr/view?id=\" + encodeURIComponent(instructionId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing active instructions.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewActiveInstructionsUrl(nodeId) {\n\t\t\treturn this.baseUrl() + \"/instr/viewActive?nodeId=\" + (nodeId || this.nodeId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing pending instructions.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewPendingInstructionsUrl(nodeId) {\n\t\t\treturn this.baseUrl() + \"/instr/viewPending?nodeId=\" + (nodeId || this.nodeId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for changing the state of an instruction.\n\t\t *\n\t\t * @param {number} instructionId the instruction ID to update\n\t\t * @param {InstructionState} state the instruction state to set\n\t\t * @returns {string} the URL\n\t\t * @see the {@link InstructionStates} enum for possible state values\n\t\t */\n\t\tupdateInstructionStateUrl(instructionId, state) {\n\t\t\treturn (\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/instr/updateState?id=\" +\n\t\t\t\tencodeURIComponent(instructionId) +\n\t\t\t\t\"&state=\" +\n\t\t\t\tencodeURIComponent(state.name)\n\t\t\t);\n\t\t}\n\n\t\t/**\n\t\t * Generate URL encoded query string for posting instruction parameters.\n\t\t *\n\t\t * @param {Object[]} [parameters] an array of parameter objects in the form `{name:n1, value:v1}`\n\t\t * @returns {string} the URL encoded query string, or an empty string if `parameters` is empty\n\t\t */\n\t\turlEncodeInstructionParameters(parameters) {\n\t\t\tvar url = \"\",\n\t\t\t\ti,\n\t\t\t\tlen;\n\t\t\tif (Array.isArray(parameters)) {\n\t\t\t\tfor (i = 0, len = parameters.length; i < len; i += 1) {\n\t\t\t\t\tif (url.length > 0) {\n\t\t\t\t\t\turl += \"&\";\n\t\t\t\t\t}\n\t\t\t\t\turl +=\n\t\t\t\t\t\tencodeURIComponent(\"parameters[\" + i + \"].name\") +\n\t\t\t\t\t\t\"=\" +\n\t\t\t\t\t\tencodeURIComponent(parameters[i].name) +\n\t\t\t\t\t\t\"&\" +\n\t\t\t\t\t\tencodeURIComponent(\"parameters[\" + i + \"].value\") +\n\t\t\t\t\t\t\"=\" +\n\t\t\t\t\t\tencodeURIComponent(parameters[i].value);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for posting an instruction request.\n\t\t *\n\t\t * @param {string} topic the instruction topic\n\t\t * @param {Object[]} [parameters] an array of parameter objects in the form `{name:n1, value:v1}`\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tqueueInstructionUrl(topic, parameters, nodeId) {\n\t\t\tvar url =\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/instr/add/\" +\n\t\t\t\tencodeURIComponent(topic) +\n\t\t\t\t\"?nodeId=\" +\n\t\t\t\t(nodeId || this.nodeId);\n\t\t\tif (Array.isArray(parameters) && parameters.length > 0) {\n\t\t\t\turl += \"&\" + this.urlEncodeInstructionParameters(parameters);\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for posting instruction requests for multiple nodes.\n\t\t *\n\t\t * @param {string} topic the instruction topic\n\t\t * @param {Object[]} [parameters] an array of parameter objects in the form `{name:n1, value:v1}`\n\t\t * @param {number[]} [nodeIds] a list of node IDs to use; if not provided the `nodeIds` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tqueueInstructionsUrl(topic, parameters, nodeIds) {\n\t\t\tvar url =\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/instr/add/\" +\n\t\t\t\tencodeURIComponent(topic) +\n\t\t\t\t\"?nodeIds=\" +\n\t\t\t\t(Array.isArray(nodeIds) && nodeIds.length > 0\n\t\t\t\t\t? nodeIds.join(\",\")\n\t\t\t\t\t: Array.isArray(this.nodeIds)\n\t\t\t\t\t? this.nodeIds.join(\",\")\n\t\t\t\t\t: \"\");\n\t\t\tif (Array.isArray(parameters) && parameters.length > 0) {\n\t\t\t\turl += \"&\" + this.urlEncodeInstructionParameters(parameters);\n\t\t\t}\n\t\t\treturn url;\n\t\t}\n\n\t\t/**\n\t\t * Create an instruction parameter suitable to passing to {@link NodeInstructionUrlHelperMixin#queueInstructionUrl}.\n\t\t *\n\t\t * @param {string} name the parameter name\n\t\t * @param {*} value the parameter value\n\t\t * @returns {object} with `name` and `value` properties\n\t\t */\n\t\tstatic instructionParameter(name, value) {\n\t\t\treturn { name: name, value: value };\n\t\t}\n\t};\n\n/**\n * A concrete {@link UrlHelper} with the {@link module:net~NodeInstructionUrlHelperMixin},\n * {@link module:net~UserUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n *\n * @mixes module:net~NodeInstructionUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeInstructionUrlHelper\n */\nclass NodeInstructionUrlHelper extends NodeInstructionUrlHelperMixin(\n\tUserUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))\n) {}\n\n/**\n * The static {@link NodeInstructionUrlHelperMixin#instructionParameter} method so it can be imported directly.\n *\n * @alias module:net~instructionParameter\n */\nconst instructionParameter = NodeInstructionUrlHelper.instructionParameter;\n\nexport default NodeInstructionUrlHelperMixin;\nexport { instructionParameter, NodeInstructionUrlHelper };\n","import Pagination from \"../domain/pagination\";\nimport SortDescriptor from \"../domain/sortDescriptor\";\nimport UrlHelper from \"./urlHelper\";\nimport NodeUrlHelperMixin from \"./nodeUrlHelperMixin\";\nimport UserUrlHelperMixin from \"./userUrlHelperMixin\";\n\n/**\n * Create a NodeMetadataUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeMetadataUrlHelperMixin} the mixin class\n */\nconst NodeMetadataUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds SolarNode metadata support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~NodeMetadataUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL for viewing the configured node's metadata.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewNodeMetadataUrl(nodeId) {\n\t\t\treturn this.baseUrl() + \"/nodes/meta/\" + (nodeId || this.nodeId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for adding metadata to a node via a `POST` request.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\taddNodeMetadataUrl(nodeId) {\n\t\t\treturn this.viewNodeMetadataUrl(nodeId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for setting the metadata of a node via a `PUT` request.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\treplaceNodeMetadataUrl(nodeId) {\n\t\t\treturn this.viewNodeMetadataUrl(nodeId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for deleting the metadata of a node via a `DELETE` request.\n\t\t *\n\t\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t\t * @returns {string} the URL\n\t\t */\n\t\tdeleteNodeMetadataUrl(nodeId) {\n\t\t\treturn this.viewNodeMetadataUrl(nodeId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for searching for node metadata.\n\t\t *\n\t\t * @param {number|number[]} [nodeId] a specific node ID, or array of node IDs, to use; if not provided the\n\t\t *                                   `nodeIds` property of this class will be used, unless `null`\n\t\t *                                   is passed in which case no node IDs will be added to the URL so that all available\n\t\t *                                   node metadata objects will be returned\n\t\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t\t * @returns {string} the URL\n\t\t */\n\t\tfindNodeMetadataUrl(nodeId, sorts, pagination) {\n\t\t\tconst nodeIds = Array.isArray(nodeId)\n\t\t\t\t? nodeId\n\t\t\t\t: nodeId\n\t\t\t\t? [nodeId]\n\t\t\t\t: nodeId !== null\n\t\t\t\t? this.nodeIds\n\t\t\t\t: undefined;\n\t\t\tlet result = this.baseUrl() + \"/nodes/meta\";\n\t\t\tlet params = \"\";\n\t\t\tif (Array.isArray(nodeIds)) {\n\t\t\t\tparams += \"nodeIds=\" + nodeIds.join(\",\");\n\t\t\t}\n\t\t\tif (Array.isArray(sorts)) {\n\t\t\t\tsorts.forEach((sort, i) => {\n\t\t\t\t\tif (sort instanceof SortDescriptor) {\n\t\t\t\t\t\tif (params.length > 0) {\n\t\t\t\t\t\t\tparams += \"&\";\n\t\t\t\t\t\t}\n\t\t\t\t\t\tparams += sort.toUriEncoding(i);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\tif (pagination instanceof Pagination) {\n\t\t\t\tif (params.length > 0) {\n\t\t\t\t\tparams += \"&\";\n\t\t\t\t}\n\t\t\t\tparams += pagination.toUriEncoding();\n\t\t\t}\n\t\t\tif (params.length > 0) {\n\t\t\t\tresult += \"?\" + params;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~NodeMetadataUrlHelperMixin},\n * {@link module:net~UserUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n *\n * @mixes module:net~NodeMetadataUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeMetadataUrlHelper\n */\nclass NodeMetadataUrlHelper extends NodeMetadataUrlHelperMixin(\n\tUserUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))\n) {}\n\nexport default NodeMetadataUrlHelperMixin;\nexport { NodeMetadataUrlHelper };\n","import UrlHelper from \"./urlHelper\";\nimport UserUrlHelperMixin from \"./userUrlHelperMixin\";\n\n/**\n * Create a UserAuthTokenUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserAuthTokenUrlHelperMixin} the mixin class\n */\nconst UserAuthTokenUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds security token support to a SolarUser {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~UserAuthTokenUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL for listing all available auth tokens.\n\t\t *\n\t\t * @returns {string} the URL\n\t\t */\n\t\tlistAllAuthTokensUrl() {\n\t\t\treturn this.baseUrl() + \"/user/auth-tokens\";\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for creating a new auth token, via a `POST` request.\n\t\t *\n\t\t * The request body accepts a {@link module:domain~SecurityPolicy} JSON document.\n\t\t *\n\t\t * @param {AuthTokenType} type the auth token type to generate\n\t\t * @returns {string} the URL\n\t\t */\n\t\tgenerateAuthTokenUrl(type) {\n\t\t\treturn this.baseUrl() + \"/user/auth-tokens/generate/\" + type.name;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for accessing an auth token.\n\t\t *\n\t\t * @param {string} tokenId the token ID\n\t\t * @returns {string} the URL\n\t\t * @private\n\t\t */\n\t\tauthTokenUrl(tokenId) {\n\t\t\treturn this.baseUrl() + \"/user/auth-tokens/\" + encodeURIComponent(tokenId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for deleting an auth token, via a `DELETE` request.\n\t\t *\n\t\t * @param {string} tokenId the token ID to delete\n\t\t * @returns {string} the URL\n\t\t */\n\t\tdeleteAuthTokenUrl(tokenId) {\n\t\t\treturn this.authTokenUrl(tokenId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for updating (merging) a security policy on an auth token,\n\t\t * via a `PATCH` request.\n\t\t *\n\t\t * The request body accepts a {@link module:net~SecurityPolicy} JSON document.\n\t\t *\n\t\t * @param {string} tokenId the ID of the token to update\n\t\t * @returns {string} the URL\n\t\t */\n\t\tupdateAuthTokenSecurityPolicyUrl(tokenId) {\n\t\t\treturn this.authTokenUrl(tokenId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for replacing a security policy on an auth token,\n\t\t * via a `PUT` request.\n\t\t *\n\t\t * The request body accepts a {@link module:domain~SecurityPolicy} JSON document.\n\t\t *\n\t\t * @param {string} tokenId the ID of the token to update\n\t\t * @returns {string} the URL\n\t\t */\n\t\treplaceAuthTokenSecurityPolicyUrl(tokenId) {\n\t\t\treturn this.authTokenUrl(tokenId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for updating the status of an auth token,\n\t\t * via a `POST` request.\n\t\t *\n\t\t * @param {string} tokenId the ID of the token to update\n\t\t * @param {AuthTokenStatus} status the status to change to\n\t\t * @returns {string} the URL\n\t\t */\n\t\tupdateAuthTokenStatusUrl(tokenId, status) {\n\t\t\treturn this.authTokenUrl(tokenId) + \"?status=\" + encodeURIComponent(status.name);\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~UserAuthTokenUrlHelperMixin} and\n * {@link module:net~UserUrlHelperMixin} mixins.\n *\n * @mixes module:net~UserAuthTokenUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~UserAuthTokenUrlHelper\n */\nclass UserAuthTokenUrlHelper extends UserAuthTokenUrlHelperMixin(UserUrlHelperMixin(UrlHelper)) {}\n\nexport default UserAuthTokenUrlHelperMixin;\nexport { UserAuthTokenUrlHelper };\n","import UrlHelper from \"./urlHelper\";\nimport UserUrlHelperMixin from \"./userUrlHelperMixin\";\nimport { timestampFormat } from \"../format/date\";\nimport PropMap from \"../util/propMap\";\n\n/**\n * Create a UserDatumAuxiliaryUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserDatumAuxiliaryUrlHelperMixin} the mixin class\n */\nconst UserDatumAuxiliaryUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds user datum auxiliary support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~UserDatumAuxiliaryUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\tuserDatumAuxiliaryBaseUrl() {\n\t\t\treturn this.baseUrl() + \"/datum/auxiliary\";\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing the configured user's metadata via a `GET` request.\n\t\t *\n\t\t * @param {module:domain~DatumFilter} filter the search criteria\n\t\t * @returns {string} the URL\n\t\t */\n\t\tlistUserDatumAuxiliaryUrl(filter) {\n\t\t\tlet result = this.userDatumAuxiliaryBaseUrl();\n\t\t\tif (filter) {\n\t\t\t\tconst params = filter.toUriEncoding();\n\t\t\t\tif (params.length > 0) {\n\t\t\t\t\tresult += \"?\" + params;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for accessing a specific `DatumAuxiliaryType` by its primary key.\n\t\t *\n\t\t * If `sourceId` contains any `/` characters, then {@link module:net~UserDatumAuxiliaryUrlHelperMixin#userDatumAuxiliaryIdQueryUrl}\n\t\t * will be invoked instead.\n\t\t *\n\t\t * @param {module:domain~DatumAuxiliaryType} type the datum auxiliary type\n\t\t * @param {number} nodeId the node ID\n\t\t * @param {Date} date a date\n\t\t * @param {string} sourceId the source ID\n\t\t * @returns {string} the URL\n\t\t */\n\t\tuserDatumAuxiliaryIdUrl(type, nodeId, date, sourceId) {\n\t\t\tif (sourceId && sourceId.indexOf(\"/\") >= 0) {\n\t\t\t\t// force use of query parameters if source ID has slash characters\n\t\t\t\treturn this.userDatumAuxiliaryIdQueryUrl(type, nodeId, date, sourceId);\n\t\t\t}\n\t\t\tlet result = this.userDatumAuxiliaryBaseUrl();\n\t\t\tresult +=\n\t\t\t\t\"/\" +\n\t\t\t\tencodeURIComponent(type.name ? type.name : type) +\n\t\t\t\t\"/\" +\n\t\t\t\tencodeURIComponent(nodeId) +\n\t\t\t\t\"/\" +\n\t\t\t\tencodeURIComponent(timestampFormat(date)) +\n\t\t\t\t\"/\" +\n\t\t\t\tencodeURIComponent(sourceId);\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for accessing a specific `DatumAuxiliaryType` by its primary key,\n\t\t * using query parameters for id components.\n\t\t *\n\t\t * @param {module:domain~DatumAuxiliaryType} type the datum auxiliary type\n\t\t * @param {number} nodeId the node ID\n\t\t * @param {Date} date a date\n\t\t * @param {string} sourceId the source ID\n\t\t * @returns {string} the URL\n\t\t */\n\t\tuserDatumAuxiliaryIdQueryUrl(type, nodeId, date, sourceId) {\n\t\t\tlet result = this.userDatumAuxiliaryBaseUrl();\n\t\t\tlet props = new PropMap({\n\t\t\t\ttype: type,\n\t\t\t\tnodeId: nodeId,\n\t\t\t\tdate: timestampFormat(date),\n\t\t\t\tsourceId: sourceId\n\t\t\t});\n\t\t\tlet query = props.toUriEncoding();\n\t\t\tif (query.length > 0) {\n\t\t\t\tresult += \"?\" + query;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for storing a `DatumAuxiliaryType` via a `POST` request.\n\t\t *\n\t\t * The {@link module:net~UserDatumAuxiliaryUrlHelperMixin#userDatumAuxiliaryIdUrl} method is used\n\t\t * to generate the URL.\n\t\t *\n\t\t * @param {module:domain~DatumAuxiliaryType} type the datum auxiliary type\n\t\t * @param {number} nodeId the node ID\n\t\t * @param {Date} date a date\n\t\t * @param {string} sourceId the source ID\n\t\t * @returns {string} the URL\n\t\t */\n\t\tstoreUserDatumAuxiliaryUrl(type, nodeId, date, sourceId) {\n\t\t\treturn this.userDatumAuxiliaryIdUrl(type, nodeId, date, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing a `DatumAuxiliaryType` via a `GET` request.\n\t\t *\n\t\t * The {@link module:net~UserDatumAuxiliaryUrlHelperMixin#userDatumAuxiliaryIdUrl} method is used\n\t\t * to generate the URL.\n\t\t *\n\t\t * @param {module:domain~DatumAuxiliaryType} type the datum auxiliary type\n\t\t * @param {number} nodeId the node ID\n\t\t * @param {Date} date a date\n\t\t * @param {string} sourceId the source ID\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewUserDatumAuxiliaryUrl(type, nodeId, date, sourceId) {\n\t\t\treturn this.userDatumAuxiliaryIdUrl(type, nodeId, date, sourceId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for deleting a `DatumAuxiliaryType` via a `DELETE` request.\n\t\t *\n\t\t * The {@link module:net~UserDatumAuxiliaryUrlHelperMixin#userDatumAuxiliaryIdUrl} method is used\n\t\t * to generate the URL.\n\t\t *\n\t\t * @param {module:domain~DatumAuxiliaryType} type the datum auxiliary type\n\t\t * @param {number} nodeId the node ID\n\t\t * @param {Date} date a date\n\t\t * @param {string} sourceId the source ID\n\t\t * @returns {string} the URL\n\t\t */\n\t\tdeleteUserDatumAuxiliaryUrl(type, nodeId, date, sourceId) {\n\t\t\treturn this.userDatumAuxiliaryIdUrl(type, nodeId, date, sourceId);\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~UserDatumAuxiliaryUrlHelperMixin}\n * and {@link module:net~UserUrlHelperMixin} mixins.\n *\n * @mixes module:net~UserDatumAuxiliaryUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~UserDatumAuxiliaryUrlHelper\n */\nclass UserDatumAuxiliaryUrlHelper extends UserDatumAuxiliaryUrlHelperMixin(\n\tUserUrlHelperMixin(UrlHelper)\n) {}\n\nexport default UserDatumAuxiliaryUrlHelperMixin;\nexport { UserDatumAuxiliaryUrlHelper };\n","import UrlHelper from \"./urlHelper\";\nimport UserUrlHelperMixin from \"./userUrlHelperMixin\";\n\n/**\n * Create a UserMetadataUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserMetadataUrlHelperMixin} the mixin class\n */\nconst UserMetadataUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds user metadata support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~UserMetadataUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL for viewing the configured user's metadata via a <code>GET</code> request.\n\t\t *\n\t\t * @param {module:domain~UserMetadataFilter} filter the search criteria\n\t\t * @returns {string} the URL\n\t\t */\n\t\tfindUserMetadataUrl(filter) {\n\t\t\tlet result = this.baseUrl() + \"/users/meta\";\n\t\t\tif (filter) {\n\t\t\t\tconst params = filter.toUriEncoding();\n\t\t\t\tif (params.length > 0) {\n\t\t\t\t\tresult += \"?\" + params;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\tuserMetadataUrl(userId) {\n\t\t\tlet result = this.baseUrl() + \"/users/meta\";\n\t\t\tlet userParam = userId || this.userId;\n\t\t\tif (Array.isArray(userParam)) {\n\t\t\t\tif (userParam.length > 0) {\n\t\t\t\t\tuserParam = userParam[0];\n\t\t\t\t} else {\n\t\t\t\t\tuserParam = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (userParam && userId !== null) {\n\t\t\t\tresult += \"/\" + userParam;\n\t\t\t}\n\t\t\treturn result;\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for viewing a specific user's metadata via a <code>GET</code> request.\n\t\t *\n\t\t * @param {number|null} [userId] a specific user ID;\n\t\t *                               if not provided the <code>userId</code> property of this class will be used;\n\t\t *                               if <code>null</code> then view metadata of the requesting user\n\t\t * @returns {string} the URL\n\t\t */\n\t\tviewUserMetadataUrl(userId) {\n\t\t\treturn this.userMetadataUrl(userId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for adding user metadata via a <code>POST</code> request.\n\t\t *\n\t\t * @param {number|null} [userId] a specific user ID;\n\t\t *                               if not provided the <code>userId</code> property of this class will be used;\n\t\t *                               if <code>null</code> then add metadata to the requesting user\n\t\t * @returns {string} the URL\n\t\t */\n\t\taddUserMetadataUrl(userId) {\n\t\t\treturn this.userMetadataUrl(userId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for replacing user metadata via a <code>PUT</code> request.\n\t\t *\n\t\t * @param {number|null} [userId] a specific user ID;\n\t\t *                               if not provided the <code>userId</code> property of this class will be used;\n\t\t *                               if <code>null</code> then add metadata to the requesting user\n\t\t * @returns {string} the URL\n\t\t */\n\t\treplaceUserMetadataUrl(userId) {\n\t\t\treturn this.userMetadataUrl(userId);\n\t\t}\n\n\t\t/**\n\t\t * Generate a URL for deleting user metadata via a <code>DELETE</code> request.\n\t\t *\n\t\t * @param {number|null} [userId] a specific user ID;\n\t\t *                               if not provided the <code>userId</code> property of this class will be used;\n\t\t *                               if <code>null</code> then add metadata to the requesting user\n\t\t * @returns {string} the URL\n\t\t */\n\t\tdeleteUserMetadataUrl(userId) {\n\t\t\treturn this.userMetadataUrl(userId);\n\t\t}\n\t};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~UserMetadataUrlHelperMixin}\n * and {@link module:net~UserUrlHelperMixin} mixins.\n *\n * @mixes module:net~UserMetadataUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~UserMetadataUrlHelper\n */\nclass UserMetadataUrlHelper extends UserMetadataUrlHelperMixin(UserUrlHelperMixin(UrlHelper)) {}\n\nexport default UserMetadataUrlHelperMixin;\nexport { UserMetadataUrlHelper };\n","/**\n * Get an appropriate multiplier value for scaling a given value to a more display-friendly form.\n *\n * This will return values suitable for passing to {@link module:format~displayUnitsForScale}.\n *\n * @param {number} value the value to get a display scale factor for, for example the maximum value\n *                       in a range of values\n * @return {number} the display scale factor\n * @alias module:format~displayScaleForValue\n */\nexport function displayScaleForValue(value) {\n\tvar result = 1,\n\t\tnum = Math.abs(Number(value));\n\tif (isNaN(num) === false) {\n\t\tif (num >= 1000000000) {\n\t\t\tresult = 1000000000;\n\t\t} else if (num >= 1000000) {\n\t\t\tresult = 1000000;\n\t\t} else if (num >= 1000) {\n\t\t\tresult = 1000;\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Get an appropriate display unit for a given base unit and scale factor.\n *\n * Use this method to render scaled data value units. Typically you would first call\n * {@link module:module:format~displayScaleForValue}, passing in the largest expected value\n * in a set of data, and then pass the result to this method to generate a display unit\n * for the base unit for that data.\n *\n * For example, given a base unit of `W` (watts) and a maximum data value of `10000`:\n *\n * ```\n * const fmt = import { * } from 'format/scale';\n * const displayScale = fmt.displayScaleForValue(10000);\n * const displayUnit = fmt.displayUnitForScale('W', displayScale);\n * ```\n *\n * The `displayUnit` result in that example would be `kW`.\n *\n * @param {string} baseUnit the base unit, for example `W` or `Wh`\n * @param {number} scale the unit scale, which must be a recognized SI scale, such\n *                       as `1000` for `k`\n * @return {string} the display unit value\n * @alias module:format~displayUnitsForScale\n */\nexport function displayUnitsForScale(baseUnit, scale) {\n\treturn (\n\t\t(scale === 1000000000 ? \"G\" : scale === 1000000 ? \"M\" : scale === 1000 ? \"k\" : \"\") +\n\t\tbaseUnit\n\t);\n}\n","import { dateFormat } from \"../format/date\";\n\n/**\n * Create a AuthTokenUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~AuthTokenUrlHelperMixin} the mixin class\n */\nconst AuthTokenUrlHelperMixin = superclass =>\n\t/**\n\t * A mixin class that adds authentication token support to {@link module:net~UrlHelper}.\n\t *\n\t * @mixin\n\t * @alias module:net~AuthTokenUrlHelperMixin\n\t */\n\tclass extends superclass {\n\t\t/**\n\t\t * Generate a URL to refresh the signing key of an authentication token.\n\t\t *\n\t\t * **Note** this method only works against the `/sec` version of the API endpoint.\n\t\t *\n\t\t * @param {date} date the signing date to use, or `null` for the current date\n\t\t * @returns {string} the URL\n\t\t */\n\t\trefreshTokenV2Url(date) {\n\t\t\treturn (\n\t\t\t\tthis.baseUrl() +\n\t\t\t\t\"/auth-tokens/refresh/v2?date=\" +\n\t\t\t\tencodeURIComponent(dateFormat(date || new Date()))\n\t\t\t);\n\t\t}\n\t};\n\nexport default AuthTokenUrlHelperMixin;\n"]}