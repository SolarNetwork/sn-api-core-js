{"version":3,"sources":["../src/format/date.js","../src/util/date.js","../src/data/nest.js","../src/domain/datumFilter.js","../src/domain/generalMetadata.js","../src/domain/securityPolicy.js","../src/util/multiMap.js","../src/util/configuration.js","../src/net/environment.js","../src/net/urlQuery.js","../src/net/authV2.js","../src/util/logger.js","../src/data/array.js","../src/util/enum.js","../src/util/comparableEnum.js","../src/domain/aggregation.js","../src/domain/authTokenStatus.js","../src/domain/authTokenType.js","../src/domain/combiningType.js","../src/domain/pagination.js","../src/domain/sortDescriptor.js","../src/util/propMap.js","../src/domain/location.js","../src/domain/datumReadingType.js","../src/domain/instructionState.js","../src/domain/locationPrecision.js","../src/net/httpHeaders.js","../src/net/urlHelper.js","../src/net/locationUrlHelperMixin.js","../src/net/queryUrlHelperMixin.js","../src/net/locationDatumMetadataUrlHelperMixin.js","../src/net/locationDatumUrlHelperMixin.js","../src/net/nodeUrlHelperMixin.js","../src/net/nodeDatumMetadataUrlHelperMixin.js","../src/net/nodeDatumUrlHelperMixin.js","../src/net/userUrlHelperMixin.js","../src/net/nodeInstructionUrlHelperMixin.js","../src/net/nodeMetadataUrlHelperMixin.js","../src/net/userAuthTokenUrlHelperMixin.js","../src/net/userMetadataUrlHelperMixin.js","../src/format/scale.js","../src/net/authTokenUrlHelperMixin.js"],"names":["iso8601Date","date","includeTime","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","datumDate","d","localDate","dateTimeParse","localTime","created","timestampParse","dateTimeUrlParse","normalizeNestedStackDataByDate","layerData","fillTemplate","fillFn","j","k","dummy","prop","copyIndex","i","jMax","length","max","map","e","values","undefined","getTime","sourceId","key","hasOwnProperty","splice","idMapQueryParameterValue","Map","size","result","_step","Symbol","iterator","_iteratorNormalCompletion","_iterator","next","done","value","Set","push","Array","from","join","datumFilterUriEncodingPropertyMapper","NodeIdsKey","LocationIdsKey","SourceIdsKey","UserIdsKey","isArray","substring","StartDateKey","EndDateKey","dateTimeUrlFormat","MostRecentKey","NodeIdMapsKey","SourceIdMapsKey","p","stringMapToObject","strMap","obj","Object","create","_ref2","v","objectToStringMap","_step2","keys","_iteratorNormalCompletion2","_iterator2","set","_typeof","setOrNull","mergedSets","set1","set2","s1","s2","add","addValue","replace","keyLc","toLowerCase","mapping","mappings","val","mappingNames","len","createGetter","me","createSetter","createProperty","defineProperty","normalizedProtocol","normalizedConfig","config","assign","protocol","port","host","hostname","urlQueryParse","search","multiValueKeys","pairs","pair","params","match","split","decodeURIComponent","has","caseInsensitiveEqualsFn","valueLc","toString","lowercaseSortedArray","items","sortedItems","sort","_hexEscapeChar","c","charCodeAt","toUpperCase","_encodeURIComponent","str","encodeURIComponent","consoleLog","level","logLevel","console","logFn","error","warn","info","log","args","_len","_key","arguments","array","freeze","data","aggregate","aggMillseconds","currTime","expectedNextTime","nextTime","fill","fillTime","f","getPrototypeOf","getOwnPropertyDescriptors","Date","prototype","apply","Enum","name","_name","this","constructor","enums","reduce","enumValues","ComparableEnum","_value","_this","other","minEnum","cache","get","agg","compareTo","Aggregation","AggregationValues","Number","MAX_SAFE_INTEGER","Aggregations","enumsValue","timestampFormat","utcFormat","dateTimeFormat","dateFormat","utcParse","aggregateTimeCount","endDate","exclusiveEndDate","interval","ceil","offset","timeCountValue","propName","isNaN","end","start","timeUnit","timeCount","Hour","utcMinute","precision","Math","min","setUTCMinutes","utcHour","Month","equals","Year","utcMonth","utcYear","floor","Day","utcDay","nest$1","resultKey","copyProperties","sumProperties","staticProperties","dataLength","clone","layerCount","copyPropLength","sumPropLength","metricName","sourceIdMap","aggFn","metricExtractorFn","rollupFn","sum","nest","sortKeys","ascending","rollup","r","metricKey","entries","layer","combined","forEach","AuthTokenStatus","_Enum","AuthTokenStatusValues","AuthTokenStatuses","AuthTokenType","AuthTokenTypeValues","AuthTokenTypes","CombiningType","CombiningTypeValues","CombiningTypes","Pagination","_max","_offset","SortDescriptor","descending","_descending","index","propertyName","PropMap","props","properties","newValue","newProps","callbackFn","forceMultiKey","kv","toUriEncoding","_k","sorts","pagination","paginationParams","Location","loc","DatumFilter","nodeIds","nodeId","locationIds","locationId","sourceIds","userIds","userId","path","t","DatumReadingType","DatumReadingTypeValues","DatumReadingTypes","GeneralMetadata","propertyInfo","tags","JSON","stringify","json","m","pm","parse","InstructionState","InstructionStateValues","InstructionStates","LocationPrecision","LocationPrecisionValues","LocationPrecisions","SecurityPolicy","aggregations","minAggregation","locationPrecisions","minLocationPrecision","nodeMetadataPaths","userMetadataPaths","_nodeIds","_sourceIds","_aggregations","_minAggregation","_locationPrecisions","_minLocationPrecision","_nodeMetadataPaths","_userMetadataPaths","MIN_AGGREGATION_CACHE","MIN_LOCATION_PRECISION_CACHE","SecurityPolicyBuilder","policy","withAggregations","withMinAggregation","withLocationPrecisions","withMinLocationPrecision","withNodeIds","withSourceIds","withNodeMetadataPaths","withUserMetadataPaths","addAggregations","addLocationPrecisions","addNodeIds","addSourceIds","addNodeMetadataPaths","addUserMetadataPaths","minimumEnumSet","buildAggregations","buildLocationPrecisions","MultiMap","putAll","indexOf","Configuration","initialMap","enabled","newMap","Environment","HttpMethod","HttpContentType","HttpHeaders","defineProperties","urlQuery","parameters","encoderFn","handleValue","encoder","AuthorizationV2Builder","token","environment","tokenId","forceHostPort","reset","contentDigest","httpHeaders","signedHeaderNames","method","GET","tokenSecret","signingKey","computeSigningKey","signingKeyExpiration","requestDate","httpMethod","put","HOST","requestPath","url","uri","uriParse","scheme","query","queryParams","CONTENT_TYPE","useSnDate","headerName","headerValue","headers","digest","Hex","content","SHA256","contentSHA256","header","Base64","keySet","first","vals","valsLen","sortedLowercaseHeaderNames","toUTCString","firstValue","trim","EMPTY_STRING_SHA256_HEX","X_SN_DATE","DATE","containsKey","CONTENT_MD5","DIGEST","computeCanonicalRequestData","canonicalHeaderNames","canonicalQueryParameters","canonicalHeaders","canonicalSignedHeaderNames","canonicalContentSHA256","secretKey","datestring","HmacSHA256","canonicalRequestData","sortedHeaderNames","canonicalReq","signatureData","computeSignatureData","signature","buildWithKey","now","signedHeaders","findIndex","existingIndex","concat","remove","UrlHelper","env","_parameters","_environment","tls","useTls","hostUrl","template","resolveTemplateUrl","variableName","variableValue","LocationUrlHelperMixin","superclass","filter","baseUrl","toUriEncodingWithSorting","parameter","QueryUrlHelperMixin","isPubPath","publicQuery","LocationDatumMetadataUrlHelperMixin","baseLocationDatumMetadataUrl","source","locationDatumMetadataUrlWithSource","LocationDatumMetadataUrlHelper","LocationDatumUrlHelperMixin","startDate","datumFilter","LocationDatumUrlHelper","NodeUrlHelperMixin","NodeDatumMetadataUrlHelperMixin","baseNodeDatumMetadataUrl","nodeDatumMetadataUrlWithSource","userParam","userMetadataUrl","NodeDatumMetadataUrlHelper","NodeDatumUrlHelperMixin","sources","readingType","tolerance","NodeDatumUrlHelper","UserUrlHelperMixin","babelHelpers.get","archived","NodeInstructionUrlHelperMixin","instructionId","state","topic","NodeInstructionUrlHelper","instructionParameter","NodeMetadataUrlHelperMixin","viewNodeMetadataUrl","NodeMetadataUrlHelper","UserAuthTokenUrlHelperMixin","type","authTokenUrl","status","UserAuthTokenUrlHelper","UserMetadataUrlHelperMixin","UserMetadataUrlHelper","logLevels","Logger","_len2","_key2","_len3","_key3","_len4","_key4","_len5","_key5","isoParse","num","abs","baseUnit","scale"],"mappings":"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","file":"lib/solarnetwork-api-core.min.js.map","sourcesContent":["import { utcFormat, utcParse, isoParse } from 'd3-time-format';\n\n/**\n * Format a date into a SolarNet UTC timestamp format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd HH:mm:ss.SSS'Z'`\n * @alias module:format~timestampFormat\n */\nexport const timestampFormat = utcFormat(\"%Y-%m-%d %H:%M:%S.%LZ\");\n\n/**\n * Format a date into a SolarNet UTC date/time format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd HH:mm`\n * @alias module:format~dateTimeFormat\n */\nexport const dateTimeFormat = utcFormat(\"%Y-%m-%d %H:%M\");\n\n/**\n * Format a date into a SolarNet URL UTC date/time format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd'T'HH:mm`\n * @alias module:format~dateTimeUrlFormat\n */\nexport const dateTimeUrlFormat = utcFormat(\"%Y-%m-%dT%H:%M\");\n\n/**\n * Format a date into a SolarNet UTC date format.\n * @function\n * @param {Date} date the date to format\n * @returns {string} the formatted date value - `yyyy-MM-dd`\n * @alias module:format~dateFormat\n */\nexport const dateFormat = utcFormat(\"%Y-%m-%d\");\n\n/**\n * Parse a SolarNet UTC timestamp value.\n * @function\n * @param {string} str the string to parse - `yyyy-MM-dd HH:mm:ss.SSS'Z'\n * @returns {Date} the parsed date, or `null`\n * @alias module:format~timestampParse\n */\nexport const timestampParse = utcParse(\"%Y-%m-%d %H:%M:%S.%LZ\");\n\n/**\n * Parse a SolarNet UTC date/time.\n * @function\n * @param {string} str the string to parse - `yyyy-MM-dd HH:mm\n * @returns {Date} the parsed date, or `null`\n * @alias module:format~dateTimeParse\n */\nexport const dateTimeParse = utcParse(\"%Y-%m-%d %H:%M\");\n\nexport { \n\t/**\n\t * Parse a SolarNet URL UTC date/time value.\n\t * @function\n\t * @param {string} str the string to parse - `yyyy-MM-dd'T'HH:mm`\n\t * @returns {Date} the parsed date, or `null`\n\t * @alias module:format~dateTimeUrlParse\n\t */\n\tisoParse as dateTimeUrlParse, \n\t\n\t/**\n\t * Parse a SolarNet UTC date value.\n\t * @function\n\t * @param {string} str the string to parse - `yyyy-MM-dd`\n\t * @returns {Date} the parsed date, or `null`\n\t * @alias module:format~dateParse\n\t */\n\tisoParse as dateParse } from 'd3-time-format';\n\n/**\n * Parse a UTC date string, from a variety of supported formats.\n *\n * @param {String} str the string to parse into a date\n * @returns {Date} the parsed `Date`, or `null` if the date can't be parsed\n * @alias module:format~dateParser\n */\nexport function dateParser(str) {\n\tvar date = isoParse(str)\n\t\t|| timestampParse(str)\n\t\t|| dateTimeParse(str);\n\treturn date;\n}\n\n/**\n * Format a date into an ISO 8601 timestamp or date string, in the UTC time zone.\n * \n * @param {Date} date the date to format \n * @param {boolean} [includeTime=false] `true` to format as a timestamp, `false` as just a date\n * @returns {string} the formatted date string\n * @alias module:format~iso8601Date\n */\nexport function iso8601Date(date, includeTime) {\n\treturn ''+date.getUTCFullYear()\n\t\t\t+(date.getUTCMonth() < 9 ? '0' : '') +(date.getUTCMonth()+1)\n\t\t\t+(date.getUTCDate() < 10 ? '0' : '') + date.getUTCDate()\n\t\t\t+(includeTime ?\n\t\t\t\t'T'\n\t\t\t\t+(date.getUTCHours() < 10 ? '0' : '') + date.getUTCHours()\n\t\t\t\t+(date.getUTCMinutes() < 10 ? '0' : '') + date.getUTCMinutes()\n\t\t\t\t+(date.getUTCSeconds() < 10 ? '0' : '') +date.getUTCSeconds()\n\t\t\t\t+'Z'\n\t\t\t\t: '');\n}\n\n/**\n * Get a UTC season constant for a date. Seasons are groups of 3 months, e.g. \n * Spring, Summer, Autumn, Winter.\n * \n * The returned value will be a number between 0 and 3, where:\n * \n *  * (Mar, Apr, May) = `0`\n *  * (Jun, Jul, Aug) = `1`\n *  * (Sep, Oct, Nov) = `2`\n *  * (Dec, Jan, Feb) = `3`\n * \n * @param {Date|number} date either a date to get the season for, or a number representing the UTC month of a date\n * @returns {number} a season constant number, from 0 - 3\n * @alias module:format~seasonForDate\n */\nexport function seasonForDate(date) {\n\tconst m = (date.getUTCMonth ? date.getUTCMonth() : Number(date));\n\tif ( m < 2 || m === 11 ) {\n\t\treturn 3;\n\t} else if ( m < 5 ) {\n\t\treturn 0;\n\t} else if ( m < 8 ) {\n\t\treturn 1;\n\t} else {\n\t\treturn 2;\n\t}\n}\n","import {\n    utcMinute,\n    utcHour,\n    utcDay,\n    utcMonth,\n    utcYear\n} from 'd3-time';\nimport Aggregations from '../domain/aggregation';\nimport { dateTimeParse, dateTimeUrlParse, timestampParse } from '../format/date';\n\n/**\n * An object that defines levels of date range configuration.\n *  \n * @typedef {Object} module:util~DateRangeConfiguration\n * @property {number} [numHours] the number of hours to use\n * @property {number} [numDays] the number of days to use\n * @property {number} [numMonths] the number of months to use\n * @property {number} [numYears] the number of years to use\n */\n\n/**\n * An object that defines a date range.\n *  \n * @typedef {Object} module:util~DateRange\n * @property {Date} start the starting date\n * @property {Date} end the ending date\n * @property {module:domain~Aggregation} timeUnit the time unit used by the date range\n * @property {number} timeCount the number of time units in the date range\n * @property {module:domain~Aggregation} aggregate the aggregate to query with\n */\n\n/**\n * Get a query range appropriate for a given aggregate level.\n * \n * Returns an object with `start` and `end` Date properties, using the given `endDate`\n * parameter as the basis for calculating the start as an offset backwards in time\n * based on the given `aggregate` level.\n * \n * When `aggregateTimeCount` will be treated as a \"next higher\" aggregate level from\n * `aggregate`, like this:\n * \n *  * < `Hour`: `numHours`\n *  * `Hour` : `numDays`\n *  * `Day` : `numMonths`\n *  * `Month` : `numYears`\n * \n * For example, you might like to render a chart using `TenMinute` aggregate data for the \n * last 24 hours. You'd call this function like this:\n * \n * ```\n * const range = rollingQueryDateRange(Aggregates.TenMinute, 24);\n * \n * // or, passing a DateRangeConfiguration\n * const range = rollingQueryDateRange(Aggregates.TenMinute, {numHours:24});\n * ```\n * \n * @param {module:domain~Aggregation} aggregate the aggregate level to get a query range for\n * @param {number|module:util~DateRangeConfiguration} aggregateTimeCount the number of aggregate time units to use\n * @param {Date} [endDate] the ending date; if not provided the current date will be used\n * @returns {module:util~DateRange} the calculated date range\n * @alias module:util~rollingQueryDateRange\n */\nexport function rollingQueryDateRange(aggregate, aggregateTimeCount, endDate) {\n    endDate = endDate || new Date();\n\t\n\tfunction exclusiveEndDate(interval, date) {\n\t\tvar result = interval.ceil(date);\n\t\tif ( result.getTime() === date.getTime() ) {\n\t\t\t// already on exact aggregate, so round up to next\n\t\t\tresult = interval.offset(result, 1);\n\t\t}\n\t\treturn result;\n\t}\n\t\n\tfunction timeCountValue(propName) {\n\t\tvar result;\n\t\tif ( isNaN(Number(aggregateTimeCount)) ) {\n\t\t\tif ( aggregateTimeCount[propName] !== undefined ) {\n\t\t\t\tresult = Number(aggregateTimeCount[propName]);\n\t\t\t} else {\n\t\t\t\tresult = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tresult = aggregateTimeCount;\n\t\t}\n\t\tif ( typeof result !== 'number' ) {\n\t\t\tresult = 1;\n\t\t}\n\t\treturn result;\n\t}\n\n    var end,\n        start,\n        timeUnit,\n        timeCount;\n\n\tif ( aggregate.compareTo(Aggregations.Hour) < 0 ) {\n\t\ttimeCount = timeCountValue('numHours');\n\t\ttimeUnit = Aggregations.Hour;\n\t\tend = exclusiveEndDate(utcMinute, endDate);\n\t\tlet precision = Math.min(30, aggregate.level / 60);\n\t\tend.setUTCMinutes((end.getUTCMinutes() + precision - (end.getUTCMinutes() % precision)), 0, 0);\n\t\tstart = utcHour.offset(end, -timeCount);\n\t} else if ( Aggregations.Month.equals(aggregate) ) {\n\t\ttimeCount = timeCountValue('numYears');\n\t\ttimeUnit = Aggregations.Year;\n\t\tend = exclusiveEndDate(utcMonth, endDate);\n\t\tstart = utcYear.offset(utcMonth.floor(endDate), -timeCount);\n\t} else if ( Aggregations.Day.equals(aggregate) ) {\n\t\ttimeCount = timeCountValue('numMonths');\n\t\ttimeUnit = Aggregations.Month;\n\t\tend = exclusiveEndDate(utcDay, endDate);\n\t\tstart = utcMonth.offset(utcDay.floor(endDate), -timeCount);\n\t} else {\n\t\t// assume Hour\n\t\ttimeCount = timeCountValue('numDays');\n\t\ttimeUnit = Aggregations.Day;\n\t\tend = exclusiveEndDate(utcHour, endDate);\n\t\tstart = utcDay.offset(utcHour.floor(end), -timeCount);\n\t}\n\treturn {\n\t\tstart : start, \n\t\tend : end, \n\t\ttimeUnit : timeUnit, \n        timeCount : timeCount,\n        aggregate : aggregate\n\t};\n}\n\n/**\n * Get a date associated with a \"datum\" style object.\n * \n * This function will return a `Date` instance found via a property on `d` according to these rules:\n * \n *  1. `date` - assumed to be a `Date` object already and returned directly\n *  2. `localDate` - a string in `yyyy-MM-dd` form, optionally with a string\n *     `localTime` property for an associated time in `HH:mm` form, treated as UTC\n *  3. `created` - a string in `yyyy-MM-dd HH:mm:ss.SSS'Z'` or `yyyy-MM-dd'T'HH:mm:ss.SSS'Z'` form\n * \n * These properties are commonly returned in results from the SolarNetwork API, and thus\n * this method is a handy way to get the dates for those objects.\n * \n * **Note** that the `localDate` and `localTime` values are parsed as UTC. When formatted the\n * date for display they should be formatted in UTC as well to preserve the expected value.\n * \n * @param {Object} d the datum object to extract a date from\n * @returns {Date} the extracted date, or `null` if no date could be extracted\n * @alias module:util~datumDate\n */\nexport function datumDate(d) {\n\tif ( !d ) {\n        return null;\n    }\n    if ( d.date ) {\n        return d.date;\n    } else if ( d.localDate ) {\n        return dateTimeParse(d.localDate +(d.localTime ? ' ' +d.localTime : ' 00:00'));\n    } else if ( d.created ) {\n        return timestampParse(d.created) || dateTimeUrlParse(d.created);\n    }\n}\n\nexport default Object.freeze({\n    datumDate : datumDate,\n    rollingQueryDateRange : rollingQueryDateRange,\n});\n\n","import { ascending, max, sum } from 'd3-array';\nimport { nest } from 'd3-collection';\n\nimport { datumDate } from '../util/date'\n\n/**\n * A callback function that operates on a nested data layer datum object.\n * \n * @callback module:data~NestedDataOperatorFunction\n * @param {object} datum the datum object being operated on\n * @param {string} key the layer key the datum object is a member of\n * @param {object} [prevDatum] the previous datum object in the layer, if available\n * @returns {void}\n */\n\n/**\n * Normalize the data arrays resulting from a `d3.nest` operation so that all group \n * value arrays have the same number of elements, based on a Date property named \n * `date`.\n * \n * The data values are assumed to be sorted by `date` already, and are modified in-place.\n * This makes the data suitable to passing to `d3.stack`, which expects all stack data\n * arrays to have the same number of values, for the same keys. When querying for data\n * in SolarNetwork there might be gaps in the results, so this function can be used to\n * \"fill in\" those gaps with \"dummy\" values so that there are no more gaps.\n * \n * Filled-in data objects are automatically populated with an appropriate `date` property\n * and a `sourceId` property taken from the `key` of the layer the gap if found in. You\n * can pass a `fillTemplate` object with static properties to also include on all filled-in\n * data objects. You can also pass a `fillFn` function to populate the filled-in objects\n * with dynamic data. \n *\n * For example, given:\n * \n * ```\n * const layerData = [\n *   { key : 'A', values : [{date : new Date('2011-12-02 12:00')}, {date : new Date('2011-12-02 12:10')}] },\n *   { key : 'B', values : [{date : new Date('2011-12-02 12:00')}] }\n * ];\n * \n * normalizeNestedStackDataByDate(layerData);\n * ```\n * \n * The `layerData` would be modified in-place and look like this (notice the filled in second data value in the **B** group):\n * \n * ```\n * [\n *   { key : 'A', values : [{date : new Date('2011-12-02 12:00')}, {date : new Date('2011-12-02 12:10')}] },\n *   { key : 'B', values : [{date : new Date('2011-12-02 12:00')}, {date : new Date('2011-12-02 12:10'), sourceId : 'B'}] }\n * ]\n * ```\n * \n * @param {object[]} layerData - An array of objects with `key` and `values` properties, as returned from `d3.nest().entries()`\n * @param {string} layerData.key - The layer's key value.\n * @param {object[]} layerData.values - The layer's value array.\n * @param {object} [fillTemplate] - An object to use as a template for any filled-in data objects.\n *                                  The `date` property will be populated automatically, and a `sourceId`\n *                                  property will be populated by the layer's `key`.\n * @param {module:data~NestedDataOperatorFunction} [fillFn] - An optional function to populate filled-in data objects with.\n *                                                            This function is invoked **after** populating any `fillTemplate` values.\n * @returns {void}\n * @alias module:data~normalizeNestedStackDataByDate\n */\nexport function normalizeNestedStackDataByDate(layerData, fillTemplate, fillFn) {\n\tvar i = 0,\n\t\tj,\n\t\tk,\n\t\tjMax = layerData.length - 1,\n\t\tdummy,\n\t\tprop,\n\t\tcopyIndex;\n\t// fill in \"holes\" for each stack, if more than one stack. we assume data already sorted by date\n\tif ( jMax > 0 ) {\n\t\twhile ( i < max(layerData.map(function(e) { return e.values.length; })) ) {\n\t\t\tdummy = undefined;\n\t\t\tfor ( j = 0; j <= jMax; j++ ) {\n\t\t\t\tif ( layerData[j].values.length <= i ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tif ( j < jMax ) {\n\t\t\t\t\tk = j + 1;\n\t\t\t\t} else {\n\t\t\t\t\tk = 0;\n\t\t\t\t}\n\t\t\t\tif ( layerData[k].values.length <= i || layerData[j].values[i].date.getTime() < layerData[k].values[i].date.getTime() ) {\n\t\t\t\t\tdummy = {date : layerData[j].values[i].date, sourceId : layerData[k].key};\n\t\t\t\t\tif ( fillTemplate ) {\n\t\t\t\t\t\tfor ( prop in fillTemplate ) {\n\t\t\t\t\t\t\tif ( fillTemplate.hasOwnProperty(prop) ) {\n\t\t\t\t\t\t\t\tdummy[prop] = fillTemplate[prop];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( fillFn ) {\n\t\t\t\t\t\tcopyIndex = (layerData[k].values.length > i ? i : i > 0 ? i - 1 : null);\n\t\t\t\t\t\tfillFn(dummy, layerData[k].key, (copyIndex !== null ? layerData[k].values[copyIndex] : undefined));\n\t\t\t\t\t}\n\t\t\t\t\tlayerData[k].values.splice(i, 0, dummy);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ( dummy === undefined ) {\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Combine the layers resulting from a `d3.nest` operation into a single, aggregated\n * layer.\n * \n * This can be used to combine all sources of a single data type, for example\n * to show all \"power\" sources as a single layer of chart data. The resulting object\n * has the same structure as the input `layerData` parameter, with just a\n * single layer of data.\n * \n * For example:\n * \n * ```\n * const layerData = [\n *   { key : 'A', values : [{watts : 123, foo : 1}, {watts : 234, foo : 2}] },\n *   { key : 'B', values : [{watts : 345, foo : 3}, {watts : 456, foo : 4}] }\n * ];\n * \n * const result = aggregateNestedDataLayers(layerData, \n *     'A and B', ['foo'], ['watts'], {'combined' : true});\n * ```\n * \n * Then `result` would look like this:\n * \n * ```\n * [\n *   { key : 'A and B', values : [{watts : 468, foo : 1, combined : true}, \n *                                {watts : 690, foo : 2, combined : true}] }\n * ]\n * ```\n * \n * @param {object[]} layerData - An array of objects with `key` and `values` properties, as returned from `d3.nest().entries()`\n * @param {string} layerData.key - The layer's key value.\n * @param {object[]} layerData.values - The layer's value array.\n * @param {string} resultKey - The `key` property to assign to the returned layer.\n * @param {string[]} copyProperties - An array of string property names to copy as-is from the **first** layer's data values.\n * @param {string[]} sumProperties - An array of string property names to add together from **all** layer data.\n * @param {object} staticProperties - Static properties to copy as-is to **all** output data values.\n * @return {object[]} An array of objects with `key` and `value` properties, the same structure as the provided `layerData` argument\n * @alias module:data~aggregateNestedDataLayers\n */\nexport function aggregateNestedDataLayers(layerData, resultKey, copyProperties, sumProperties, staticProperties) {\n\t// combine all layers into a single source\n\tvar layerCount = layerData.length,\n\t\tdataLength,\n\t\ti,\n\t\tj,\n\t\tk,\n\t\tcopyPropLength = (copyProperties ? copyProperties.length : 0),\n\t\tsumPropLength = (sumProperties ? sumProperties.length : 0),\n\t\td,\n\t\tval,\n\t\tclone,\n\t\tarray;\n\n\tdataLength = layerData[0].values.length;\n\tif ( dataLength > 0 ) {\n\t\tarray = [];\n\t\tfor ( i = 0; i < dataLength; i += 1 ) {\n\t\t\td = layerData[0].values[i];\n\t\t\tclone = {};\n\t\t\tif ( staticProperties !== undefined ) {\n\t\t\t\tfor ( val in staticProperties ) {\n\t\t\t\t\tif ( staticProperties.hasOwnProperty(val) ) {\n\t\t\t\t\t\tclone[val] = staticProperties[val];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tfor ( k = 0; k < copyPropLength; k += 1 ) {\n\t\t\t\tclone[copyProperties[k]] = d[copyProperties[k]];\n\t\t\t}\n\t\t\tfor ( k = 0; k < sumPropLength; k += 1 ) {\n\t\t\t\tclone[sumProperties[k]] = 0;\n\t\t\t}\n\t\t\tfor ( j = 0; j < layerCount; j += 1 ) {\n\t\t\t\tfor ( k = 0; k < sumPropLength; k += 1 ) {\n\t\t\t\t\tval = layerData[j].values[i][sumProperties[k]];\n\t\t\t\t\tif ( val !== undefined ) {\n\t\t\t\t\t\tclone[sumProperties[k]] += val;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tarray.push(clone);\n\t\t}\n\t\tlayerData = [{ key : resultKey, values : array }];\n\t}\n\n\treturn layerData;\n}\n\n/**\n * Transform raw SolarNetwork timeseries data by combining datum from multiple sources into a single\n * data per time key.\n * \n * This method produces a single array of objects with metric properties derived by grouping \n * that property within a single time slot across one or more source IDs. Conceptually this is\n * similar to {@link module:data~aggregateNestedDataLayers} except groups of source IDs can be\n * produced in the final result.\n * \n * The data will be passed through {@link module:data~normalizeNestedStackDataByDate} so that every\n * result object will contain every configured output group, but missing data will result in a\n * `null` value.\n * \n * Here's an example where two sources `A` and `B` are combined into a single group `Generation`\n * and a third source `C` is passed through as another group `Consumption`:\n * \n * ```\n * const queryData = [\n *     {localDate: '2018-05-05', localTime: '11:00', sourceId: 'A', watts : 123}, \n *     {localDate: '2018-05-05', localTime: '11:00', sourceId: 'B', watts : 234},\n *     {localDate: '2018-05-05', localTime: '11:00', sourceId: 'C', watts : 345},\n *     {localDate: '2018-05-05', localTime: '12:00', sourceId: 'A', watts : 456}, \n *     {localDate: '2018-05-05', localTime: '12:00', sourceId: 'B', watts : 567},\n *     {localDate: '2018-05-05', localTime: '12:00', sourceId: 'C', watts : 678},\n * ];\n * const sourceMap = new Map([\n *     ['A', 'Generation'],\n *     ['B', 'Generation'],\n *     ['C', 'Consumption'],\n * ]);\n * \n * const result = groupedBySourceMetricDataArray(queryData, 'watts', sourceMap);\n * ```\n * \n * Then `result` would look like this:\n * \n * ```\n * [\n *     {date : new Date('2018-05-05T11:00Z'), Generation : 357, Consumption: 345},\n *     {date : new Date('2018-05-05T12:00Z'), Generation : 1023, Consumption: 678}\n * ]\n * ```\n * \n * @param {object[]} data the raw data returned from SolarNetwork\n * @param {string} metricName the datum property name to extract\n * @param {Map} [sourceIdMap] an optional mapping of input source IDs to output source IDs; this can be used\n *                            to control the grouping of data, by mapping multiple input source IDs to the same\n *                            output source ID\n * @param {function} [aggFn] an optional aggregate function to apply to the metric values;\n *                           defaults to `d3.sum`; **note** that the function will be passed an array of input\n *                           data objects, not metric values\n * @returns {object[]} array of datum objects, each with a date and one metric value per source ID\n * @alias module:data~groupedBySourceMetricDataArray\n */\nexport function groupedBySourceMetricDataArray(data, metricName, sourceIdMap, aggFn) {\n\tconst metricExtractorFn = function metricExtractor(d) {\n\t\treturn d[metricName];\n\t};\n\tconst rollupFn = (typeof aggFn === 'function' ? aggFn : sum);\n\tconst layerData = nest()\n\t\t// group first by source\n\t\t.key((d) => {\n\t\t\treturn sourceIdMap && sourceIdMap.has(d.sourceId)\n\t\t\t\t? sourceIdMap.get(d.sourceId)\n\t\t\t\t: d.sourceId;\n\t\t})\n\t\t.sortKeys(ascending)\n\t\t// group second by date\n\t\t.key((d) => {\n\t\t\treturn d.localDate + ' ' +d.localTime;\n\t\t})\n\t\t// sum desired property in date group\n\t\t.rollup((values) => {\n\t\t\tconst r = {\n\t\t\t\tdate: datumDate(values[0])\n\t\t\t};\n\t\t\tlet metricKey = values[0].sourceId;\n\t\t\tif ( sourceIdMap && sourceIdMap.has(metricKey) ) {\n\t\t\t\tmetricKey = sourceIdMap.get(metricKey);\n\t\t\t}\n\t\t\tr[metricKey] = rollupFn(values, metricExtractorFn);\n\t\t\treturn r;\n\t\t})\n\t\t// un-nest to single group by source\n\t\t.entries(data).map(function(layer) {\n\t\t\treturn {\n\t\t\t\tkey: layer.key, \n\t\t\t\tvalues: layer.values.map(function(d) {\n\t\t\t\t\treturn d.value;\n\t\t\t\t})\n\t\t\t};\n\t\t});\n\t\n\t// ensure all layers have the same time keys\n\tnormalizeNestedStackDataByDate(layerData, null, (d, key) => {\n\t\t// make sure filled-in data has the metric property defined\n\t\td[key] = null;\n\t});\n\n\t// reduce to single array with multiple metric properties\n\treturn layerData.reduce(function(combined, layer) {\n\t\tif ( !combined ) {\n\t\t\treturn layer.values;\n\t\t}\n\t\tcombined.forEach(function(d, i) {\n\t\t\tconst v = layer.values[i][layer.key];\n\t\t\td[layer.key] = v;\n\t\t});\n\t\treturn combined;\n\t}, null);\n}\n\nexport default Object.freeze({\n\taggregateNestedDataLayers : aggregateNestedDataLayers,\n\tgroupedBySourceMetricDataArray : groupedBySourceMetricDataArray,\n    normalizeNestedStackDataByDate : normalizeNestedStackDataByDate,\n});\n","import { Aggregation } from './aggregation';\nimport { CombiningType } from './combiningType';\nimport Location from './location';\nimport PropMap from '../util/propMap';\n\nimport { dateTimeUrlFormat } from '../format/date'\n\nconst AggregationKey = 'aggregation';\nconst CombiningTypeKey = 'combiningType';\nconst DataPathKey = 'dataPath';\nconst EndDateKey = 'endDate';\nconst LocationIdsKey = 'locationIds';\nconst LocationKey = 'location';\nconst MetadataFilterKey = 'metadataFilter';\nconst MostRecentKey = 'mostRecent';\nconst NodeIdMapsKey = 'nodeIdMaps';\nconst NodeIdsKey = 'nodeIds';\nconst QueryKey = 'query';\nconst SourceIdMapsKey = 'sourceIdMaps';\nconst SourceIdsKey = 'sourceIds';\nconst StartDateKey =  'startDate';\nconst TagsKey = 'tags';\nconst UserIdsKey = 'userIds';\nconst WithoutTotalResultsCountKey = 'withoutTotalResultsCount';\n\n/**\n * Combine an ID map into a query parameter.\n * @param {Map<*, Set<*>>} map ID mapping\n * @returns {String[]} the query parameter value, or `null` if no mapping available\n * @private\n */\nfunction idMapQueryParameterValue(map) {\n    if ( !(map instanceof Map && map.size > 0) ) {\n        return null;\n    }\n    var result = [];\n    for ( let e of map ) {\n        if ( !(e[1] instanceof Set) ) {\n            continue;\n        }\n        result.push(`${e[0]}:${Array.from(e[1]).join(',')}`);\n    }\n    return result;\n}\n\n/**\n * A filter criteria object for datum.\n * \n * <p>This filter is used to query both node datum and location datum. Not all properties are\n * applicable to both types. Be sure to consult the SolarNet API documentation on the \n * supported properties for each type.</p>\n * \n * @extends module:util~PropMap\n * @alias module:domain~DatumFilter\n */\nclass DatumFilter extends PropMap {\n\n    /**\n     * Constructor.\n     * @param {object} [props] initial property values \n     */\n    constructor(props) {\n        super(props);\n    }\n\n    /**\n     * A node ID.\n     * \n     * This manages the first available node ID from the `nodeIds` property.\n     * \n     * @type {number}\n     */\n    get nodeId() {\n        const nodeIds = this.nodeIds;\n        return (Array.isArray(nodeIds) && nodeIds.length > 0 ? nodeIds[0] : null);\n    }\n\n    set nodeId(nodeId) {\n        if ( nodeId ) {\n            this.nodeIds = [nodeId];\n        } else {\n            this.nodeIds = null;\n        }\n    }\n\n    /**\n     * An array of node IDs.\n     * @type {number[]}\n     */\n    get nodeIds() {\n        return this.prop(NodeIdsKey);\n    }\n\n    set nodeIds(nodeIds) {\n        this.prop(NodeIdsKey, Array.isArray(nodeIds) ? nodeIds : null);\n    }\n\n    /**\n     * A location ID.\n     * \n     * This manages the first available location ID from the `locationIds` property.\n     * \n     * @type {number}\n     */\n    get locationId() {\n        const locationIds = this.locationIds;\n        return (Array.isArray(locationIds) && locationIds.length > 0 ? locationIds[0] : null);\n    }\n\n    set locationId(locationId) {\n        if ( locationId ) {\n            this.locationIds = [locationId];\n        } else {\n            this.locationIds = null;\n        }\n    }\n\n    /**\n     * An array of location IDs.\n     * @type {number[]}\n     */\n    get locationIds() {\n        return this.prop(LocationIdsKey);\n    }\n\n    set locationIds(locationIds) {\n        this.prop(LocationIdsKey, Array.isArray(locationIds) ? locationIds : null);\n    }\n\n    /**\n     * A source ID.\n     * \n     * This manages the first available source ID from the `sourceIds` property.\n     * \n     * @type {string}\n     */\n    get sourceId() {\n        const sourceIds = this.sourceIds;\n        return (Array.isArray(sourceIds) && sourceIds.length > 0 ? sourceIds[0] : null);\n    }\n\n    set sourceId(sourceId) {\n        if ( sourceId ) {\n            this.sourceIds = [sourceId];\n        } else {\n            this.sourceIds = null;\n        }\n    }\n\n    /**\n     * An array of source IDs.\n     * @type {string[]}\n     */\n    get sourceIds() {\n        return this.prop(SourceIdsKey);\n    }\n\n    set sourceIds(sourceIds) {\n        this.prop(SourceIdsKey, Array.isArray(sourceIds) ? sourceIds : null);\n    }\n\n    /**\n     * A user ID.\n     * \n     * This manages the first available location ID from the `userIds` property.\n     * \n     * @type {number}\n     */\n    get userId() {\n        const userIds = this.userIds;\n        return (Array.isArray(userIds) && userIds.length > 0 ? userIds[0] : null);\n    }\n\n    set userId(userId) {\n        if ( userId ) {\n            this.userIds = [userId];\n        } else {\n            this.userIds = null;\n        }\n    }\n\n    /**\n     * An array of user IDs.\n     * @type {number[]}\n     */\n    get userIds() {\n        return this.prop(UserIdsKey);\n    }\n\n    set userIds(userIds) {\n        this.prop(UserIdsKey, Array.isArray(userIds) ? userIds : null);\n    }\n\n    /**\n     * The \"most recent\" flag.\n     * @type {boolean}\n     */\n    get mostRecent() {\n        return !!this.prop(MostRecentKey);\n    }\n\n    set mostRecent(value) {\n        this.prop(MostRecentKey, !!value);\n    }\n\n    /**\n     * A minimumin date.\n     * @type {Date}\n     */\n    get startDate() {\n        return this.prop(StartDateKey);\n    }\n\n    set startDate(date) {\n        this.prop(StartDateKey, date);\n    }\n\n    /**\n     * A maximum date.\n     * @type {Date}\n     */\n    get endDate() {\n        return this.prop(EndDateKey);\n    }\n\n    set endDate(date) {\n        this.prop(EndDateKey, date);\n    }\n\n    /**\n     * A data path, in dot-delimited notation like `i.watts`.\n     * @type {string}\n     */\n    get dataPath() {\n        return this.prop(DataPathKey);\n    }\n\n    set dataPath(path) {\n        this.prop(DataPathKey, path);\n    }\n\n    /**\n     * An aggregation.\n     * \n     * Including this in a filter will cause SolarNet to return aggregated results, rather\n     * than raw results.\n     * \n     * @type {module:domain~Aggregation}\n     */\n    get aggregation() {\n        return this.prop(AggregationKey);\n    }\n\n    set aggregation(agg) {\n        this.prop(AggregationKey, agg instanceof Aggregation ? agg : null);\n    }\n\n    /**\n     * An array of tags.\n     * @type {string[]}\n     */\n    get tags() {\n        return this.prop(TagsKey);\n    }\n\n    set tags(val) {\n        this.prop(TagsKey, Array.isArray(val) ? val : null);\n    }\n\n    /**\n     * A location, used as an example-based search criteria.\n     * @type {module:domain~Location}\n     */\n    get location() {\n        return this.prop(LocationKey);\n    }\n\n    set location(val) {\n        this.prop(LocationKey, val instanceof Location ? val : null);\n    }\n\n    /**\n     * A general full-text style query string.\n     * @type {string}\n     */\n    get query() {\n        return this.prop(QueryKey);\n    }\n\n    set query(val) {\n        this.prop(QueryKey, val);\n    }\n\n    /**\n     * A metadata filter (LDAP style search criteria).\n     * @type {string}\n     */\n    get metadataFilter() {\n        return this.prop(MetadataFilterKey);\n    }\n\n    set metadataFilter(val) {\n        this.prop(MetadataFilterKey, val);\n    }\n\n    /**\n     * Get the _without total results_ flag.\n     * @type {boolean}\n     */\n    get withoutTotalResultsCount() {\n        return this.prop(WithoutTotalResultsCountKey);\n    }\n\n    set withoutTotalResultsCount(val) {\n        this.prop(WithoutTotalResultsCountKey, !!val);\n    }\n\n    /**\n     * Get the combining type.\n     * \n     * Use this to combine nodes and/or sources into virtual groups. Requires some combination\n     * of {@link #nodeIdMaps} or {@link #sourceIdMaps} also be specified.\n     * \n     * @type {module:domain~CombiningType}\n     */\n    get combiningType() {\n        return this.prop(CombiningTypeKey);\n    }\n\n    set combiningType(t) {\n        this.prop(CombiningTypeKey, t instanceof CombiningType ? t : null);\n    }\n\n    /**\n     * A mapping of virtual node IDs to sets of real node IDs to combine.\n     * \n     * @type {Map<Number, Set<Number>>}\n     */\n    get nodeIdMaps() {\n        return this.prop(NodeIdMapsKey);\n    }\n\n    set nodeIdMaps(map) {\n        this.prop(NodeIdMapsKey, map instanceof Map ? map : null);\n    }\n\n    /**\n     * A mapping of virtual source IDs to sets of real source IDs to combine.\n     * \n     * @type {Map<String, Set<String>>}\n     */\n    get sourceIdMaps() {\n        return this.prop(SourceIdMapsKey);\n    }\n\n    set sourceIdMaps(map) {\n        this.prop(SourceIdMapsKey, map instanceof Map ? map : null);\n    }\n\n    /**\n     * Get this object as a standard URI encoded (query parameters) string value.\n     * \n     * @override\n     * @inheritdoc\n     */\n    toUriEncoding(propertyName, callbackFn) {\n        return super.toUriEncoding(propertyName, callbackFn || datumFilterUriEncodingPropertyMapper);\n    }\n\n}\n\n/**\n * Map DatumFilter properties for URI encoding.\n * \n * @param {string} key the property key\n * @param {*} value the property value\n * @returns {*} 2 or 3-element array for mapped key+value+forced-multi-key, `null` to skip, or `key` to keep as-is\n * @private\n */\nfunction datumFilterUriEncodingPropertyMapper(key, value) {\n    if ( key === NodeIdsKey || key === LocationIdsKey || key === SourceIdsKey || key === UserIdsKey ) {\n        // check for singleton array value, and re-map to singular property by chopping of \"s\"\n        if  ( Array.isArray(value) && value.length === 1 ) {\n            return [key.substring(0, key.length - 1), value[0]];\n        }\n    } else if ( key === StartDateKey || key === EndDateKey ) {\n        return [key, dateTimeUrlFormat(value)];\n    } else if ( key === MostRecentKey && !value ) {\n        return null;\n    } else if ( key === NodeIdMapsKey || key === SourceIdMapsKey ) {\n        let p = idMapQueryParameterValue(value);\n        return (p ? [key, p, true] : null);\n    }\n    return key;\n}\n\nexport default DatumFilter;\n","/**\n * General metadata with a basic structure.\n * \n * This metadata can be associated with a variety of objects within SolarNetwork, such\n * as users, nodes, and datum.\n * \n * @alias module:domain~GeneralMetadata\n */\nclass GeneralMetadata {\n\n    /**\n     * Constructor.\n     * \n     * @param {Map<string, *>} [info] the general metadata map\n     * @param {Map<string, Map<string, *>>} [propertyInfo] the property metadata map\n     * @param {Set<string>} [tags] the tags\n     */\n    constructor(info, propertyInfo, tags) {\n        this.info = info || null;\n        this.propertyInfo = propertyInfo || null;\n        this.tags = (tags instanceof Set ? tags : Array.isArray(tags) ? new Set(tags) : null);\n    }\n\n    /**\n     * Get this object as a standard JSON encoded string value.\n     * \n     * @return {string} the JSON encoded string\n     */\n    toJsonEncoding() {\n        const result = {};\n        const info = this.info;\n        if ( info ) {\n            result['m'] = stringMapToObject(info);\n        }\n        const propertyInfo = this.propertyInfo;\n        if ( propertyInfo ) {\n            result['pm'] = stringMapToObject(propertyInfo);\n        }\n        const tags = this.tags;\n        if ( tags ) {\n            result['t'] = Array.from(tags);\n        }\n\n\t\treturn JSON.stringify(result);\n    }\n\n    /**\n     * Parse a JSON string into a {@link module:domain~GeneralMetadata} instance.\n     * \n     * The JSON must be encoded the same way {@link module:domain~GeneralMetadata#toJsonEncoding} does.\n     * \n     * @param {string} json the JSON to parse\n     * @returns {module:domain~GeneralMetadata} the metadata instance \n     */\n    static fromJsonEncoding(json) {\n        let m, pm, t;\n        if ( json ) {\n            const obj = JSON.parse(json);\n            m = (obj['m'] ? objectToStringMap(obj['m']) : null);\n            pm = (obj['pm'] ? objectToStringMap(obj['pm']) : null);\n            t = (Array.isArray(obj['t']) ? new Set(obj['t']) : null);\n        }\n        return new GeneralMetadata(m, pm, t);\n    }\n}\n\n/**\n * Convert a `Map` into a simple object.\n * \n * The keys are assumed to be strings. Values that are themselves `Map` instances\n * will be converted to simple objects as well.\n * \n * @param {Map<string, *>} strMap a Map with string keys; nested Map objects are also handled\n * @returns {object} a simple object\n * @see {@link objectToStringMap} for the reverse conversion\n * @alias module:domain~stringMapToObject\n */\nfunction stringMapToObject(strMap) {\n    const obj = Object.create(null);\n    if ( strMap ) {\n        for (const [k,v] of strMap) {\n            obj[k] = (v instanceof Map ? stringMapToObject(v) : v);\n        }\n    }\n    return obj;\n}\n\n/**\n * Convert a simple object into a `Map` instance.\n * \n * Property values that are themselves objects will be converted into `Map`\n * instances as well.\n * \n * @param {object} obj a simple object\n * @returns {Map<string, *>} a Map with string keys; nested Map objects are also handled\n * @see {@link module:domain~stringMapToObject} for the reverse conversion\n * @alias module:domain~objectToStringMap\n */\nfunction objectToStringMap(obj) {\n    const strMap = new Map();\n    if ( obj ) {\n        for (const k of Object.keys(obj)) {\n            const v = obj[k];\n            strMap.set(k, (typeof v === 'object' ? objectToStringMap(v) : v));\n        }\n    }\n    return strMap;\n}\n\nexport default GeneralMetadata;\nexport { stringMapToObject, objectToStringMap };\n","import { Aggregation } from './aggregation';\nimport { LocationPrecision } from './locationPrecision';\n\n/**\n * Get a Set from a Set or array or object, returning `null` if the set would be empty.\n * \n * @param {Object[]|Set<*>} obj the array, Set, or singleton object to get as a Set\n * @returns {Set<*>} the Set, or `null`\n * @private\n */\nfunction setOrNull(obj) {\n\tlet result = null;\n\tif ( obj instanceof Set ) {\n\t\tresult = (obj.size > 0 ? obj : null);\n\t} else if ( Array.isArray(obj) ) {\n\t\tresult = (obj.length > 0 ? new Set(obj) : null);\n\t} else if ( obj ) {\n\t\tresult = new Set([obj]);\n\t}\n\treturn result;\n}\n\n/**\n * Merge two sets.\n * \n * @param {Object[]|Set<*>} [set1] the first set \n * @param {Object[]|Set<*>} [set2] the second set \n * @returns {Set<*>} the merged Set, or `null` if neither arguments are sets or \n *                   neither argument have any values\n * @private\n */\nfunction mergedSets(set1, set2) {\n\tlet s1 = setOrNull(set1);\n\tlet s2 = setOrNull(set2);\n\tif ( s1 === null && s2 === null ) {\n\t\treturn null;\n\t} else if ( s2 === null ) {\n\t\treturn s1;\n\t} else if ( s1 === null ) {\n\t\treturn s2;\n\t} else {\n\t\tfor ( let v of s2.values() ) {\n\t\t\ts1.add(v);\n\t\t}\n\t\treturn s1;\n\t}\n}\n\n\n/**\n * An immutable set of security restrictions that can be attached to other objects, like auth tokens.\n * \n * Use the {@link module:domain~SecurityPolicyBuilder} to create instances of this class with a fluent API.\n * @alias module:domain~SecurityPolicy\n */\nclass SecurityPolicy {\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param {number[]|Set<number>} [nodeIds] the node IDs to restrict to, or `null` for no restriction\n\t * @param {string[]|Set<string>} [sourceIds] the source ID to restrict to, or `null` for no restriction\n\t * @param {module:domain~Aggregation[]|Set<module:domain~Aggregation>} [aggregations] the aggregation names to restrict to, or `null` for no restriction\n\t * @param {module:domain~Aggregation} [minAggregation] if specified, a minimum aggregation level that is allowed\n\t * @param {Set<module:domain~LocationPrecision>} [locationPrecisions] the location precision names to restrict to, or `null` for no restriction\n\t * @param {module:domain~LocationPrecision} [minLocationPrecision] if specified, a minimum location precision that is allowed\n\t * @param {Set<string>} [nodeMetadataPaths] the `SolarNodeMetadata` paths to restrict to, or `null` for no restriction\n\t * @param {Set<string>} [userMetadataPaths] the `UserNodeMetadata` paths to restrict to, or `null` for no restriction\n\t */\n    constructor(nodeIds, sourceIds, aggregations, minAggregation, locationPrecisions,\n\t\t\tminLocationPrecision, nodeMetadataPaths, userMetadataPaths) {\n\t\tthis._nodeIds = setOrNull(nodeIds);\n\t\tthis._sourceIds = setOrNull(sourceIds);\n\t\tthis._aggregations = setOrNull(aggregations);\n\t\tthis._minAggregation = (minAggregation instanceof Aggregation ? minAggregation : null);\n\t\tthis._locationPrecisions = setOrNull(locationPrecisions);\n\t\tthis._minLocationPrecision = (minLocationPrecision instanceof LocationPrecision ? minLocationPrecision : null);\n\t\tthis._nodeMetadataPaths = setOrNull(nodeMetadataPaths);\n        this._userMetadataPaths = setOrNull(userMetadataPaths);\n        if ( this.constructor === SecurityPolicy ) {\n            Object.freeze(this);\n        }\n\t}\n\n\t/**\n\t * Get the node IDs.\n\t * \n\t * @returns {Set<number>} the node IDs, or `null`\n\t */\n\tget nodeIds() {\n\t\treturn this._nodeIds;\n\t}\n\n\t/**\n\t * Get the source IDs.\n\t * \n\t * @returns {Set<string>} the source IDs, or `null`\n\t */\n\tget sourceIds() {\n\t\treturn this._sourceIds;\n\t}\n\n\t/**\n\t * Get the aggregations.\n\t * \n\t * @returns {Set<module:domain~Aggregation>} the aggregations, or `null`\n\t */\n\tget aggregations() {\n\t\treturn this._aggregations;\n\t}\n\n\t/**\n\t * Get the location precisions.\n\t * \n\t * @returns {Set<module:domain~LocationPrecision>} the precisions, or `null`\n\t */\n\tget locationPrecisions() {\n\t\treturn this._locationPrecisions;\n\t}\n\n\t/**\n\t * Get the minimum aggregation.\n\t * \n\t * @returns {module:domain~Aggregation} the minimum aggregation, or `null`\n\t */\n\tget minAggregation() {\n\t\treturn this._minAggregation;\n\t}\n\n\t/**\n\t * Get the minimum location precision.\n\t * \n\t * @returns {module:domain~LocationPrecision} the minimum precision, or `null`\n\t */\n\tget minLocationPrecision() {\n\t\treturn this._minLocationPrecision;\n\t}\n\n\t/**\n\t * Get the node metadata paths.\n\t * \n\t * @returns {Set<string>} the node metadata paths, or `null`\n\t */\n\tget nodeMetadataPaths() {\n\t\treturn this._nodeMetadataPaths;\n\t}\n\n\t/**\n\t * Get the user metadata paths.\n\t * \n\t * @returns {Set<string>} the user metadata paths, or `null`\n\t */\n\tget userMetadataPaths() {\n\t\treturn this._userMetadataPaths;\n\t}\n\n    /**\n     * Get this object as a standard JSON encoded string value.\n     * \n     * @return {string} the JSON encoded string\n     */\n    toJsonEncoding() {\n\t\tlet result = {};\n\t\tlet val = this.nodeIds;\n\t\tif ( val ) {\n\t\t\tresult.nodeIds = Array.from(val);\n\t\t}\n\t\t\n\t\tval = this.sourceIds;\n\t\tif ( val ) {\n\t\t\tresult.sourceIds = Array.from(val);\n\t\t}\n\n\t\tval = this.aggregations;\n\t\tif ( val ) {\n\t\t\tresult.aggregations = Array.from(val).map(e => e.name);\n\t\t}\n\n\t\tval = this.locationPrecisions;\n\t\tif ( val ) {\n\t\t\tresult.locationPrecisions = Array.from(val).map(e => e.name);\n\t\t}\n\n\t\tval = this.minAggregation;\n\t\tif ( val ) {\n\t\t\tif ( result.length > 0 ) {\n\t\t\t\tresult += '&';\n\t\t\t}\n\t\t\tresult.minAggregation = val.name;\n\t\t}\n\n\t\tval = this.minLocationPrecision;\n\t\tif ( val ) {\n\t\t\tresult.minLocationPrecision = val.name;\n\t\t}\n\n\t\tval = this.nodeMetadataPaths;\n\t\tif ( val ) {\n\t\t\tresult.nodeMetadataPaths = Array.from(val);\n\t\t}\n\n\t\tval = this.userMetadataPaths;\n\t\tif ( val ) {\n\t\t\tresult.userMetadataPaths = Array.from(val);\n\t\t}\n\n\t\treturn JSON.stringify(result);\n    }\n}\n\nconst MIN_AGGREGATION_CACHE = new Map(); // Map<string, Set<Aggregation>>\nconst MIN_LOCATION_PRECISION_CACHE = new Map(); // Map<string, Set<LocationPrecision>>\n\n/**\n * A mutable builder object for {@link module:domain~SecurityPolicy} instances.\n * @alias module:domain~SecurityPolicyBuilder\n */\nclass SecurityPolicyBuilder {\n\n\t/**\n\t * Apply all properties from another SecurityPolicy.\n\t * \n\t * @param {module:domain~SecurityPolicy} policy the SecurityPolicy to apply\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithPolicy(policy) {\n\t\tif ( policy ) {\n\t\t\tthis.withAggregations(policy.aggregations)\n\t\t\t\t.withMinAggregation(policy.minAggregation)\n\t\t\t\t.withLocationPrecisions(policy.locationPrecisions)\n\t\t\t\t.withMinLocationPrecision(policy.minLocationPrecision)\n\t\t\t\t.withNodeIds(policy.nodeIds)\n\t\t\t\t.withSourceIds(policy.sourceIds)\n\t\t\t\t.withNodeMetadataPaths(policy.nodeMetadataPaths)\n\t\t\t\t.withUserMetadataPaths(policy.userMetadataPaths);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Merge all properties from another SecurityPolicy.\n\t * \n\t * @param {module:domain~SecurityPolicy} policy the SecurityPolicy to merge\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddPolicy(policy) {\n\t\tif ( policy ) {\n\t\t\tthis.addAggregations(policy.aggregations)\n\t\t\t\t\t.addLocationPrecisions(policy.locationPrecisions)\n\t\t\t\t\t.addNodeIds(policy.nodeIds)\n\t\t\t\t\t.addSourceIds(policy.sourceIds)\n\t\t\t\t\t.addNodeMetadataPaths(policy.nodeMetadataPaths)\n\t\t\t\t\t.addUserMetadataPaths(policy.userMetadataPaths);\n\t\t\tif ( policy.minAggregation ) {\n\t\t\t\tthis.withMinAggregation(policy.minAggregation);\n\t\t\t}\n\t\t\tif ( policy.minLocationPrecision ) {\n\t\t\t\tthis.withMinLocationPrecision(policy.minLocationPrecision);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the node IDs.\n\t * \n\t * @param {number[]|Set<number>} nodeIds the node IDs to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithNodeIds(nodeIds) {\n\t\tthis.nodeIds = setOrNull(nodeIds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a set of node IDs.\n\t * \n\t * @param {number[]|Set<number>} nodeIds the node IDs to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddNodeIds(nodeIds) {\n\t\treturn this.withNodeIds(mergedSets(this.nodeIds, nodeIds));\n\t}\n\n\t/**\n\t * Set the node metadata paths.\n\t * \n\t * @param {string[]|Set<string>} nodeMetadataPaths the path expressions to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithNodeMetadataPaths(nodeMetadataPaths) {\n\t\tthis.nodeMetadataPaths = setOrNull(nodeMetadataPaths);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a set of node metadata paths.\n\t * \n\t * @param {string[]|Set<string>} nodeMetadataPaths the path expressions to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddNodeMetadataPaths(nodeMetadataPaths) {\n\t\treturn this.withNodeMetadataPaths(mergedSets(this.nodeMetadataPaths, nodeMetadataPaths));\n\t}\n\n\t/**\n\t * Set the user metadata paths.\n\t * \n\t * @param {string[]|Set<string>} userMetadataPaths the path expressions to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithUserMetadataPaths(userMetadataPaths) {\n\t\tthis.userMetadataPaths = setOrNull(userMetadataPaths);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a set of user metadata paths.\n\t * \n\t * @param {string[]|Set<string>} userMetadataPaths the path expressions to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddUserMetadataPaths(userMetadataPaths) {\n\t\treturn this.withUserMetadataPaths(mergedSets(this.userMetadataPaths, userMetadataPaths));\n\t}\n\n\t/**\n\t * Set the source IDs.\n\t * \n\t * @param {string[]|Set<string>} sourceIds the source IDs to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithSourceIds(sourceIds) {\n\t\tthis.sourceIds = setOrNull(sourceIds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add source IDs.\n\t * \n\t * @param {string[]|Set<string>} sourceIds the source IDs to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddSourceIds(sourceIds) {\n\t\treturn this.withSourceIds(mergedSets(this.sourceIds, sourceIds));\n\t}\n\n\t/**\n\t * Set the aggregations.\n\t * \n\t * @param {module:domain~Aggregation[]|Set<module:domain~Aggregation>} aggregations the aggregations to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithAggregations(aggregations) {\n\t\tthis.aggregations = setOrNull(aggregations);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the aggregations.\n\t * \n\t * @param {module:domain~Aggregation[]|Set<module:domain~Aggregation>} aggregations the aggregations to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddAggregations(aggregations) {\n\t\treturn this.withAggregations(mergedSets(this.aggregations, aggregations));\n\t}\n\n\t/**\n\t * Set the location precisions.\n\t * \n\t * @param {module:domain~LocationPrecision[]|Set<module:domain~LocationPrecision>} locationPrecisions the precisions to use\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithLocationPrecisions(locationPrecisions) {\n\t\tthis.locationPrecisions = setOrNull(locationPrecisions);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add location precisions.\n\t * \n\t * @param {module:domain~LocationPrecision[]|Set<module:domain~LocationPrecision>} locationPrecisions the precisions to add\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\taddLocationPrecisions(locationPrecisions) {\n\t\treturn this.withLocationPrecisions(mergedSets(this.locationPrecisions, locationPrecisions));\n\t}\n\n\t/**\n\t * Set a minimum aggregation level.\n\t * \n\t * @param {module:domain~Aggregation} minAggregation the minimum aggregation level to set\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithMinAggregation(minAggregation) {\n\t\tthis.minAggregation = minAggregation;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the effective aggregation level set from the policy settings.\n\t * \n\t * This computes a set of aggregation levels based on the configured `minAggregation`\n\t * and `aggregations` values.\n\t * \n\t * @returns {Set<module:domain~Aggregation>} the aggregation set\n\t * @private\n\t */\n\tbuildAggregations() {\n\t\tconst minAggregation = this.minAggregation;\n\t\tconst aggregations = this.aggregations;\n\t\tif ( !minAggregation && aggregations && aggregations.size > 0 ) {\n\t\t\treturn aggregations;\n\t\t} else if ( !minAggregation ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn Aggregation.minimumEnumSet(minAggregation, MIN_AGGREGATION_CACHE);\n\t}\n\n\t/**\n\t * Treat the configured `locationPrecisions` set as a single\n\t * minimum value or a list of exact values.\n\t * \n\t * By default if `locationPrecisions` is configured with a single\n\t * value it will be treated as a <em>minimum</em> value, and any\n\t * {@link module:domain~LocationPrecision} with a {@link module:domain~LocationPrecision#precision} equal \n\t * to or higher than that value's level will be included in the generated\n\t * {@link module:domain~SecurityPolicy#locationPrecisions} set. Set this to\n\t * `null` to disable that behavior and treat\n\t * `locationPrecisions` as the exact values to include in the\n\t * generated {@link module:domain~SecurityPolicy#locationPrecisions} set.\n\t * \n\t * @param {module:domain~LocationPrecision|null} minLocationPrecision\n\t *        `null` to treat configured location precision values\n\t *        as-is, or else the minimum threshold\n\t * @returns {module:domain~SecurityPolicyBuilder} this object\n\t */\n\twithMinLocationPrecision(minLocationPrecision) {\n\t\tthis.minLocationPrecision = minLocationPrecision;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Build the effective aggregation level set from the policy settings.\n\t * \n\t * This computes a set of location precision levels based on the configured `minLocationPrecision`\n\t * and `locationPrecisions` values.\n\t * \n\t * @returns {Set<module:domain~LocationPrecision>} the precision set\n\t * @private\n\t */\n\tbuildLocationPrecisions() {\n\t\tconst minLocationPrecision = this.minLocationPrecision;\n\t\tconst locationPrecisions = this.locationPrecisions;\n\t\tif ( !minLocationPrecision && locationPrecisions && locationPrecisions.size > 0 ) {\n\t\t\treturn locationPrecisions;\n\t\t} else if ( !minLocationPrecision ) {\n\t\t\treturn null;\n\t\t}\n\t\treturn LocationPrecision.minimumEnumSet(minLocationPrecision, MIN_LOCATION_PRECISION_CACHE);\n\t}\n\n\t/**\n\t * Create a new {@link SecurityPolicy} out of the properties configured on this builder.\n\t * \n\t * @returns {module:domain~SecurityPolicy} the new policy instance\n\t */\n\tbuild() {\n\t\treturn new SecurityPolicy(this.nodeIds, this.sourceIds, \n\t\t\t\tthis.buildAggregations(), this.minAggregation,\n\t\t\t\tthis.buildLocationPrecisions(), this.minLocationPrecision,\n\t\t\t\tthis.nodeMetadataPaths, this.userMetadataPaths);\n\t}\n}\n\nexport default SecurityPolicy;\nexport { SecurityPolicyBuilder };","/**\n * A case-insensitive string key multi-value map object.\n * @alias module:util~MultiMap\n */\nclass MultiMap {\n\n\t/**\n\t * Constructor.\n\t * \n\t * @param {*} [values] an object who's enumerable properties will be added to this map\n\t */\n\tconstructor(values) {\n\t\tthis.mappings = {}; // map of lower-case header names to {name:X, val:[]} values\n\t\tthis.mappingNames = []; // to keep insertion order\n\t\tif ( values ) {\n\t\t\tthis.putAll(values);\n\t\t}\n\t}\n\n\t/**\n\t * Add a value.\n\t * \n\t * This method will append values to existing keys.\n\t * \n\t * @param {string} key the key to use\n\t * @param {*} value the value to add\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tadd(key, value) {\n\t\treturn addValue(this, key, value);\n\t}\n\n\t/**\n\t * Set a value.\n\t * \n\t * This method will replace any existing values with just <code>value</code>.\n\t * \n\t * @param {string} key the key to use\n\t * @param {*} value the value to set\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tput(key, value) {\n\t\treturn addValue(this, key, value, true);\n\t}\n\n\t/**\n\t * Set multiple values.\n\t * \n\t * This method will replace any existing values with those provided on <code>values</code>.\n\t * \n\t * @param {*} values an object who's enumerable properties will be added to this map\n\t * @returns {module:util~MutliMap} this object\n\t */\n\tputAll(values) {\n\t\tfor ( let key in values ) {\n\t\t\tif ( values.hasOwnProperty(key) ) {\n                addValue(this, key, values[key], true);\n            }\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the values associated with a key.\n\t * \n\t * @param {string} key the key of the values to get\n\t * @returns {object[]} the array of values associated with the key, or <code>undefined</code> if not available\n\t */\n\tvalue(key) {\n\t\tconst keyLc = key.toLowerCase();\n\t\tconst mapping = this.mappings[keyLc];\n\t\treturn (mapping ? mapping.val : undefined);\n\t}\n\n\t/**\n\t * Get the first avaialble value assocaited with a key.\n\t * \n\t * @param {string} key the key of the value to get\n\t * @returns {*} the first available value associated with the key, or <code>undefined</code> if not available\n\t */\n\tfirstValue(key) {\n\t\tconst values = this.value(key);\n\t\treturn (values && values.length > 0 ? values[0] : undefined);\n\t}\n\n\t/**\n\t * Remove all properties from this map.\n\t * \n\t * @returns {module:util~MutliMap} this object\n\t */\n\tclear() {\n\t\tthis.mappingNames.length = 0;\n\t\tthis.mappings = {};\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all values associated with a key.\n\t * \n\t * @param {string} key the key of the values to remove\n\t * @returns {object[]} the removed values, or <code>undefined</code> if no values were present for the given key\n\t */\n\tremove(key) {\n\t\tconst keyLc = key.toLowerCase();\n\t\tconst index = this.mappingNames.indexOf(keyLc);\n\t\tconst result = this.mappings[keyLc];\n\t\tif ( result ) {\n\t\t\tdelete this.mappings[keyLc];\n\t\t\tthis.mappingNames.splice(index, 1);\n\t\t}\n\t\treturn (result ? result.val : undefined);\n\t}\n\n\t/**\n\t * Get the number of entries in this map.\n\t * \n\t * @returns {number} the number of entries in the map\n\t */\n\tsize() {\n\t\treturn this.mappingNames.length;\n\t}\n\n\t/**\n\t * Test if the map is empty.\n\t * \n\t * @returns {boolean} <code>true</code> if there are no entries in this map\n\t */\n\tisEmpty() {\n\t\treturn this.size() < 1;\n\t}\n\n\t/**\n\t * Test if there are any values associated with a key.\n\t * \n\t * @param {string} key the key to test\n\t * @returns {boolean} <code>true</code> if there is at least one value associated with the key\n\t */\n\tcontainsKey(key) {\n\t\treturn (this.value(key) !== undefined);\n\t}\n\n\t/**\n\t * Get an array of all keys in this map.\n\t * \n\t * @returns {string[]} array of keys in this map, or an empty array if the map is empty\n\t */\n\tkeySet() {\n\t\tconst result = [];\n\t\tconst len = this.size();\n\t\tfor ( let i = 0; i < len; i += 1 ) {\n\t\t\tresult.push(this.mappings[this.mappingNames[i]].key);\n\t\t}\n\t\treturn result;\n\t}\n}\n\n/**\n * Add/replace values on a map.\n * \n * @param {module:util~MutliMap} map the map to mutate \n * @param {string} key the key to change \n * @param {*} value the value to add\n * @param {boolean} replace if <code>true</code> then replace all existing values;\n *                          if <code>false</code> append to any existing values\n * @returns {module:util~MutliMap} the passed in <code>map</code>\n * @private\n */\nfunction addValue(map, key, value, replace) {\n\tconst keyLc = key.toLowerCase();\n\tlet mapping = map.mappings[keyLc];\n\tif ( !mapping ) {\n\t\tmapping = {key:key, val:[]};\n\t\tmap.mappings[keyLc] = mapping;\n\t\tmap.mappingNames.push(keyLc);\n\t}\n\tif ( replace ) {\n\t\tmapping.val.length = 0;\n\t}\n\tif ( Array.isArray(value) ) {\n\t\tconst len = value.length;\n\t\tfor ( let i = 0; i < len; i += 1 ) {\n\t\t\tmapping.val.push(value[i]);\n\t\t}\n\t} else {\n\t\tmapping.val.push(value);\n\t}\n\treturn map;\n}\n\nexport default MultiMap;\n","function createGetter(me, prop) {\n\treturn function() { return me.map[prop]; };\n}\n\nfunction createSetter(me, prop) {\n\treturn function(value) { me.map[prop] = value; };\n}\n\nfunction createProperty(me, prop) {\n\tObject.defineProperty(me, prop, {\n\t\tenumerable : true,\n\t\tconfigurable : true,\n\t\tget : createGetter(me, prop),\n\t\tset : createSetter(me, prop)\n\t});\n}\n\n/**\n * A configuration utility object.\n *\n * Properties can be get/set by using the {@link module:util~Configuration#value} function.\n * @alias module:util~Configuration\n */\nclass Configuration {\n\n\t/**\n\t * Constructor.\n\t *\n\t * For any properties passed on `initialMap`, {@link module:util~Configuration#value} will\n\t * be called so those properties are defined on this instance.\n\t *\n\t * @param {object} initialMap the optional initial properties to store\n\t */\n\tconstructor(initialMap) {\n\t\tthis.map = {};\n\t\tif ( initialMap !== undefined ) {\n\t\t\tthis.values(initialMap);\n\t\t}\n\t}\n\n\t/**\n\t * Test if a key is truthy.\n\t *\n\t * @param {string} key the key to test\n\t * @returns {boolean} `true` if the key is enabled\n\t */\n\tenabled(key) {\n\t\tif ( key === undefined ) {\n\t\t\treturn false;\n\t\t}\n\t\treturn !!this.map[key];\n\t}\n\n\t/**\n\t * Set or toggle the enabled status of a given key.\n\t *\n\t * <p>If the `enabled` parameter is not passed, then the enabled\n\t * status will be toggled to its opposite value.</p>\n\t *\n\t * @param {string} key they key to set\n\t * @param {boolean} enabled the optional enabled value to set\n\t * @returns {module:util~Configuration} this object to allow method chaining\n\t */\n\ttoggle(key, enabled) {\n\t\tvar val = enabled;\n\t\tif ( key === undefined ) {\n\t\t\treturn this;\n\t\t}\n\t\tif ( val === undefined ) {\n\t\t\t// in 1-argument mode, toggle current value\n\t\t\tval = (this.map[key] === undefined);\n\t\t}\n\t\treturn this.value(key, (val === true ? true : null));\n\t}\n\n\t/**\n\t * Get or set a configuration value.\n\t *\n\t * @param {string} key The key to get or set the value for\n\t * @param {object} [newValue] If defined, the new value to set for the given `key`.\n\t *                            If `null` then the value will be removed.\n\t * @returns {object} If called as a getter, the associated value for the given `key`,\n\t *                   otherwise this object.\n\t */\n\tvalue(key, newValue) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\treturn this.map[key];\n\t\t}\n\t\tif ( newValue === null ) {\n\t\t\tdelete this.map[key];\n\t\t\tif ( this.hasOwnProperty(key) ) {\n\t\t\t\tdelete this[key];\n\t\t\t}\n\t\t} else {\n\t\t\tthis.map[key] = newValue;\n\t\t\tif ( !this.hasOwnProperty(key) ) {\n\t\t\t\tcreateProperty(this, key);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get or set multiple properties.\n\t * \n\t * @param {object} [newMap] a map of values to set\n\t * @returns {object} if called as a getter, all properties of this object copied into a simple object;\n\t *                   otherwise this object\n\t */\n\tvalues(newMap) {\n\t\tif ( newMap ) {\n\t\t\tfor ( let prop in newMap ) {\n\t\t\t\tif ( newMap.hasOwnProperty(prop) ) {\n\t\t\t\t\tthis.value(prop, newMap[prop]);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\treturn Object.assign({}, this.map);\n\t}\n\n}\n\nexport default Configuration;\n","import Configuration from '../util/configuration';\n\n/**\n * Normailze a protocol value.\n * \n * This method is used to normalize protocol values which might come from a `Location`\n * object and thus contain a trailing colon.\n * \n * @param {String} [val] the protocol value to normalize\n * @returns {String} the normalized protocol value\n * @alias module:net~normalizedProtocol\n */\nfunction normalizedProtocol(val) {\n\tif ( !val ) {\n\t\treturn 'https';\n\t}\n\treturn val.replace(/:$/, '');\n}\n\n/**\n * Normalize the environment configuration.\n * \n * Passing a browser `Location` object, like `window.location`, is supported. The\n * `protocol`, `hostname`, and `port` values will be used.\n * \n * @param {Object} [config] the initial configuration\n * @returns {Object} a new object with normalized configuration values\n * @alias module:net~normalizedConfig\n */\nfunction normalizedConfig(config) {\n\tvar result = Object.assign({\n\t\thost: 'data.solarnetwork.net'\n\t}, config);\n\tresult.protocol = normalizedProtocol(result.protocol || 'https');\n\tresult.port = (result.port || (result.protocol === 'https'  ? 443  : 80));\n\tresult.host = (result.port && result.hostname ? result.hostname : result.host);\n\treturn result;\n}\n\n/**\n * An environment configuration utility object.\n *\n * This extends {@link module:util~Configuration} to add support for standard properties\n * needed to access the SolarNetwork API, such as host and protocol values.\n *\n * @extends module:util~Configuration\n * @alias module:net~Environment\n */\nclass Environment extends Configuration {\n\n\t/**\n\t * Constructor.\n\t *\n\t * This will define the following default properties, if not supplied on the\n\t * `config` argument:\n\t *\n\t * <dl>\n\t * <dt>host</dt><dd>`data.solarnetwork.net`</dd>\n\t * <dt>protocol</dt><dd>`https`</dd>\n\t * <dt>port</dt><dd>`443`</dd>\n\t * </dl>\n\t * \n\t * These properties correspond to those on the `window.location` object when\n\t * running in a browser. Thus to construct an environment based on the location\n\t * of the current page you can create an instance like this:\n\t * \n\t * ```\n\t * const env = new Environment(window.location);\n\t * ```\n\t *\n\t * @param {Object} [config] an optional set of properties to start with\n\t */\n\tconstructor(config) {\n\t\tsuper(normalizedConfig(config));\n\t}\n\n    /**\n\t * Check if TLS is in use via the `https` protocol.\n\t *\n     * @returns {boolean} `true` if the `protocol` is set to `https`\n     */\n\tuseTls() {\n\t\treturn (this.value('protocol') === 'https');\n\t}\n\n}\n\nexport default Environment;\n","/**\n * Parse the query portion of a URL string, and return a parameter object for the\n * parsed key/value pairs.\n *\n * <p>Multiple parameters of the same name will be stored as an array on the returned object.</p>\n *\n * @param {string} search the query portion of the URL, which may optionally include\n *                        the leading `?` character\n * @param {Set<String>} [multiValueKeys] if provided, a set of keys for which to always treat\n *                                       as a multi-value array, even if there is only one value\n * @return {object} the parsed query parameters, as a parameter object\n * @alias module:net~urlQueryParse\n */\nfunction urlQueryParse(search, multiValueKeys) {\n    var params = {};\n    var pairs;\n    var pair;\n    var i, len, k, v;\n    if ( search !== undefined && search.length > 0 ) {\n        // remove any leading ? character\n        if ( search.match(/^\\?/) ) {\n            search = search.substring(1);\n        }\n        pairs = search.split('&');\n        for ( i = 0, len = pairs.length; i < len; i++ ) {\n            pair = pairs[i].split('=', 2);\n            if ( pair.length === 2 ) {\n                k = decodeURIComponent(pair[0]);\n                v = decodeURIComponent(pair[1]);\n                if ( params[k] ) {\n                    if ( !Array.isArray(params[k]) ) {\n                        params[k] = [params[k]]; // turn into array;\n                    }\n                    params[k].push(v);\n                } else if ( multiValueKeys && multiValueKeys.has(k) ) {\n                    params[k] = [v];\n                } else {\n                    params[k] = v;\n                }\n            }\n        }\n    }\n    return params;\n}\n\n/**\n * Encode the properties of an object as a URL query string.\n *\n * <p>If an object property has an array value, multiple URL parameters will be encoded for that property.</p>\n *\n * <p>The optional `encoderFn` argument is a function that accepts a string value\n * and should return a URI-safe string for that value.</p>\n *\n * @param {object} parameters an object to encode as URL parameters\n * @param {function} encoderFn an optional function to encode each URI component with;\n *                             if not provided the built-in `encodeURIComponent()` function\n *                             will be used\n * @return {string} the encoded query parameters\n * @alias module:net~urlQueryEncode\n */\nfunction urlQueryEncode(parameters, encoderFn) {\n    var result = '',\n        prop,\n        val,\n        i,\n        len;\n    const encoder = (encoderFn || encodeURIComponent);\n    function handleValue(k, v) {\n        if ( result.length ) {\n            result += '&';\n        }\n        result += encoder(k) + '=' + encoder(v);\n    }\n    if ( parameters ) {\n        for ( prop in parameters ) {\n            if ( parameters.hasOwnProperty(prop) ) {\n                val = parameters[prop];\n                if ( Array.isArray(val) ) {\n                    for ( i = 0, len = val.length; i < len; i++ ) {\n                        handleValue(prop, val[i]);\n                    }\n                } else {\n                    handleValue(prop, val);\n                }\n            }\n        }\n    }\n    return result;\n}\n\nexport { urlQueryParse, urlQueryEncode };\n\nexport default {\n    urlQueryParse : urlQueryParse,\n    urlQueryEncode : urlQueryEncode,\n}\n","import Base64 from 'crypto-js/enc-base64';\nimport Hex from 'crypto-js/enc-hex';\nimport HmacSHA256 from 'crypto-js/hmac-sha256';\nimport SHA256 from 'crypto-js/sha256';\nimport { parse as uriParse } from 'uri-js';\n\nimport { iso8601Date } from '../format/date';\nimport MultiMap from '../util/multiMap';\nimport Environment from './environment';\nimport { HttpMethod, default as HttpHeaders } from './httpHeaders';\nimport { urlQueryParse } from './urlQuery';\n\n/**\n * The number of milliseconds a signing key is valid for.\n * @type {number}\n * @private\n */\nconst SIGNING_KEY_VALIDITY = (7 * 24 * 60 * 60 * 1000);\n\n/**\n * A builder object for the SNWS2 HTTP authorization scheme.\n *\n * This builder can be used to calculate a one-off header value, for example:\n *\n * ```\n * let authHeader = new AuthorizationV2Builder(\"my-token\")\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .build(\"my-token-secret\");\n * ```\n * \n * Or the builder can be re-used for a given token:\n *\n * ```\n * // create a builder for a token\n * let builder = new AuthorizationV2Builder(\"my-token\");\n *\n * // elsewhere, re-use the builder for repeated requests\n * builder.reset()\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .build(\"my-token-secret\");\n * ```\n *\n * Additionally, a signing key can be generated and re-used for up to 7 days:\n *\n * ```\n * // create a builder for a token\n * let builder = new AuthorizationV2Builder(\"my-token\")\n *   .saveSigningKey(\"my-token-secret\");\n *\n * // elsewhere, re-use the builder for repeated requests\n * builder.reset()\n *     .path(\"/solarquery/api/v1/pub/...\")\n *     .buildWithSavedKey(); // note previously generated key used\n * ```\n * @alias module:net~AuthorizationV2Builder\n */\nclass AuthorizationV2Builder {\n\n    /**\n     * Constructor.\n     * \n     * @param {string} token the auth token to use\n     * @param {module:net~Environment} [environment] the environment to use; if not provided a default environment will be created \n     */\n    constructor(token, environment) {\n\n        /**\n         * The SolarNet auth token value.\n         * @member {string}\n         */\n        this.tokenId = token;\n\n        /**\n         * The SolarNet environment.\n         * @member {module:net~Environment}\n         */\n        this.environment = (environment || new Environment());\n\n        /**\n         * Force a port number to be added to host values, even if port would be implied.\n         * \n         * This can be useful when working with a server behind a proxy, where the \n         * proxy is configured to always forward the port even if the port is implied\n         * (i.e. HTTPS is used on the standard port 443).\n         * \n         * @member {boolean}\n         */\n        this.forceHostPort = false;\n\n        this.reset();\n    }\n\n    /**\n     * Reset to defalut property values.\n     *\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    reset() {\n        this.contentDigest = null;\n        this.httpHeaders = new HttpHeaders();\n        this.parameters = new MultiMap();\n        this.signedHeaderNames = [];\n        var host = this.environment.host;\n        if ( this.environment.protocol === 'https' || this.environment.port != 80 ) {\n            host += ':' +this.environment.port;\n        }\n        return this.method(HttpMethod.GET).host(host).path('/').date(new Date());\n    }\n\n    /**\n     * Compute and cache the signing key.\n     *\n     * Signing keys are derived from the token secret and valid for 7 days, so\n     * this method can be used to compute a signing key so that {@link module:net~AuthorizationV2Builder#build}\n     * can be called later. The signing date will be set to whatever date is\n     * currently configured via {@link module:net~AuthorizationV2Builder#date}, which defaults to the\n     * current time for newly created builder instances.\n     *\n     * @param {string} tokenSecret the secret to sign the digest with\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    saveSigningKey(tokenSecret) {\n        this.signingKey = this.computeSigningKey(tokenSecret);\n        this.signingKeyExpiration = new Date(this.requestDate.getTime() + SIGNING_KEY_VALIDITY)\n    }\n\n    /**\n     * Test if a signing key is present and not expired.\n     * @readonly\n     * @type {boolean}\n     */\n    get signingKeyValid() {\n        return (this.signingKey && this.signingKeyExpiration instanceof Date\n            && Date.now() < this.signingKeyExpiration.getTime() ? true : false);\n    }\n\n    /**\n     * Set the HTTP method (verb) to use.\n     *\n     * @param {string} val the method to use; see the {@link HttpMethod} enum for possible values\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    method(val) {\n        this.httpMethod = val;\n        return this;\n    }\n\n    /**\n     * Set the HTTP host.\n     *\n     * This is a shortcut for calling `HttpHeaders#put(HttpHeaders.HOST, val)`.\n     *\n     * @param {string} val the HTTP host value to use\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    host(val) {\n        if ( this.forceHostPort && val.indexOf(':') < 0 && this.environment.port != 80 ) {\n            val += ':' +this.environment.port;\n        }\n        this.httpHeaders.put(HttpHeaders.HOST, val);\n        return this;\n    }\n\n    /**\n     * Set the HTTP request path to use.\n     *\n     * @param {string} val the request path to use\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    path(val) {\n        this.requestPath = val;\n        return this;\n    }\n\n    /**\n     * Set the host, path, and query parameters via a URL string.\n     *\n     * @param {string} url the URL value to use\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    url(url) {\n        const uri = uriParse(url);\n        let host = uri.host;\n        if ( uri.port && (((uri.scheme === 'https' || uri.scheme === 'wss') && uri.port !== 443) \n                || ((uri.scheme === 'http' || uri.scheme === 'ws') && uri.port !== 80)) ) {\n            host += ':' + uri.port;\n        }\n        if ( uri.query ) {\n            this.queryParams(urlQueryParse(uri.query));\n        }\n        return this.host(host).path(uri.path);\n    }\n\n    /**\n     * Set the HTTP content type.\n     *\n     * This is a shortcut for calling {@link HttpHeaders#put} with the key {@link HttpHeaders#CONTENT_TYPE}.\n     *\n     * @param {string} val the HTTP content type value to use\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    contentType(val) {\n        this.httpHeaders.put(HttpHeaders.CONTENT_TYPE, val);\n        return this;\n    }\n\n    /**\n     * Set the authorization request date.\n     *\n     * @param {Date} val the date to use; typically the current time, e.g. `new Date()`\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    date(val) {\n        this.requestDate = (val ? val : new Date());\n        return this;\n    }\n\n    /**\n     * The authorization request date as a HTTP header string value.\n     *\n     * @readonly\n     * @type {string}\n     */\n    get requestDateHeaderValue() {\n        return this.requestDate.toUTCString();\n    }\n\n    /**\n     * Control using the `X-SN-Date` HTTP header versus the `Date` header.\n     *\n     * <p>Set to `true` to use the `X-SN-Date` header, `false` to use \n     * the `Date` header. This will return `true` if `X-SN-Date` has been\n     * added to the `signedHeaderNames` property or has been added to the `httpHeaders`\n     * property.</p>\n     *\n     * @type {boolean}\n     */\n    get useSnDate() {\n        let signedHeaders = this.signedHeaderNames;\n        let existingIndex = (Array.isArray(signedHeaders)\n            ? signedHeaders.findIndex(caseInsensitiveEqualsFn(HttpHeaders.X_SN_DATE))\n            : -1);\n        return existingIndex >= 0 || this.httpHeaders.containsKey(HttpHeaders.X_SN_DATE);\n    }\n\n    set useSnDate(enabled) {\n        let signedHeaders = this.signedHeaderNames;\n        let existingIndex = (Array.isArray(signedHeaders)\n            ? signedHeaders.findIndex(caseInsensitiveEqualsFn(HttpHeaders.X_SN_DATE))\n            : -1);\n        if ( enabled && existingIndex < 0 ) {\n            signedHeaders = (signedHeaders\n                ? signedHeaders.concat(HttpHeaders.X_SN_DATE)\n                : [HttpHeaders.X_SN_DATE]);\n            this.signedHeaderNames = signedHeaders;\n        } else if ( !enabled && existingIndex >= 0 ) {\n            signedHeaders.splice(existingIndex, 1);\n            this.signedHeaderNames = signedHeaders;\n        }\n\n        // also clear from httpHeaders\n        this.httpHeaders.remove(HttpHeaders.X_SN_DATE);\n    }\n\n    /**\n     * Set the `useSnDate` property.\n     *\n     * @param {boolean} enabled `true` to use the `X-SN-Date` header, `false` to use `Date`\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    snDate(enabled) {\n        this.useSnDate = enabled;\n        return this;\n    }\n\n    /**\n     * Set a HTTP header value.\n     *\n     * This is a shortcut for calling `HttpHeaders#put(headerName, val)`.\n     *\n     * @param {string} headerName the header name to set\n     * @param {string} headerValue the header value to set\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    header(headerName, headerValue) {\n        this.httpHeaders.put(headerName, headerValue);\n        return this;\n    }\n\n    /**\n     * Set the HTTP headers to use with the request.\n     *\n     * The headers object must include all headers necessary by the\n     * authentication scheme, and any additional headers also configured via\n     * {@link module:net~AuthorizationV2Builder#signedHttpHeaders}.\n     *\n     * @param {HttpHeaders} headers the HTTP headers to use\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    headers(headers) {\n        this.httpHeaders = headers;\n        return this;\n    }\n\n    /**\n     * Set the HTTP `GET` query parameters, or `POST` form-encoded\n     * parameters.\n     *\n     * @param {MultiMap|Object} params the parameters to use, as either a {@link MultiMap} or simple `Object`\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    queryParams(params) {\n        if ( params instanceof MultiMap ) {\n            this.parameters = params;\n        } else {\n            this.parameters.putAll(params);\n        }\n        return this;\n    }\n\n    /**\n     * Set additional HTTP header names to sign with the authentication.\n     *\n     * @param {sring[]} signedHeaderNames additional HTTP header names to include in the signature\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    signedHttpHeaders(signedHeaderNames) {\n        this.signedHeaderNames = signedHeaderNames;\n        return this;\n    }\n\n    /**\n     * Set the HTTP request body content SHA-256 digest value.\n     *\n     * @param {string|module:crypto-js/enc-hex~WordArray} digest the digest value to use; if a string it is assumed to be Hex encoded\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    contentSHA256(digest) {\n        var contentDigest;\n        if ( typeof digest === 'string' ) {\n            contentDigest = Hex.parse(digest);\n        } else {\n            contentDigest = digest;\n        }\n        this.contentDigest = contentDigest;\n        return this;\n    }\n\n    /**\n     * Compute the SHA-256 digest of the request body content and configure the result on this builder.\n     * \n     * This method will compute the digest and then save the result via the {@link module:net~AuthorizationV2Builder#contentSHA256}\n     * method. In addition, it will set the `Digest` HTTP header value via {@link module:net~AuthorizationV2Builder#header}. \n     * This means you <i>must</i> also pass the `Digest` HTTP header with the request. After calling this\n     * method, you can retrieve the `Digest` HTTP header value via the `httpHeaders`property.\n     * \n     * @param {string} content the request body content to compute a SHA-256 digest value from\n     * @returns {module:net~AuthorizationV2Builder} this object\n     */\n    computeContentDigest(content) {\n        var digest = SHA256(content);\n        this.contentSHA256(digest);\n        this.header('Digest', 'sha-256=' +Base64.stringify(digest));\n        return this;\n    }\n\n    /**\n     * Compute the canonical query parameters.\n     * \n     * @returns {string} the canonical query parameters string value\n     */\n    canonicalQueryParameters() {\n        const keys = this.parameters.keySet();\n        if ( keys.length < 1 ) {\n            return '';\n        }\n        keys.sort();\n        const len = keys.length;\n        var first = true,\n            result = '';\n        for ( let i = 0; i < len; i += 1 ) {\n            let key = keys[i];\n            let vals = this.parameters.value(key);\n            const valsLen = vals.length;\n            for ( let j = 0; j < valsLen; j += 1 ) {\n                if ( first ) {\n                    first = false;\n                } else {\n                    result += '&';\n                }\n                result += _encodeURIComponent(key) + '=' + _encodeURIComponent(vals[j]);\n            }\n        }\n        return result;\n    }\n\n    /**\n     * Compute the canonical HTTP headers string value.\n     * \n     * @param {string[]} sortedLowercaseHeaderNames the sorted, lower-cased HTTP header names to include\n     * @returns {string} the canonical headers string value\n     */\n    canonicalHeaders(sortedLowercaseHeaderNames) {\n        var result = '',\n            headerName,\n            headerValue;\n        const len = sortedLowercaseHeaderNames.length;\n        for ( let i = 0; i < len; i += 1 ) {\n            headerName = sortedLowercaseHeaderNames[i];\n            if ( \"date\" === headerName ||  \"x-sn-date\" === headerName ) {\n                headerValue = this.requestDate.toUTCString();\n            } else {\n                headerValue = this.httpHeaders.firstValue(headerName);\n            }\n            result += headerName +':' + (headerValue ? headerValue.trim() : '') + '\\n';\n        }\n        return result;\n    }\n\n    /**\n     * Compute the canonical signed header names value from an array of HTTP header names.\n     * \n     * @param {string[]} sortedLowercaseHeaderNames the sorted, lower-cased HTTP header names to include\n     * @returns {string} the canonical signed header names string value\n     * @private\n     */\n    canonicalSignedHeaderNames(sortedLowercaseHeaderNames) {\n        return sortedLowercaseHeaderNames.join(';');\n    }\n\n    /**\n     * Get the canonical request content SHA256 digest, hex encoded.\n     * \n     * @returns {string} the hex-encoded SHA256 digest of the request content\n     */\n    canonicalContentSHA256() {\n        return (this.contentDigest\n            ? Hex.stringify(this.contentDigest)\n            : AuthorizationV2Builder.EMPTY_STRING_SHA256_HEX);\n    }\n\n    /**\n     * Compute the canonical HTTP header names to include in the signature.\n     * \n     * @returns {string[]} the sorted, lower-cased HTTP header names to include\n     */\n    canonicalHeaderNames() {\n        const httpHeaders = this.httpHeaders;\n        const signedHeaderNames = this.signedHeaderNames;\n\n        // use a MultiMap to take advantage of case-insensitive keys\n        const map = new MultiMap();\n\n        map.put(HttpHeaders.HOST, true);\n        if ( this.useSnDate ) {\n            map.put(HttpHeaders.X_SN_DATE, true);\n        } else {\n            map.put(HttpHeaders.DATE, true);\n        }\n        if ( httpHeaders.containsKey(HttpHeaders.CONTENT_MD5) ) {\n            map.put(HttpHeaders.CONTENT_MD5, true);\n        }\n        if ( httpHeaders.containsKey(HttpHeaders.CONTENT_TYPE) ) {\n            map.put(HttpHeaders.CONTENT_TYPE, true);\n        }\n        if ( httpHeaders.containsKey(HttpHeaders.DIGEST) ) {\n            map.put(HttpHeaders.DIGEST, true);\n        }\n        if ( signedHeaderNames && signedHeaderNames.length > 0 ) {\n            signedHeaderNames.forEach(e => map.put(e, true));\n        }\n        return lowercaseSortedArray(map.keySet());\n    }\n\n    /**\n     * Compute the canonical request data that will be included in the data to sign with the request.\n     * \n     * @returns {string} the canonical request data\n     */\n    buildCanonicalRequestData() {\n        return this.computeCanonicalRequestData(this.canonicalHeaderNames());\n    }\n\n    /**\n     * Compute the canonical request data that will be included in the data to sign with the request,\n     * using a specific set of HTTP header names to sign.\n     * \n     * @param {string[]} sortedLowercaseHeaderNames the sorted, lower-cased HTTP header names to sign with the request\n     * @returns {string} the canonical request data\n     * @private\n     */\n    computeCanonicalRequestData(sortedLowercaseHeaderNames) {\n        // 1: HTTP verb\n        var result = this.httpMethod +'\\n';\n\n        // 2: Canonical URI\n        result += this.requestPath + '\\n';\n\n        // 3: Canonical query string\n        result += this.canonicalQueryParameters() + '\\n';\n\n        // 4: Canonical headers\n        result += this.canonicalHeaders(sortedLowercaseHeaderNames); // already includes newline\n\n        // 5: Signed header names\n        result += this.canonicalSignedHeaderNames(sortedLowercaseHeaderNames) + '\\n';\n\n        // 6: Content SHA256, hex encoded\n        result += this.canonicalContentSHA256();\n\n        return result;\n    }\n\n    /**\n     * Compute the signing key, from a secret key.\n     * \n     * @param {string} secretKey the secret key string \n     * @returns {CryptoJS#Hash} the computed key\n     * @private\n     */\n    computeSigningKey(secretKey) {\n        const datestring = iso8601Date(this.requestDate);\n        const key = HmacSHA256('snws2_request', HmacSHA256(datestring, 'SNWS2' + secretKey));\n        return key;\n    }\n\n    /**\n     * Compute the data to be signed by the signing key.\n     * \n     * @param {string} canonicalRequestData the request data, returned from {@link module:net~AuthorizationV2Builder#buildCanonicalRequestData}\n     * @returns {string} the data to sign\n     * @private\n     */\n    computeSignatureData(canonicalRequestData) {\n        /*- signature data is like:\n\n            SNWS2-HMAC-SHA256\\n\n            20170301T120000Z\\n\n            Hex(SHA256(canonicalRequestData))\n        */\n        return \"SNWS2-HMAC-SHA256\\n\" + iso8601Date(this.requestDate, true) + \"\\n\"\n                + Hex.stringify(SHA256(canonicalRequestData));\n    }\n\n    /**\n     * Compute a HTTP `Authorization` header value from the configured properties\n     * on the builder, using the provided signing key.\n     * \n     * @param {CryptoJS#Hash} signingKey the key to sign the computed signature data with\n     * @returns {string} the SNWS2 HTTP Authorization header value\n     * @private\n     */\n    buildWithKey(signingKey) {\n        const sortedHeaderNames = this.canonicalHeaderNames();\n        const canonicalReq = this.computeCanonicalRequestData(sortedHeaderNames);\n        const signatureData = this.computeSignatureData(canonicalReq);\n        const signature = Hex.stringify(HmacSHA256(signatureData, signingKey));\n        let result = 'SNWS2 Credential=' + this.tokenId\n            + ',SignedHeaders=' + sortedHeaderNames.join(';')\n            + ',Signature=' +signature;\n        return result;\n    }\n\n    /**\n     * Compute a HTTP `Authorization` header value from the configured\n     * properties on the builder, computing a new signing key based on the\n     * configured {@link module:net~AuthorizationV2Builder#date}.\n     *\n     * @param {string} tokenSecret the secret to sign the authorization with\n     * @return {string} the SNWS2 HTTP Authorization header value\n     */\n    build(tokenSecret) {\n        const signingKey = this.computeSigningKey(tokenSecret);\n        return this.buildWithKey(signingKey);\n    }\n\n    /**\n     * Compute a HTTP `Authorization` header value from the configured\n     * properties on the builder, using a signing key configured from a previous\n     * call to {@link module:net~AuthorizationV2Builder#saveSigningKey}.\n     *\n     * @return {string} the SNWS2 HTTP Authorization header value.\n     */\n    buildWithSavedKey() {\n        return this.buildWithKey(this.signingKey);\n    }\n\n}\n\n/**\n * @function stringMatchFn\n * @param {string} e the element to test\n * @returns {boolean} `true` if the element matches\n * @private\n */\n\n\n/**\n * Create a case-insensitive string matching function.\n * \n * @param {string} value the string to perform the case-insensitive comparison against\n * @returns {stringMatchFn} a matching function that performs a case-insensitive comparison\n * @private\n */\nfunction caseInsensitiveEqualsFn(value) {\n    const valueLc = value.toLowerCase();\n    return e => valueLc === e.toString().toLowerCase();\n}\n\n/**\n * Create a new array of lower-cased and sorted strings from another array.\n * \n * @param {string[]} items the items to lower-case and sort\n * @returns {string[]} a new array of the lower-cased and sorted items\n * @private\n */\nfunction lowercaseSortedArray(items) {\n    const sortedItems = [];\n    const len = items.length;\n    for ( let i = 0; i < len; i += 1 ) {\n        sortedItems.push(items[i].toLowerCase());\n    }\n    sortedItems.sort();\n    return sortedItems;\n}\n\nfunction _hexEscapeChar(c) {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase();\n}\n\nfunction _encodeURIComponent(str) {\n  return encodeURIComponent(str).replace(/[!'()*]/g, _hexEscapeChar);\n}\n\nObject.defineProperties(AuthorizationV2Builder, {\n    /**\n     * The hex-encoded value for an empty SHA256 digest value.\n     * \n     * @memberof AuthorizationV2Builder\n     * @readonly\n     * @type {string}\n     */\n    EMPTY_STRING_SHA256_HEX:    { value: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855' },\n\n    /**\n     * The SolarNetwork V2 authorization scheme.\n     * \n     * @memberof AuthorizationV2Builder\n     * @readonly\n     * @type {string}\n     */\n    SNWS2_AUTH_SCHEME:          { value: 'SNWS2' },\n});\n\nexport default AuthorizationV2Builder;\n","/* eslint no-console: 0 */\n\nlet logLevel = 2;\n\nfunction consoleLog(level, ...args) {\n    if ( level > logLevel ) {\n        return;\n    }\n    if ( !console ) {\n        return;\n    }\n\n    let logFn;\n    switch ( level ) {\n        case 1:\n            logFn = console.error;\n            break;\n        case 2:\n            logFn = console.warn;\n            break;\n        case 3:\n            logFn = console.info;\n            break;\n    }\n    if ( !logFn ) {\n        logFn = console.log;\n    }\n    if ( !logFn ) {\n        return; // no console available\n    }\n    logFn(...args); // TODO formatting like sn.format.fmt.apply(this, arguments)?\n}\n\nconst logLevels = Object.freeze({\n    DEBUG: 4,\n    INFO: 3,\n    WARN: 2,\n    ERROR: 1,\n    OFF: 0,\n});\n\n/**\n * An application logger.\n * \n * Logging levels range from 0-4 and is controlled at the application level.\n * Level `0` is off, `1` is error, `2` is warn, `3` is info,  and `4` is debug.\n * The default level starts as `2`.\n */\nclass Logger {\n\n    static debug(...args) {\n        consoleLog(4, ...args);\n    }\n\n    static info(...args) {\n        consoleLog(3, ...args);\n    }\n\n    static warn(...args) {\n        consoleLog(2, ...args);\n    }\n\n    static error(...args) {\n        consoleLog(1, ...args);\n    }\n\n}\n\nObject.defineProperties(Logger, {\n\t/**\n\t * The global logging level. Set to `0` to disable all logging.\n\t * \n\t * @memberof module:util~Logger\n\t * @type {number}\n\t */\n    level: { \n        get:function() { return logLevel; }, \n        set:function(v) { logLevel = typeof v === 'number' ? v : 0}\n    },\n});\n\nexport default Logger;\nexport { logLevels };\n","/**\n * Normalize a data array of time series data based on an aggregate time step.\n * \n * This method is useful for \"filling in\" gaps of data in situations where something expects\n * the data include placeholders for the gaps. Charting applications often expect this, for\n * example.\n * \n * Each element in the `data` array is expected to provide a `date` property that is a `Date`\n * object. When gaps are discovered in the array, \"filler\" objects will be inserted with\n * an approprate `date` value and all other properties copied from the previous element but\n * set to `null`.\n * \n * Here's an example where a new element is added to an array to fill in a missing time slot:\n * \n * ```\n * const queryData = [\n *     {date : new Date('2018-05-05T11:00Z'), Generation : 357, Consumption: 345},\n *     {date : new Date('2018-05-05T12:00Z'), Generation : 1023, Consumption: 678}\n * ]\n * \n * timeNormalizeDataArray(queryData, Aggregations.ThirtyMinute);\n * ```\n * \n * Then `queryData` would look like this:\n * \n * ```\n * [\n *     {date : new Date('2018-05-05T11:00Z'), Generation : 357, Consumption: 345},\n *     {date : new Date('2018-05-05T11:30Z'), Generation : null, Consumption: null},\n *     {date : new Date('2018-05-05T12:00Z'), Generation : 1023, Consumption: 678}\n * ]\n * ```\n * \n * @param {object[]} data the raw data returned from SolarNetwork; this array is modified in-place\n * @param {module:domain~Aggregation} aggregate the expected aggregate level of the data\n * @returns {void}\n * @alias module:data~timeNormalizeDataArray\n */\nexport function timeNormalizeDataArray(data, aggregate) {\n    const aggMillseconds = aggregate.level * 1000;\n    if ( !Array.isArray(data) || data.length < 2 ) {\n        return data;\n    }\n    var i = 0;\n    while ( i < data.length - 1 ) {\n        const d = data[i];\n        const currTime = d.date.getTime();\n        const expectedNextTime = currTime + aggMillseconds;\n        let nextTime = data[i+1].date.getTime();\n        if ( nextTime > expectedNextTime ) {\n            let fill = [i + 1, 0];\n            for ( let fillTime = currTime + aggMillseconds; fillTime < nextTime; fillTime += aggMillseconds ) {\n                let f = Object.create(Object.getPrototypeOf(d), Object.getOwnPropertyDescriptors(d));\n                for ( let p in f ) {\n                    f[p] = null;\n                }\n                f.date = new Date(fillTime);\n                fill.push(f);\n            }\n            Array.prototype.splice.apply(data, fill);\n            i += fill.length;\n        }\n        i += 1;            \n    }\n}\n\nexport default Object.freeze({\n\ttimeNormalizeDataArray : timeNormalizeDataArray,\n});\n","/**\n * An enumerated object base class.\n * \n * This class is essentially abstract, and must be extended by another\n * class that overrides the {@link module:util~Enum.enumValues} method.\n * \n * @abstract\n * @alias module:util~Enum\n */\nclass Enum {\n\n    /**\n     * Constructor.\n     * \n     * @param {string} name the name\n     */\n    constructor(name) {\n        this._name = name;\n        if ( this.constructor === Enum ) {\n            Object.freeze(this);\n        }\n    }\n\n    /**\n     * Get the enum name.\n     * \n     * @returns {string} the  name\n     */\n    get name() {\n        return this._name;\n    }\n\n    /**\n     * Test if a string is equal to this enum's name.\n     * \n     * As long as enum values are consistently obtained from the {@link module:util~Enum.enumValues}\n     * array then enum instances can be compared with `===`. If unsure, this method can be used\n     * to compare string values instead.\n     * \n     * If `value` is passed as an actual Enum instance, then if that enum is the same class\n     * as this enum it's `name` is compared to this instance's `name`.\n     * \n     * @param {string|Enum} value the value to test\n     * @returns {boolean} `true` if `value` is the same as this instance's `name` value \n     */\n    equals(value) {\n        if ( this.constructor === value.constructor ) {\n            return (value.name === this.name);\n        }\n        return (value === this.name);\n    }\n\n    /**\n     * Get all enum values.\n     * \n     * This method must be overridden by subclasses to return something meaningful.\n     * This implementation returns an empty array.\n     * \n     * @abstract\n     * @returns {module:util~Enum[]} get all enum values\n     */\n    static enumValues() {\n        return [];\n    }\n\n    /**\n     * This method takes an array of enums and turns them into a mapped object, using the enum\n     * `name` as object property names.\n     * \n     * @param {module:util~Enum[]} enums the enum list to turn into a value object\n     * @returns {object} an object with enum `name` properties with associated enum values \n     */\n    static enumsValue(enums) {\n        return Object.freeze(enums.reduce((obj, e) => {\n            obj[e.name] = e;\n            return obj;\n        }, {}));\n    }\n\n    /**\n     * Get an enum instance from its name.\n     * \n     * This method searches the {@link module:util~Enum#enumVvalues} array for a matching value.\n     * \n     * @param {string} name the enum name to get an instnace for\n     * @returns {module:util~Enum} the instance, or `undefined` if no instance exists for the given `name`\n     */\n    static valueOf(name) {\n        const enums = this.enumValues();\n        if ( !Array.isArray(enums) ) {\n            return undefined;\n        }\n        for ( let i = 0, len = enums.length; i < len; i += 1 ) {\n            if ( name === enums[i].name ) {\n                return enums[i];\n            }\n        }\n    }\n\n    static namesFor(set) {\n        const result = [];\n        if ( set ) {\n            for ( const e of set ) {\n                result.push(e.name);\n            }\n        }\n        return result;\n    }\n}\n\nexport default Enum;\n","import Enum from './enum';\n\n/**\n * An immutable enum-like object with an associated comparable value.\n *\n * This class is essentially abstract, and must be extended by another\n * class that overrides the inerited {@link module:util~Enum.enumValues} method.\n * \n * @abstract\n * @extends module:util~Enum\n * @alias module:util~ComparableEnum\n */\nclass ComparableEnum extends Enum {\n\n    /**\n     * Constructor.\n     * \n     * @param {string} name the name\n     * @param {number} value the comparable value\n     */\n    constructor(name, value) {\n        super(name);\n        this._value = value;\n        if ( this.constructor === ComparableEnum ) {\n            Object.freeze(this);\n        }\n    }\n\n    /**\n     * Get the comparable value.\n     * \n     * @returns {number} the value\n     */\n    get value() {\n        return this._value;\n    }\n\n    /**\n     * Compare two ComparableEnum objects based on their `value` values.\n     * \n     * @param {ComparableEnum} other the object to compare to\n     * @returns {number} `-1` if `this.value` is less than `other.value`, \n     *                   `1` if `this.value` is greater than `other.value`,\n     *                   `0` otherwise (when the values are equal) \n     */\n    compareTo(other) {\n        return this.value < other.value ? -1 : this.value > other.value ? 1 : 0;\n    }\n\n    /**\n     * Compute a complete set of enum values based on a minimum enum and/or set of enums.\n     * \n     * If `cache` is provided, then results computed via `minAggregation` \n     * will be cached there, and subsequent calls will returned the cached result when appropriate.\n     * \n     * @param {ComparableEnum} [minEnum] a minimum enum value\n     * @param {Map<string, Set<ComparableEnum>>} [cache] a cache of computed values\n     * @returns {Set<ComparableEnum>|null} the computed set, or `null` if no values match\n     */\n    static minimumEnumSet(minEnum, cache) {\n        if ( !minEnum ) {\n            return null;\n        }\n        let result = (cache ? cache.get(minEnum.name) : undefined);\n        if ( result ) {\n            return result;\n        }\n        result = new Set();\n        for ( const agg of minEnum.constructor.enumValues() ) {\n            if ( agg.compareTo(minEnum) > -1 ) {\n                result.add(agg);\n            }\n        }\n        if ( cache ) {\n            cache.set(minEnum.name, result);\n        }\n        return (result.size > 0 ? result : null);\n    }\n\n}\n\nexport default ComparableEnum;\n","import ComparableEnum from '../util/comparableEnum';\n\n/**\n * A named aggregation.\n * \n * @extends module:util~ComparableEnum\n * @alias module:domain~Aggregation\n */\nclass Aggregation extends ComparableEnum {\n\n\t/**\n     * Constructor.\n     * \n     * @param {string} name the unique name for this precision \n     * @param {number} level a relative aggregation level value \n     */\n    constructor(name, level) {\n\t\tsuper(name, level);\n\t\tif ( this.constructor === Aggregation ) {\n\t\t\tObject.freeze(this);\n\t\t}\n    }\n\n    /**\n     * Get the aggregate level value.\n\t * \n\t * This is an alias for {@link module:util~ComparableEnum#value}.\n     */\n    get level() {\n        return this.value;\n\t}\n\t\n\t/**\n\t * Get the {@link module:domain~Aggregations} values.\n\t * \n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn AggregationValues;\n\t}\n\n}\n\n\nconst AggregationValues = Object.freeze([\n\tnew Aggregation('Minute', 60),\n\tnew Aggregation('FiveMinute', 60 * 5),\n\tnew Aggregation('TenMinute', 60 * 10),\n\tnew Aggregation('FifteenMinute', 60 * 15),\n\tnew Aggregation('ThirtyMinute', 60 * 30),\n\tnew Aggregation('Hour', 3600),\n\tnew Aggregation('HourOfDay', 3600),\n\tnew Aggregation('SeasonalHourOfDay', 3600),\n\tnew Aggregation('Day', 86400),\n\tnew Aggregation('DayOfWeek', 86400),\n\tnew Aggregation('SeasonalDayOfWeek', 86400),\n\tnew Aggregation('Week', 604800),\n\tnew Aggregation('WeekOfYear', 604800),\n\tnew Aggregation('Month', 2419200),\n\tnew Aggregation('Year', 31536000),\n\tnew Aggregation('RunningTotal', Number.MAX_SAFE_INTEGER),\n]);\n\n/**\n * The enumeration of supported Aggregation values.\n * \n * @readonly\n * @enum {module:domain~Aggregation}\n * @property {module:domain~Aggregation} Minute minute\n * @property {module:domain~Aggregation} FiveMinute 5 minutes\n * @property {module:domain~Aggregation} TenMinute 10 minutes\n * @property {module:domain~Aggregation} FifeteenMinute 15 minutes\n * @property {module:domain~Aggregation} ThirtyMinute 30 minutes\n * @property {module:domain~Aggregation} Hour an hour\n * @property {module:domain~Aggregation} HourOfDay an hour of a day, e.g. 1-24\n * @property {module:domain~Aggregation} SeasonalHourOfDay an hour of a day, further grouped into 4 seasons\n * @property {module:domain~Aggregation} Day a day\n * @property {module:domain~Aggregation} DayOfWeek a day of the week, e.g. Monday - Sunday\n * @property {module:domain~Aggregation} SeasonalDayOfWeek a day of the week, further grouped into 4 seasons\n * @property {module:domain~Aggregation} Week a week\n * @property {module:domain~Aggregation} WeekOfYear the week within a year, e.g. 1 - 52\n * @property {module:domain~Aggregation} Month a month\n * @property {module:domain~Aggregation} Year a year\n * @property {module:domain~Aggregation} RunningTotal a complete running total over a time span\n * @alias module:domain~Aggregations\n */\nconst Aggregations = Aggregation.enumsValue(AggregationValues);\n\nexport default Aggregations;\nexport { Aggregation };","import Enum from '../util/enum';\n\n/**\n * An auth token status.\n * \n * @extends module:util~Enum\n * @alias module:domain~AuthTokenStatus\n */\nexport class AuthTokenStatus extends Enum {\n    /**\n     * Constructor.\n     * \n     * @param {string} name the name\n     */\n    constructor(name) {\n        super(name);\n        if ( this.constructor === AuthTokenStatus ) {\n            Object.freeze(this);\n        }\n    }\n\n    /**\n\t * Get the {@link module:domain~AuthTokenStatuses} values.\n\t * \n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn AuthTokenStatusValues;\n\t}\n\n}\n\nconst AuthTokenStatusValues = Object.freeze([\n\tnew AuthTokenStatus('Active'),\n    new AuthTokenStatus('Disabled'),\n]);\n\n/**\n * The enumeration of supported AuthTokenStatus values.\n * \n * @readonly\n * @enum {module:domain~AuthTokenStatus}\n * @property {module:domain~AuthTokenStatus} Active the token is active and usable\n * @property {module:domain~AuthTokenStatus} Disabled the token is disabled and not usable\n * @alias module:domain~AuthTokenStatuses\n */\nconst AuthTokenStatuses = AuthTokenStatus.enumsValue(AuthTokenStatusValues);\n\nexport default AuthTokenStatuses;\n","import Enum from '../util/enum';\n\n/**\n * A named auth token type.\n * \n * @extends module:util~Enum\n * @alias module:domain~AuthTokenType\n */\nexport class AuthTokenType extends Enum {\n    /**\n     * Constructor.\n     * \n     * @param {string} name the name\n     */\n    constructor(name) {\n        super(name);\n        if ( this.constructor === AuthTokenType ) {\n            Object.freeze(this);\n        }\n    }\n\n    /**\n\t * Get the {@link AuthTokenTypes} values.\n\t * \n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn AuthTokenTypeValues;\n\t}\n\n}\n\nconst AuthTokenTypeValues = Object.freeze([\n\tnew AuthTokenType('ReadNodeData'),\n    new AuthTokenType('User'),\n]);\n\n/**\n * The enumeration of supported AuthTokenType values.\n * \n * @readonly\n * @enum {module:domain~AuthTokenType}\n * @property {module:domain~AuthTokenType} ReadNodeData a read-only token for reading SolarNode data\n * @property {module:domain~AuthTokenType} User full access as the user that owns the token\n * @alias module:domain~AuthTokenTypes\n */\nconst AuthTokenTypes = AuthTokenType.enumsValue(AuthTokenTypeValues);\n\nexport default AuthTokenTypes;\n","import Enum from '../util/enum';\n\n/**\n * A named query combining action type.\n * \n * @extends module:util~Enum\n * @alias module:domain~CombiningType\n */\nexport class CombiningType extends Enum {\n\n\t/**\n     * Constructor.\n     * \n     * @param {string} name the unique name for this type \n     */\n    constructor(name) {\n\t\tsuper(name);\n\t\tif ( this.constructor === CombiningType ) {\n\t\t\tObject.freeze(this);\n\t\t}\n    }\n\n\t/**\n\t * Get the {@link module:domain~CombiningTypes} values.\n\t * \n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn CombiningTypeValues;\n\t}\n\n}\n\nconst CombiningTypeValues = Object.freeze([\n\tnew CombiningType('Average'),\n\tnew CombiningType('Sum'),\n]);\n\n/**\n * The enumeration of supported CombiningType values.\n * \n * @readonly\n * @enum {module:domain~CombiningType}\n * @property {module:domain~CombiningType} Average average\n * @property {module:domain~CombiningType} Sum sum\n * @alias module:domain~CombiningTypes\n */\nconst CombiningTypes = CombiningType.enumsValue(CombiningTypeValues);\n\nexport default CombiningTypes;\n","/**\n * A pagination criteria object.\n * @alias module:domain~Pagination\n */\nclass Pagination {\n\n    /**\n     * Construct a pagination object.\n     * \n     * @param {number} max the maximum number of results to return \n     * @param {number} [offset] the 0-based starting offset \n     */\n    constructor(max, offset) {\n        this._max = (max > 0 ? +max : 0);\n        this._offset = (offset > 0 ? +offset : 0);\n    }\n\n    /**\n     * Get the maximum number of results to return.\n     * \n     * @returns {number} the maximum number of results\n     */\n    get max() {\n        return this._max;\n    }\n\n    /**\n     * Get the results starting offset.\n     * \n     * The first available result starts at offset <code>0</code>. Note this is \n     * a raw offset value, not a \"page\" offset.\n     * \n     * @returns {number} the starting result offset\n     */\n    get offset() {\n        return this._offset;\n    }\n\n    /**\n     * Copy constructor with a new <code>offset</code> value.\n     * \n     * @param {number} offset the new offset to use\n     * @return {Pagination} a new instance\n     */\n    withOffset(offset) {\n        return new Pagination(this.max, offset);\n    }\n\n    /**\n     * Get this object as a standard URI encoded (query parameters) string value.\n     * \n     * @return {string} the URI encoded string\n     */\n    toUriEncoding() {\n        let result = '';\n        if ( this.max > 0 ) {\n            result += 'max=' +this.max;\n        }\n        if ( this.offset > 0 ) {\n            if ( result.length > 0 ) {\n                result += '&';\n            }\n            result += 'offset=' +this.offset;\n        }\n        return result;\n    }\n}\n\nexport default Pagination;\n","/**\n * A description of a sort applied to a property of a collection.\n * @alias module:domain~SortDescriptor\n */\nclass SortDescriptor {\n\n    /**\n     * Constructor.\n     * \n     * @param {string} key the property to sort on\n     * @param {boolean} [descending] `true` to sort in descending order, `false` for ascending\n     */\n    constructor(key, descending) {\n        this._key = key;\n        this._descending = !!descending;\n    }\n\n    /**\n     * Get the sort property name.\n     * \n     * @returns {string} the sort key\n     */\n    get key() {\n        return this._key;\n    }\n\n    /**\n     * Get the sorting direction.\n     * \n     * @returns {boolean} `true` if descending order, `false` for ascending\n     */\n    get descending() {\n        return this._descending;\n    }\n\n    /**\n     * Get this object as a standard URI encoded (query parameters) string value.\n     * \n     * If `index` is provided and non-negative, then the query parameters will\n     * be encoded as an array property named `sorts`. Otherwise just\n     * bare `key` and `descending` properties will be used. The \n     * `descending` property is only added if it is `true`.\n     * \n     * @param {number} [index] an optional array property index\n     * @param {string} [propertyName=sorts] an optional array property name, only used if `index` is also provided\n     * @return {string} the URI encoded string\n     */\n    toUriEncoding(index, propertyName) {\n        let result,\n            propName = (propertyName || 'sorts');\n        if ( index !== undefined && index >= 0 ) {\n            result = encodeURIComponent(propName +'[' +index +'].key') + '=';\n        } else {\n            result = 'key=';\n        }\n        result += encodeURIComponent(this.key);\n        if ( this.descending ) {\n            if ( index !== undefined && index >= 0 ) {\n                result += '&' +encodeURIComponent(propName +'[' +index +'].descending') + '=true';\n            } else {\n                result += '&descending=true';\n            }\n        }\n        return result;\n    }\n\n}\n\nexport default SortDescriptor;\n","import Pagination from '../domain/pagination';\nimport SortDescriptor from '../domain/sortDescriptor';\nimport Enum from './enum';\n\n/**\n * A basic map-like object.\n * \n * <p>This object includes some utility functions that make it well suited to using\n * as an API query object. For example, the {@link module:util~PropMap#toUriEncoding}\n * method provides a way to serialize this object into URL query parameters.</p>\n * \n * @alias module:util~PropMap\n */\nclass PropMap {\n    /**\n     * Constructor.\n     * @param {PropMap|object} props the initial properties; if a `PropMap` instance is provided, the properties\n     *                               of that object will be copied into this one; otherwise the object will be\n     *                               used directly to hold property values\n     */\n    constructor(props) {\n        /**\n         * The object that all properties are stored on. \n         * @member {object} \n         */\n        this.props = (props instanceof PropMap ? props.properties() : \n            typeof props === 'object' ? props : {});\n    }\n\n    /**\n\t * Get, set, or remove a property value.\n\t *\n\t * @param {string} key the key to get or set the value for\n\t * @param {*} [newValue] if defined, the new value to set for the given `key`;\n\t *                       if `null` then the `key` property will be removed\n\t * @returns {*} if called as a getter, the associated value for the given `key`,\n\t *              otherwise this object\n\t */\n\tprop(key, newValue) {\n\t\tif ( arguments.length === 1 ) {\n\t\t\treturn this.props[key];\n\t\t}\n\t\tif ( newValue === null ) {\n\t\t\tdelete this.props[key];\n\t\t} else {\n\t\t\tthis.props[key] = newValue;\n\t\t}\n\t\treturn this;\n\t}\n\n    /**\n\t * Get, set, or remove multiple properties.\n\t * \n\t * @param {object} [newProps] the new values to set; if any value is `null` that property\n     *                            will be deleted\n\t * @returns {object} if called as a getter, all properties of this object copied into a \n     *                   simple object; otherwise this object\n\t */\n\tproperties(newProps) {\n\t\tif ( newProps ) {\n\t\t\tfor ( const k of Object.keys(newProps) ) {\n\t\t\t\tthis.prop(k, newProps[k]);\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\t\treturn Object.assign({}, this.props);\n\t}\n\n    /**\n     * Get this object as a standard URI encoded (query parameters) string value.\n     * \n     * All enumerable properties of the <code>props</code> property will be added to the\n     * result. If any property value is an array, the values of the array will be joined\n     * by a comma. Any {@link module:util~Enum} values will have their `name` property used.\n     * Any value that has a `toUriEncoding()` function property will have that function\n     * invoked, passing the associated property name as the first argument, and the returned\n     * value will be used.\n     * \n     * @param {string} [propertyName] an optional object property prefix to add to all properties\n     * @param {function} [callbackFn] An optional function that will be called for each property.\n     *                   The function will be passed property name and value arguments, and must\n     *                   return either `null` to skip the property, a 2 or 3-element array with the\n     *                   property name and value to use, and an optional boolean to force array\n     *                   values to use mutliple parameter keys. Any other return value causes the\n     *                   property to be used as- is.\n     * @return {string} the URI encoded string\n     */\n    toUriEncoding(propertyName, callbackFn) {\n        let result = '';\n        for ( let k of Object.keys(this.props) ) {\n            if ( result.length > 0 ) {\n                result += '&';\n            }\n            let v = this.props[k];\n            let forceMultiKey = false;\n            if ( callbackFn ) {\n                const kv = callbackFn(k, v);\n                if ( kv === null ) {\n                    continue;\n                } else if ( Array.isArray(kv) && kv.length > 1 ) {\n                    k = kv[0];\n                    v = kv[1];\n                    if ( kv.length > 2 ) {\n                        forceMultiKey = !!kv[2];\n                    }\n                }\n            }\n            \n            if ( typeof v.toUriEncoding === 'function' ) {\n                result += v.toUriEncoding(propertyName ? encodeURIComponent(propertyName) + '.' + k : k);\n                continue;\n            }\n            \n            if ( propertyName ) {\n                result += encodeURIComponent(propertyName) + '.';\n            }\n            result += encodeURIComponent(k) + '=';\n            if ( Array.isArray(v) ) {\n                v.forEach(function(e, i) {\n                    if ( i > 0 ) {\n                        result += (forceMultiKey ? '&' + encodeURIComponent(k) + '=' : ',');\n                    }\n                    if ( e instanceof Enum ) {\n                        e = e.name;\n                    }\n                    result += encodeURIComponent(e);\n                });\n            } else {\n                if ( v instanceof Enum ) {\n                    v = v.name;\n                }\n                result += encodeURIComponent(v);\n            }\n        }\n        return result;\n    }\n\n\n    /**\n     * Get this object as a standard URI encoded (query parameters) string value with\n     * sorting and pagination parameters.\n     * \n     * <p>This calls {@link module:util~PropMap#toUriEncoding} first, then encodes \n     * the `sorts` and `pagination` parameters, if provided.\n     * \n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n     * @param {string} [propertyName] an optional object property prefix to add to all properties\n     * @param {function} [callbackFn] An optional function that will be called for each property.\n     *                   The function will be passed property name and value arguments, and must\n     *                   return either `null` to skip the property, a 2-element array with the property\n     *                   name and value to use, or anything else to use the property as- is.\n     * @return {string} the URI encoded string\n     */\n    toUriEncodingWithSorting(sorts, pagination, propertyName, callbackFn) {\n        let params = this.toUriEncoding(propertyName, callbackFn);\n        if ( Array.isArray(sorts) ) {\n            sorts.forEach((sort, i) => {\n                if ( sort instanceof SortDescriptor ) {\n                    if ( params.length > 0 ) {\n                        params += '&';\n                    }\n                    params += sort.toUriEncoding(i);\n                }\n            });\n        }\n        if ( pagination instanceof Pagination ) {\n            const paginationParams = pagination.toUriEncoding();\n            if ( paginationParams ) {\n                if ( params.length > 0 ) {\n                    params += '&';\n                }\n                params += paginationParams;\n            }\n        }\n        return params;\n    }\n\n}\n\nexport default PropMap;\n","import PropMap from '../util/propMap';\n\nconst CountryKey = 'country';\nconst ElevationKey = 'elevation';\nconst LatitudeKey = 'latitude';\nconst IdKey = 'id';\nconst LocalityKey = 'locality';\nconst LongitudeKey = 'longitude';\nconst NameKey = 'name';\nconst PostalCodeKey = 'postalCode';\nconst RegionKey = 'region';\nconst StateOrProvinceKey = 'stateOrProvince';\nconst StreetKey = 'street';\nconst TimeZoneIdKey = 'timeZoneId';\n\n/**\n * A geographic location.\n * \n * @extends module:util~PropMap\n * @alias module:domain~Location\n */\nclass Location extends PropMap {\n\n    /**\n\t * Constructor.\n\t * \n\t * @param {module:domain~Location|object} loc the location to copy properties from\n\t */\n\tconstructor(loc) {\n        super(loc);\n   }\n    \n    /**\n     * A SolarNetwork assigned unique identifier.\n     * @type {number}\n     */\n    get id() {\n        return this.prop(IdKey);\n    }\n\n    set id(val) {\n        this.prop(IdKey, val);\n    }\n\n    /**\n     * A generalized name, can be used for \"virtual\" locations.\n     * @type {string}\n     */\n    get name() {\n        return this.prop(NameKey);\n    }\n\n    set name(val) {\n        this.prop(NameKey, val);\n    }\n\n    /**\n     * An ISO 3166-1 alpha-2 character country code.\n     * @type {string}\n     */\n    get country() {\n        return this.prop(CountryKey);\n    }\n\n    set country(val) {\n        this.prop(CountryKey, val);\n    }\n\n    /**\n     * A country-specific regional identifier.\n     * @type {string}\n     */\n    get region() {\n        return this.prop(RegionKey);\n    }\n\n    set region(val) {\n        this.prop(RegionKey, val);\n    }\n\n    /**\n     * A country-specific state or province identifier.\n     * @type {string}\n     */\n    get stateOrProvince() {\n        return this.prop(StateOrProvinceKey);\n    }\n\n    set stateOrProvince(val) {\n        this.prop(StateOrProvinceKey, val);\n    }\n\n    /**\n     * Get the locality (city, town).\n     * @type {string}\n     */\n    get locality() {\n        return this.prop(LocalityKey);\n    }\n\n    set locality(val) {\n        this.prop(LocalityKey, val);\n    }\n\n    /**\n     * A country-specific postal code.\n     * @type {string}\n     */\n    get postalCode() {\n        return this.prop(PostalCodeKey);\n    }\n\n    set postalCode(val) {\n        this.prop(PostalCodeKey, val);\n    }\n\n    /**\n     * The street address.\n     * @type {string}\n     */\n    get street() {\n        return this.prop(StreetKey);\n    }\n\n    set street(val) {\n        this.prop(StreetKey, val);\n    }\n\n    /**\n     * The decimal world latitude.\n     * @type {number}\n     */\n    get latitude() {\n        return this.prop(LatitudeKey);\n    }\n\n    set latitude(val) {\n        this.prop(LatitudeKey, val);\n    }\n\n    /**\n     * The decimal world longitude.\n     * @type {number}\n     */\n    get longitude() {\n        return this.prop(LongitudeKey);\n    }\n\n    set longitude(val) {\n        this.prop(LongitudeKey, val);\n    }\n\n    /**\n     * The elevation above sea level, in meters.\n     * @type {number}\n     */\n    get elevation() {\n        return this.prop(ElevationKey);\n    }\n\n    set elevation(val) {\n        this.prop(ElevationKey, val);\n    }\n\n    /**\n     * A time zone ID, for example `Pacific/Auckland`.\n     * @type {string}\n     */\n    get timeZoneId() {\n        return this.prop(TimeZoneIdKey)\n    }\n\n    set timeZoneId(val) {\n        this.prop(TimeZoneIdKey, val);\n    }\n\n}\n\nexport default Location;\n","import Enum from '../util/enum';\n\n/**\n * An enumeration of datum reading types.\n * \n * @extends module:util~Enum\n * @alias module:domain~DatumReadingType\n */\nexport class DatumReadingType extends Enum {\n\n\t/**\n     * Constructor.\n     * \n     * @param {string} name the unique name for this type\n     * @param {string} key the key value associated with this type\n     */\n    constructor(name, key) {\n        super(name);\n        this._key = key;\n\t\tif ( this.constructor === DatumReadingType ) {\n\t\t\tObject.freeze(this);\n\t\t}\n    }\n\n    /**\n     * Get the key value.\n     * \n     * @returns {string} the key value\n     */\n    get key() {\n        return this._key;\n    }\n\n\t/**\n\t * Get the {@link module:domain~DatumReadingType} values.\n\t * \n\t * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn DatumReadingTypeValues;\n\t}\n\n}\n\nconst DatumReadingTypeValues = Object.freeze([\n\tnew DatumReadingType('CalculatedAt', 'at'),\n    new DatumReadingType('CalculatedAtDifference', 'atd'),\n    new DatumReadingType('NearestDifference', 'diff')\n]);\n\n/**\n * The enumeration of supported `DatumReadingType` values.\n * \n * @readonly\n * @enum {module:domain~DatumReadingType}\n * @property {module:domain~DatumReadingType} CalculatedAt Derive a single reading value based\n * from one datum the nearest before a specific time and one the nearest after.\n * @property {module:domain~DatumReadingType} CalculatedAtDifference Calculate the difference \n * between two reading values on two dates, using the `CalcualtedAt` style of deriving the start\n * and end readings.\n * @property {module:domain~DatumReadingType} NearestDifference Find the difference between two \n * datum that are nearest in time on or before two dates.\n * @alias module:domain~DatumReadingTypes\n */\nconst DatumReadingTypes = DatumReadingType.enumsValue(DatumReadingTypeValues);\n\nexport default DatumReadingTypes;\n","import Enum from '../util/enum';\n\n/**\n * A named instruction state.\n * \n * @extends module:util~Enum\n * @alias module:domain~InstructionState\n */\nclass InstructionState extends Enum {\n\n    /**\n     * Constructor.\n     * \n     * @param {string} name the name\n     */\n    constructor(name) {\n        super(name);\n        if ( this.constructor === InstructionState ) {\n            Object.freeze(this);\n        }\n    }\n\n    /**\n\t * Get the {@link module:domain~InstructionStates} values.\n\t * \n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn InstructionStateValues;\n\t}\n\n}\n\nconst InstructionStateValues = Object.freeze([\n\tnew InstructionState('Unknown'),\n\tnew InstructionState('Queued'),\n    new InstructionState('Received'),\n    new InstructionState('Executing'),\n    new InstructionState('Declined'),\n    new InstructionState('Completed'),\n]);\n\n/**\n * The enumeration of supported InstructionState values.\n * \n * @readonly\n * @enum {module:domain~InstructionState}\n * @property {module:domain~InstructionState} Unknown an unknown state\n * @property {module:domain~InstructionState} Queued the instruction has been received by SolarNet but not yet delivered to its destination\n * @property {module:domain~InstructionState} Received the instruction has been delivered to its destination but not yet acted upon\n * @property {module:domain~InstructionState} Executed the instruction is currently being acted upon\n * @property {module:domain~InstructionState} Declined the destination has declined to execute the instruction, or the execution failed\n * @property {module:domain~InstructionState} Completed the destination has executed successfully\n * @alias module:domain~InstructionStates\n */\nconst InstructionStates = InstructionState.enumsValue(InstructionStateValues);\n\nexport default InstructionStates;\nexport { InstructionState };","import ComparableEnum from '../util/comparableEnum';\n\n/**\n * A location precision object for use with defining named geographic precision.\n * \n * @extends module:util~ComparableEnum\n * @alias module:domain~LocationPrecision\n */\nclass LocationPrecision extends ComparableEnum {\n\n    /**\n     * Constructor.\n     * \n     * @param {string} name the unique name for this precision \n     * @param {number} precision a relative precision value for this precision \n     */\n    constructor(name, precision) {\n        super(name, precision);\n        if ( this.constructor === LocationPrecision ) {\n            Object.freeze(this);\n        }\n    }\n\n    /**\n     * Get the relative precision value.\n     * \n     * This is an alias for {@link #name}.\n     * \n     * @returns {number} the precision\n     */\n    get precision() {\n        return this.value;\n    }\n\n\t/**\n\t * Get the {@link module:domain~LocationPrecisions} values.\n\t * \n     * @override\n\t * @inheritdoc\n\t */\n\tstatic enumValues() {\n\t\treturn LocationPrecisionValues;\n\t}\n}\n\nconst LocationPrecisionValues = Object.freeze([\n    new LocationPrecision('LatLong', 1),\n    new LocationPrecision('Block', 5),\n    new LocationPrecision('Street', 10),\n    new LocationPrecision('PostalCode', 20),\n    new LocationPrecision('Locality', 30),\n    new LocationPrecision('StateOrProvince', 40),\n    new LocationPrecision('Region', 50),\n    new LocationPrecision('TimeZone', 60),\n    new LocationPrecision('Country', 70),\n]);\n\n/**\n * The enumeration of supported LocationPrecision values.\n * \n * @readonly\n * @enum {module:domain~LocationPrecision}\n * @property {module:domain~LocationPrecision} LatLong GPS coordinates\n * @property {module:domain~LocationPrecision} Block a city block\n * @property {module:domain~LocationPrecision} Street a street\n * @property {module:domain~LocationPrecision} PostalCode a postal code (or \"zip code\")\n * @property {module:domain~LocationPrecision} Locality a town or city\n * @property {module:domain~LocationPrecision} StateOrProvince a state or province\n * @property {module:domain~LocationPrecision} Region a large region\n * @property {module:domain~LocationPrecision} TimeZone a time zone\n * @property {module:domain~LocationPrecision} Country a country\n * @alias module:domain~LocationPrecisions\n */\nconst LocationPrecisions = LocationPrecision.enumsValue(LocationPrecisionValues);\n\nexport default LocationPrecisions;\nexport { LocationPrecision };","import MultiMap from '../util/multiMap';\n\nconst HttpMethod = Object.freeze(\t\n\t/**\n\t * Enumeration of HTTP methods (verbs).\n\t * @enum {string}\n\t * @alias module:net~HttpMethod\n\t * @constant\n\t */\n\t{\n\tGET: 'GET',\n\tHEAD: 'HEAD',\n\tPOST: 'POST',\n\tPUT: 'PUT',\n\tPATCH: 'PATCH',\n\tDELETE: 'DELETE',\n\tOPTIONS: 'OPTIONS',\n\tTRACE: 'TRACE',\n});\n\nconst HttpContentType = Object.freeze(\t\n\t/**\n\t * Enumeration of common HTTP `Content-Type` values.\n\t * @enum {string}\n\t * @alias module:net~HttpContentType\n\t * @constant\n\t */\n\t{\n\t\tAPPLICATION_JSON:\t\t'application/json',\n\t\tAPPLICATION_JSON_UTF8:\t'application/json; charset=UTF-8',\n\t\tFORM_URLENCODED: \t\t'application/x-www-form-urlencoded',\n\t\tFORM_URLENCODED_UTF8:\t'application/x-www-form-urlencoded; charset=UTF-8',\n});\n\n/**\n * Support for HTTP headers.\n * \n * @extends module:util~MultiMap\n * @alias module:net~HttpHeaders\n */\nclass HttpHeaders extends MultiMap {\n\tconstructor() {\n\t\tsuper();\n\t}\n\n}\n\nObject.defineProperties(HttpHeaders, {\n\t/**\n\t * The `Authorization` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'AUTHORIZATION':\t{ value: 'Authorization' },\n\n\t/**\n\t * The `Content-MD5` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'CONTENT_MD5':\t\t{ value: 'Content-MD5' },\n\n\t/**\n\t * The `Content-Type` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'CONTENT_TYPE': \t{ value: 'Content-Type' },\n\n\t/**\n\t * The `Date` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'DATE':\t\t\t\t{ value: 'Date' },\n\n\t/**\n\t * The `Digest` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'DIGEST':\t\t\t{ value: 'Digest' },\n\n\t/**\n\t * The `Host` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'HOST': \t\t\t{ value: 'Host' },\n\n\t/**\n\t * The `X-SN-Date` header.\n\t * \n\t * @memberof module:net~HttpHeaders\n\t * @readonly\n\t * @type {string}\n\t */\n\t'X_SN_DATE': \t\t{ value: 'X-SN-Date' },\n});\n\nexport default HttpHeaders;\nexport { HttpContentType, HttpMethod };","import Configuration from '../util/configuration';\nimport Environment from './environment';\n\n/**\n * A utility class for helping to compose SolarNet URLs for the REST API.\n *\n * This class is essentially abstract and meant to have mixin helper objects extend it.\n * @alias module:net~UrlHelper\n */\nclass UrlHelper {\n\n    /**\n     * Constructor.\n     *\n     * @param {module:net~Environment|object} [environment] the optional initial environment to use;\n     *        if a non-`Environment` object is passed then the properties of that object will\n     *        be used to construct a new `Environment` instance\n     */\n    constructor(environment) {\n        let env = (environment instanceof Environment ? environment\n            : new Environment(environment));\n        \n        /**\n         * The environment associated with this helper.\n         * @member {module:net~Environment}\n         */\n        this.environment = env;\n\n        this._parameters = new Configuration();\n    }\n\n    /**\n     * Get a parameters object that can be used to hold URL variables.\n     * \n     * @readonly\n     * @type {module:util~Configuration}\n     */\n    get parameters() {\n        return this._parameters;\n    }\n\n    /**\n     * Get or set an environment parameter.\n     * \n     * This is a shortcut for calling {@link module:net~Configuration#value} on the\n     * `environment` object.\n     * \n     * @param {string} key the environment parameter name to get\n     * @param {object} [val] the optional value to set\n     * @returns {object} when called as a getter, the environment parameter value;\n     *                   when called as a setter, the environment parameters object\n     */\n    env(...args) {\n        return this.environment.value(...args);\n    }\n\n    /**\n     * Get or set a parameter.\n     * \n     * This is a shortcut for calling {@link module:net~Configuration#value} on the\n     * `parameters` object.\n     * \n     * @param {string} key the parameter name to get\n     * @param {Object} [val] the optional value to set\n     * @returns {Object} when called as a getter, the parameter value;\n     *                   when called as a setter, the parameters object\n     */\n    parameter(...args) {\n        return this._parameters.value(...args);\n    }\n\n    /**\n     * Get a URL for just the SolarNet host, without any path.\n     *\n     * @returns {string} the URL to the SolarNet host\n     */\n    hostUrl() {\n        const tls = this.environment.useTls();\n        const port = +this.environment.value('port');\n\t\tlet url = 'http' +(tls ? 's' : '') +'://' +this.environment.value('host');\n        if ( (tls && port > 0 && port !== 443) || (!tls && port > 0 && port !== 80) ) {\n            url += ':' +port;\n        }\n        return url;\n    }\n    \n    /**\n     * Get a URL for just the SolarNet host using the WebSocket protocol, without any path.\n     * \n     * @returns {string} the URL to the SolarNet host WebSocket\n     */\n    hostWebSocketUrl() {\n        const tls = this.environment.useTls();\n        const port = +this.environment.value('port');\n\t\tlet url = 'ws' +(tls ? 's' : '') +'://' +this.environment.value('host');\n        if ( (tls && port > 0 && port !== 443) || (!tls && port > 0 && port !== 80) ) {\n            url += ':' +port;\n        }\n        return url;\n    }\n\n\t/**\n\t * Get the base URL to the REST API.\n\t * \n\t * This implementation is a stub, meant for subclasses to override. This implementation\n     * simply returns {@link module:net~UrlHelper#hostUrl}.\n\t * \n     * @abstract\n\t * @returns {string} the base URL to the REST API\n\t */\n\tbaseUrl() {\n\t\treturn this.hostUrl();\n\t}\n\n    /**\n     * Replace occurances of URL template variables with values from the `parameters`\n     * property and append to the host URL.\n     * \n     * This method provides a way to resolve an absolute URL based on the configured\n     * environment and parameters on this object.\n     * \n     * @param {string} template a URL path template\n     * @returns {string} an absolute URL\n     * @see module:net~UrlHelper#resolveTemplateUrl\n     */\n    resolveTemplatePath(template) {\n        return this.hostUrl() + this.resolveTemplateUrl(template);\n    }\n\n     /**\n     * Replace occurances of URL template variables with values from the `parameters`\n     * property.\n     * \n     * URL template variables are specified as `{<em>name</em>}`. The variable\n     * will be replaced by the value associated with property `name` in the\n     * `parameters` object. The value will be URI encoded.\n     * \n     * @param {string} template a URL template\n     * @returns {string} the URL with template variables resolved\n     */\n   resolveTemplateUrl(template) {\n        return UrlHelper.resolveTemplateUrl(template, this._parameters);\n    }\n\n    /**\n     * Replace occurances of URL template variables with values from a parameter object.\n     * \n     * URL template variables are specified as `{<em>name</em>}`. The variable\n     * will be replaced by the value associated with property `name` in the\n     * provided parameter object. The value will be URI encoded.\n     * \n     * @param {string} template a URL template\n     * @param {object} params an object whose properties should serve as template variables\n     * @returns {string} the URL\n     */\n    static resolveTemplateUrl(template, params) {\n        return template.replace(/\\{([^}]+)\\}/g, function(match, variableName) {\n            let variableValue = params[variableName];\n            return (variableValue !== undefined ? encodeURIComponent(variableValue) : '');\n        });\n    }\n\n}\n\nexport default UrlHelper;\n","const LocationIdsKey = 'locationIds';\nconst SourceIdsKey = 'sourceIds';\n\n/**\n * Create a LocationUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~LocationUrlHelperMixin} the mixin class\n */\nconst LocationUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds support for SolarLocation properties to a {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~LocationUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * The first available location ID from the `locationIds` property.\n     * Setting this replaces any existing location IDs with an array of just that value.\n     * @type {number}\n     */\n    get locationId() {\n        const locationIds = this.locationIds;\n        return (Array.isArray(locationIds) && locationIds.length > 0 ? locationIds[0] : null);\n    }\n\n    set locationId(locationId) {\n        this.parameter(LocationIdsKey, locationId ? [locationId] : null);\n    }\n\n    /**\n     * An array of location IDs, set on the `locationIds` parameter\n     * @type {number[]}\n     */\n    get locationIds() {\n        return this.parameter(LocationIdsKey);\n    }\n\n    set locationIds(locationIds) {\n        this.parameter(LocationIdsKey, locationIds);\n    }\n\n    /**\n     * The first available source ID from the `sourceIds` property.\n     * Setting this replaces any existing location IDs with an array of just that value.\n     * @type {string}\n     */\n    get sourceId() {\n        const sourceIds = this.sourceIds;\n        return (Array.isArray(sourceIds) && sourceIds.length > 0 ? sourceIds[0] : null);\n    }\n\n    set sourceId(sourceId) {\n        this.parameter(SourceIdsKey, sourceId ? [sourceId] : sourceId);\n    }\n\n    /**\n     * An array of source IDs, set on the `sourceIds` parameter\n     * @type {string[]}\n     */\n    get sourceIds() {\n        return this.parameter(SourceIdsKey);\n    }\n\n    set sourceIds(sourceIds) {\n        this.parameter(SourceIdsKey, sourceIds);\n    }\n\n    /**\n     * Generate a URL to find locations based on a search criteria.\n     * \n     * @param {module:domain~Location} filter the search criteria\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n     * @returns {string} the generated URL\n     */\n    findLocationsUrl(filter, sorts, pagination) {\n        return this.baseUrl() + '/location?' +filter.toUriEncodingWithSorting(sorts, pagination);\n    }\n\n}\n\nexport default LocationUrlHelperMixin;\n","/** \n * The SolarQuery default path.\n * @type {string}\n * @alias module:net~SolarQueryDefaultPath\n */\nexport const SolarQueryDefaultPath = '/solarquery';\n\n/** \n * The {@link module:net~UrlHelper#parameters} key for the SolarQuery path.\n * @type {string}\n * @alias module:net~SolarQueryPathKey\n */\nexport const SolarQueryPathKey = 'solarQueryPath';\n\n/** \n * The SolarQuery REST API path.\n * @type {string}\n * @alias module:net~SolarQueryApiPathV1\n */\nexport const SolarQueryApiPathV1 = '/api/v1';\n\n/** \n * The {@link module:net~UrlHelper#parameters} key that holds a `boolean` flag to\n * use the public path scheme (`/pub`) when constructing URLs.\n * @type {string}\n * @alias module:net~SolarQueryPublicPathKey\n */\nexport const SolarQueryPublicPathKey = 'publicQuery';\n\n/**\n * Create a QueryUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~QueryUrlHelperMixin} the mixin class\n */\nconst QueryUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarQuery specific support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~QueryUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * Flag to set the `publicQuery` environment parameter.\n     * @type {boolean}\n     */\n    get publicQuery() {\n        return !!this.env(SolarQueryPublicPathKey);\n    }\n\n    set publicQuery(value) {\n        this.env(SolarQueryPublicPathKey, !!value);\n    }\n\n\t/**\n\t * Get the base URL to the SolarQuery v1 REST API.\n\t * \n\t * The returned URL uses the configured environment to resolve\n\t * the `hostUrl`, the `solarQueryPath` context path,\n     * and the `publicQuery` boolean flag. If the context path is not \n     * available, it will default to `/solarquery`.\n\t * \n\t * @returns {string} the base URL to SolarQuery\n\t */\n\tbaseUrl() {\n\t\tconst path = this.env(SolarQueryPathKey) || SolarQueryDefaultPath;\n        const isPubPath = this.publicQuery;\n\t\treturn this.hostUrl() + path + SolarQueryApiPathV1\n            +(isPubPath ? '/pub' : '/sec');\n\t}\n\n};\n\nexport default QueryUrlHelperMixin;\n","import UrlHelper from './urlHelper';\nimport LocationUrlHelperMixin from './locationUrlHelperMixin';\nimport QueryUrlHelperMixin from './queryUrlHelperMixin'\n\n/**\n * Create a LocationDatumMetadataUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~LocationDatumMetadataUrlHelperMixin} the mixin class\n */\nconst LocationDatumMetadataUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarNode datum metadata support to {@link module:net~UrlHelper}.\n * \n * <p>Location datum metadata is metadata associated with a specific location and source, i.e. \n * a `locationId` and a `sourceId`.\n * \n * @mixin\n * @alias module:net~LocationDatumMetadataUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * Get a base URL for location datum metadata operations using a specific location ID.\n     * \n     * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n     * @returns {string} the base URL\n     * @private\n     */\n    baseLocationDatumMetadataUrl(locationId) {\n        return this.baseUrl() + '/location/meta/' +(locationId || this.locationId);\n    }\n\n    locationDatumMetadataUrlWithSource(locationId, sourceId) {\n        let result = this.baseLocationDatumMetadataUrl(locationId);\n        let source = (sourceId || this.sourceId);\n        if ( sourceId !== null && source ) {\n            result += '?sourceId=' +encodeURIComponent(source);\n        }\n        return result;\n    }\n\n\t/**\n\t * Generate a URL for viewing datum metadata.\n     * \n     * If no `sourceId` is provided, then the API will return all available datum metadata for all sources.\n\t *\n\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; \n     *                            if not provided the `sourceId` property of this class will be used;\n     *                            if `null` then ignore any `sourceId` property of this class\n     * @returns {string} the URL\n\t */\n\tviewLocationDatumMetadataUrl(locationId, sourceId) {\n        return this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n    }\n    \n\t/**\n\t * Generate a URL for adding (merging) datum metadata via a `POST` request.\n     * \n\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; if not provided the `sourceId` property of this class will be used\n     * @returns {string} the URL\n\t */\n    addLocationDatumMetadataUrl(locationId, sourceId) {\n        return this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n    }\n\n\t/**\n\t * Generate a URL for setting datum metadata via a `PUT` request.\n     * \n\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; if not provided the `sourceId` property of this class will be used\n     * @returns {string} the URL\n\t */\n    replaceLocationDatumMetadataUrl(locationId, sourceId) {\n        return this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n    }\n\n\t/**\n\t * Generate a URL for deleting datum metadata via a `DELETE` request.\n     * \n\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; if not provided the `sourceId` property of this class will be used\n     * @returns {string} the URL\n\t */\n    deleteLocationDatumMetadataUrl(locationId, sourceId) {\n        return this.locationDatumMetadataUrlWithSource(locationId, sourceId);\n    }\n\n\t/**\n\t * Generate a URL for searching for location metadata.\n\t * \n     * @param {module:domain~DatumFilter} [filter] a search filter; the `locationIds`, `sourceIds`, `tags`,\n\t *                                    `query`, and `location` properties are supported \n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tfindLocationDatumMetadataUrl(filter, sorts, pagination) {\n\t\tlet result = this.baseUrl() + '/location/meta'\n\t\tlet params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~LocationDatumMetadataUrlHelperMixin},  \n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~LocationUrlHelperMixin} mixins.\n * \n * @mixes module:net~LocationDatumMetadataUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~LocationUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~LocationDatumMetadataUrlHelper\n */\nclass LocationDatumMetadataUrlHelper extends LocationDatumMetadataUrlHelperMixin(QueryUrlHelperMixin(LocationUrlHelperMixin(UrlHelper))) {\n\n}\n\nexport default LocationDatumMetadataUrlHelperMixin;\nexport { LocationDatumMetadataUrlHelper };\n","import { dateTimeUrlFormat } from '../format/date';\nimport UrlHelper from './urlHelper';\nimport LocationUrlHelperMixin from './locationUrlHelperMixin';\nimport QueryUrlHelperMixin from './queryUrlHelperMixin';\n\n/**\n * Create a LocationDatumUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~LocationDatumUrlHelperMixin} the mixin class\n */\nconst LocationDatumUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarLocation datum query support to {@link module:net~UrlHelper}.\n * \n * <p>This mixin is commonly mixed with the {@link module:net~QueryUrlHelperMixin} to pick\n * up support for the SolarQuery base URL.</p>\n * \n * <p>This mixin is commonly mixed with the {@link module:net~LocationUrlHelperMixin} to\n * pick up support for `locationId` and `sourceId` properties.</p>\n * \n * @mixin\n * @alias module:net~LocationDatumUrlHelperMixin\n */\nclass extends superclass {\n\n\t/**\n\t * Generate a URL for the \"reportable interval\" for a location, optionally limited to a specific source ID.\n\t *\n     * If no source IDs are provided, then the reportable interval query will return an interval for\n     * all available sources.\n     *\n\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId` property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to limit query to; \n     *                 if not provided the `sourceId` property of this class will be used;\n     *                 if `null` the `sourceId` property of this class will be ignored\n\t * @returns {string} the URL\n\t */\n\treportableIntervalUrl(locationId, sourceId) {\n        let url = this.baseUrl() +'/location/datum/interval?locationId=' \n            +(locationId || this.locationId);\n        let source = (sourceId || this.sourceId);\n\t\tif ( sourceId !== null && source ) {\n\t\t\turl += '&sourceId=' + encodeURIComponent(source);\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Generate a URL for finding the available source IDs for a location or metadata filter.\n\t * \n\t * @param {number} [locationId] a specific location ID to use; if not provided the `locationId`\n     *                              property of this class will be used\n\t * @param {Date} [startDate] a start date to limit the search to\n     * @param {Date} [endDate] an end date to limit the search to\n\t * @returns {string} the URL\n\t */\n\tavailableSourcesUrl(locationId, startDate, endDate) {\n\t\tlet result = this.baseUrl() + '/location/datum/sources?locationId='\n            +(locationId || this.locationId);\n        if ( startDate instanceof Date ) {\n            result += '&start=' +encodeURIComponent(dateTimeUrlFormat(startDate));\n        }\n        if ( endDate instanceof Date ) {\n            result += '&end=' +encodeURIComponent(dateTimeUrlFormat(endDate));\n        }\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generate a URL for querying for location datum, in either raw or aggregate form.\n\t * \n\t * If the `datumFilter` has an `aggregate` value set, then aggregate results will be\n\t * returned by SolarNet.\n\t * \n\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tlistDatumUrl(datumFilter, sorts, pagination) {\n\t\tlet result = this.baseUrl() + '/location/datum/list';\n\t\tlet params = (datumFilter ? datumFilter.toUriEncodingWithSorting(sorts, pagination) : '');\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generate a URL for querying for the most recent datum.\n\t * \n\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tmostRecentDatumUrl(datumFilter, sorts, pagination) {\n\t\tlet result = this.baseUrl() + '/location/datum/mostRecent';\n\t\tlet params = (datumFilter ? datumFilter.toUriEncodingWithSorting(sorts, pagination) : '');\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~LocationDatumUrlHelperMixin}, \n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~LocationUrlHelperMixin} mixins.\n * \n * @mixes module:net~LocationDatumUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~LocationUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~LocationDatumUrlHelper\n */\nclass LocationDatumUrlHelper extends LocationDatumUrlHelperMixin(QueryUrlHelperMixin(LocationUrlHelperMixin(UrlHelper))) {\n\n}\n\nexport default LocationDatumUrlHelperMixin;\nexport { LocationDatumUrlHelper };\n","const NodeIdsKey = 'nodeIds';\nconst SourceIdsKey = 'sourceIds';\n\n/**\n * Create a NodeUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeUrlHelperMixin} the mixin class\n */\nconst NodeUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds support for SolarNode properties to a {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~NodeUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * The first available node ID from the `nodeIds` property.\n     * Setting this replaces any existing node IDs with an array of just that value.\n     * @type {number}\n     */\n    get nodeId() {\n        const nodeIds = this.nodeIds;\n        return (Array.isArray(nodeIds) && nodeIds.length > 0 ? nodeIds[0] : null);\n    }\n\n    set nodeId(nodeId) {\n        this.parameter(NodeIdsKey, nodeId ? [nodeId] : null);\n    }\n\n    /**\n     * An array of node IDs, set on the `nodeIds` parameter\n     * @type {number[]}\n     */\n    get nodeIds() {\n        return this.parameter(NodeIdsKey);\n    }\n\n    set nodeIds(nodeIds) {\n        this.parameter(NodeIdsKey, nodeIds);\n    }\n\n    /**\n     * The first available source ID from the `sourceIds` property.\n     * Setting this replaces any existing node IDs with an array of just that value.\n     * @type {string}\n     */\n    get sourceId() {\n        const sourceIds = this.sourceIds;\n        return (Array.isArray(sourceIds) && sourceIds.length > 0 ? sourceIds[0] : null);\n    }\n\n    set sourceId(sourceId) {\n        this.parameter(SourceIdsKey, sourceId ? [sourceId] : sourceId);\n    }\n\n    /**\n     * An array of source IDs, set on the `sourceIds` parameter\n     * @type {string[]}\n     */\n    get sourceIds() {\n        return this.parameter(SourceIdsKey);\n    }\n\n    set sourceIds(sourceIds) {\n        this.parameter(SourceIdsKey, sourceIds);\n    }\n\n\t/**\n\t * Generate a URL to get a list of all active node IDs available to the requesting user.\n     * \n     * **Note** this method only works against the `/sec` version of the API endpoint.\n\t *\n\t * @return {string} the URL to access the node IDs the requesting user has access to\n\t */\n\tlistAllNodeIdsUrl() {\n\t\treturn this.baseUrl() + '/nodes';\n\t}\n    \n}\n\nexport default NodeUrlHelperMixin;\n","import Pagination from '../domain/pagination';\nimport SortDescriptor from '../domain/sortDescriptor';\nimport UrlHelper from './urlHelper';\nimport NodeUrlHelperMixin from './nodeUrlHelperMixin';\nimport QueryUrlHelperMixin from './queryUrlHelperMixin'\n\n\n/**\n * Create a NodeDatumUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeDatumMetadataUrlHelperMixin} the mixin class\n */\nconst NodeDatumMetadataUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarNode datum metadata support to {@link module:net~UrlHelper}.\n * \n * <p>Datum metadata is metadata associated with a specific node and source, i.e. \n * a <code>nodeId</code> and a <code>sourceId</code>.\n * \n * @mixin\n * @alias module:net~NodeDatumMetadataUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * Get a base URL for datum metadata operations using a specific node ID.\n     * \n     * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n     * @returns {string} the base URL\n     * @private\n     */\n    baseNodeDatumMetadataUrl(nodeId) {\n        return this.baseUrl() + '/datum/meta/' +(nodeId || this.nodeId);\n    }\n\n    nodeDatumMetadataUrlWithSource(nodeId, sourceId) {\n        let result = this.baseNodeDatumMetadataUrl(nodeId);\n        let source = (sourceId || this.sourceId);\n        if ( sourceId !== null && source ) {\n            result += '?sourceId=' +encodeURIComponent(source);\n        }\n        return result;\n    }\n\n\t/**\n\t * Generate a URL for viewing datum metadata.\n     * \n     * If no <code>sourceId</code> is provided, then the API will return all available datum metadata for all sources.\n\t *\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; \n     *                            if not provided the <code>sourceId</code> property of this class will be used;\n     *                            if <code>null</code> then ignore any <code>sourceId</code> property of this class\n     * @returns {string} the URL\n\t */\n\tviewNodeDatumMetadataUrl(nodeId, sourceId) {\n        return this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n    }\n    \n\t/**\n\t * Generate a URL for adding (merging) datum metadata via a <code>POST</code> request.\n     * \n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; if not provided the <code>sourceId</code> property of this class will be used\n     * @returns {string} the URL\n\t */\n    addNodeDatumMetadataUrl(nodeId, sourceId) {\n        return this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n    }\n\n\t/**\n\t * Generate a URL for setting datum metadata via a <code>PUT</code> request.\n     * \n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; if not provided the <code>sourceId</code> property of this class will be used\n     * @returns {string} the URL\n\t */\n    replaceNodeDatumMetadataUrl(nodeId, sourceId) {\n        return this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n    }\n\n\t/**\n\t * Generate a URL for deleting datum metadata via a <code>DELETE</code> request.\n     * \n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; if not provided the <code>sourceId</code> property of this class will be used\n     * @returns {string} the URL\n\t */\n    deleteNodeDatumMetadataUrl(nodeId, sourceId) {\n        return this.nodeDatumMetadataUrlWithSource(nodeId, sourceId);\n    }\n\n\t/**\n\t * Generate a URL for searching for datum metadata.\n\t * \n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @param {string} [sourceId] a specific source ID to use; \n     *                            if not provided the <code>sourceId</code> property of this class will be used;\n     *                            if <code>null</code> then ignore any <code>sourceId</code> property of this class\n\t * @param {SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tfindNodeDatumMetadataUrl(nodeId, sourceId, sorts, pagination) {\n        let result = this.baseNodeDatumMetadataUrl(nodeId);\n\t\tlet params = '';\n        let source = (sourceId || this.sourceId);\n        if ( sourceId !== null && source ) {\n            params += 'sourceId=' +encodeURIComponent(source);\n        }\n\t\tif ( Array.isArray(sorts) ) {\n\t\t\tsorts.forEach((sort, i) => {\n\t\t\t\tif ( sort instanceof SortDescriptor ) {\n\t\t\t\t\tif ( params.length > 0 ) {\n\t\t\t\t\t\tparams += '&';\n\t\t\t\t\t}\n\t\t\t\t\tparams += sort.toUriEncoding(i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif ( pagination instanceof Pagination ) {\n\t\t\tif ( params.length > 0 ) {\n\t\t\t\tparams += '&';\n\t\t\t}\n\t\t\tparams += pagination.toUriEncoding();\n\t\t}\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n    userMetadataUrl(userId) {\n        let result = this.baseUrl() +'/users/meta';\n        let userParam = (userId || this.userId);\n        if ( Array.isArray(userParam) ) {\n            if ( userParam.length > 0 ) {\n                userParam = userParam[0];\n            } else {\n                userParam = null;\n            }\n        }\n        if ( userParam && userId !== null ) {\n            result += '/' +userParam;\n        }\n        return result;\n    }\n\n    /**\n\t * Generate a URL for viewing a specific user's metadata via a `GET` request.\n\t * \n\t * Note this URL is similar to {@link module:net~UserMetadataUrlHelperMixin#viewUserMetadataUrl}\n\t * but is for the read-only SolarQuery API, rather than the read-write SolarUser API.\n\t *\n\t * @param {number|null} [userId] a specific user ID;\n     *                               if not provided the `userId` property of this class will be used\n\t * @returns {string} the URL\n\t */\n    viewUserMetadataUrl(userId) {\n        return this.userMetadataUrl(userId);\n\t}\n\n};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~NodeDatumMetadataUrlHelperMixin},  \n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n * \n * @mixes module:net~NodeDatumMetadataUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeDatumMetadataUrlHelper\n */\nclass NodeDatumMetadataUrlHelper extends NodeDatumMetadataUrlHelperMixin(QueryUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))) {\n\n}\n\nexport default NodeDatumMetadataUrlHelperMixin;\nexport { NodeDatumMetadataUrlHelper };\n","import DatumFilter from '../domain/datumFilter';\nimport UrlHelper from './urlHelper';\nimport NodeUrlHelperMixin from './nodeUrlHelperMixin';\nimport QueryUrlHelperMixin from './queryUrlHelperMixin';\n\n/**\n * Create a NodeDatumUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeDatumUrlHelperMixin} the mixin class\n */\nconst NodeDatumUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarNode datum query support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~NodeDatumUrlHelperMixin\n */\nclass extends superclass {\n\n\t/**\n\t * Generate a URL for the \"reportable interval\" for a node, optionally limited to a specific set of source IDs.\n\t *\n     * If no source IDs are provided, then the reportable interval query will return an interval for\n     * all available sources.\n     *\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t * @param {string[]} [sourceIds] an array of source IDs to limit query to; if not provided the `sourceIds` property of this class will be used\n\t * @returns {string} the URL\n\t */\n\treportableIntervalUrl(nodeId, sourceIds) {\n\t\tlet url = (this.baseUrl() +'/range/interval?nodeId=' +(nodeId || this.nodeId));\n        let sources = (sourceIds || this.sourceIds);\n\t\tif ( Array.isArray(sources) && sources.length > 0 ) {\n\t\t\turl += '&sourceIds=' + sources.map(e => encodeURIComponent(e)).join(',');\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Generate a URL for finding the available source IDs for a node or metadata filter.\n\t * \n\t * @param {module:domain~DatumFilter} datumFilter the search criteria, which can define `nodeId`, `startDate`, `endDate`,\n\t *                                                and `metadataFilter` properties to limit the results to; if `nodeId` not\n\t *                                                provided the `nodeIds` property of this class will be used\n\t * @returns {string} the URL\n\t */\n\tavailableSourcesUrl(datumFilter) {\n\t\tconst filter = (datumFilter || this.datumFilter());\n\t\tlet result = this.baseUrl() + '/range/sources';\n\t\tconst params = filter.toUriEncoding();\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generate a URL for querying for datum, in either raw or aggregate form.\n\t * \n\t * If the `datumFilter` has an `aggregate` value set, then aggregate results will be\n\t * returned by SolarNet.\n\t * \n\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tlistDatumUrl(datumFilter, sorts, pagination) {\n\t\tlet result = this.baseUrl() + '/datum/list';\n\t\tconst filter = (datumFilter || this.datumFilter());\n\t\tconst params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Generate a URL for querying for datum _reading_ values.\n\t * \n\t * The `datumFilter` must provide the required date(s) to use for the\n\t * reading type. If the reading type only requires one date, then the\n\t * {@link module:domain~DatumFilter#startDate} or\n\t * {@link module:domain~DatumFilter#endDate} value should be provided.\n\t * \n\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t * @param {module:domain~DatumReadingType} readingType the type of reading to find\n\t * @param {string} [tolerance] optional query tolerance to use\n\t * @returns {string} the URL\n\t * @see https://github.com/SolarNetwork/solarnetwork/wiki/SolarQuery-API#datum-reading\n\t */\n\tdatumReadingUrl(datumFilter, readingType, tolerance) {\n\t\tlet result = this.baseUrl() + '/datum/reading';\n\t\tconst filter = (new DatumFilter(datumFilter) || this.datumFilter());\n\t\tfilter.prop('readingType', readingType.name);\n\t\tif ( tolerance ) {\n\t\t\tfilter.prop('tolerance', tolerance);\n\t\t}\n\t\tconst params = filter.toUriEncoding();\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * Get a new {@link module:domain~DatumFilter} configured with properties of this instance.\n\t * \n\t * This will configure the following properties:\n\t * \n\t *  * `nodeIds`\n\t *  * `sourceIds`\n\t * \n\t * @returns {module:domain~DatumFilter} the filter\n\t */\n\tdatumFilter() {\n\t\tconst filter = new DatumFilter();\n\t\tlet v;\n\t\t\n\t\tv = this.nodeIds;\n\t\tif ( v ) {\n\t\t\tfilter.nodeIds = v;\n\t\t}\n\n\t\tv = this.sourceIds;\n\t\tif ( v ) {\n\t\t\tfilter.sourceIds = v;\n\t\t}\n\n\t\treturn filter;\n\t}\n\n\t/**\n\t * Generate a URL for querying for the most recent datum.\n\t * \n\t * @param {module:domain~DatumFilter} datumFilter the search criteria\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tmostRecentDatumUrl(datumFilter, sorts, pagination) {\n\t\tlet result = this.baseUrl() + '/datum/mostRecent';\n\t\tconst filter = (datumFilter || this.datumFilter());\n\t\tconst params = filter.toUriEncodingWithSorting(sorts, pagination);\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~NodeDatumUrlHelperMixin}, \n * {@link module:net~QueryUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n * \n * @mixes module:net~NodeDatumUrlHelperMixin\n * @mixes module:net~QueryUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeDatumUrlHelper\n */\nclass NodeDatumUrlHelper extends NodeDatumUrlHelperMixin(QueryUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))) {\n\n}\n\nexport default NodeDatumUrlHelperMixin;\nexport { NodeDatumUrlHelper };\n","/** \n * The SolarUser default path.\n * @type {string}\n * @alias module:net~SolarUserDefaultPath\n */\nexport const SolarUserDefaultPath = '/solaruser';\n\n/**\n * The {@link module:net~UrlHelper} parameters key for the SolarUser path.\n * @type {string}\n * @alias module:net~SolarUserPathKey\n */\nexport const SolarUserPathKey = 'solarUserPath';\n\n/** \n * The SolarUser REST API path.\n * @type {string}\n * @alias module:net~SolarUserApiPathV1\n */\nexport const SolarUserApiPathV1 = '/api/v1/sec';\n\nconst UserIdsKey = 'userIds';\n\n/**\n * Create a UserUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserUrlHelperMixin} the mixin class\n */\nconst UserUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarUser specific support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~UserUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * Get the default user ID.\n     * \n     * This gets the first available user ID from the `userIds` property.\n     * \n     * @returns {number} the default user ID, or `null`\n     */\n    get userId() {\n        const userIds = this.parameter(UserIdsKey);\n        return (Array.isArray(userIds) && userIds.length > 0 ? userIds[0] : null);\n    }\n\n    /**\n     * Set the user ID.\n     * \n     * This will set the `userIds` property to a new array of just the given value.\n     * \n     * @param {number} userId the user ID to set\n     */\n    set userId(userId) {\n        this.parameter(UserIdsKey, [userId]);\n    }\n\n    get userIds() {\n        return this.parameter(UserIdsKey);\n    }\n\n    set userIds(userIds) {\n        this.parameter(UserIdsKey, userIds);\n    }\n\n\t/**\n\t * Get the base URL to the SolarUser v1 REST API.\n\t * \n\t * The returned URL uses the configured environment to resolve\n\t * the `hostUrl` and a `solarUserPath` context path.\n\t * If the context path is not available, it will default to \n\t * `/solaruser`.\n\t * \n\t * @returns {string} the base URL to SolarUser\n\t */\n\tbaseUrl() {\n\t\tconst path = this.env(SolarUserPathKey) || SolarUserDefaultPath;\n\t\treturn super.baseUrl() + path + SolarUserApiPathV1;\n\t}\n\n\t/**\n\t * Generate a URL to get a list of all active nodes for the user account.\n\t *\n\t * @return {string} the URL to access the user's active nodes\n\t */\n\tviewNodesUrl() {\n\t\treturn this.baseUrl() + '/nodes';\n\t}\n\n\t/**\n\t * Generate a URL to get a list of all pending nodes for the user account.\n\t *\n\t * @return {string} the URL to access the user's pending nodes\n\t */\n\tviewPendingNodesUrl() {\n\t\treturn this.baseUrl() + '/nodes/pending';\n\t}\n\n\t/**\n\t * Generate a URL to get a list of all archived nodes for the user account.\n\t *\n\t * @return {string} the URL to access the user's archived nodes\n\t */\n\tviewArchivedNodesUrl() {\n\t\treturn this.baseUrl() + '/nodes/archived';\n\t}\n\n\t/**\n\t * Generate a URL to update the archived status of a set of nodes via a `POST` request.\n\t *\n\t * @param {number|number[]|null} nodeId a specific node ID, or array of node IDs, to update; if not provided the \n\t *                                      `nodeIds` property of this class will be used\n\t * @param {boolean} archived `true` to mark the nodes as archived; `false` to un-mark\n\t *                           and return to normal status\n\t * @return {string} the URL to update the nodes archived status\n\t */\n\tupdateNodeArchivedStatusUrl(nodeId, archived) {\n\t\tconst nodeIds = Array.isArray(nodeId) ? nodeId : nodeId ? [nodeId] : this.nodeIds;\n\t\tlet result = this.baseUrl() + '/nodes/archived?nodeIds='\n\t\t\t+nodeIds.join(',') +'&archived='\n\t\t\t+(archived ? 'true' : 'false');\n\t\treturn result;\n\t}\n\n}\n\nexport default UserUrlHelperMixin;\n","import UrlHelper from './urlHelper';\nimport NodeUrlHelperMixin from './nodeUrlHelperMixin';\nimport UserUrlHelperMixin from './userUrlHelperMixin'\n\n/**\n * Create a NodeInstructionUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeInstructionUrlHelperMixin} the mixin class\n */\nconst NodeInstructionUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarNode instruction support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~NodeInstructionUrlHelperMixin\n */\nclass extends superclass {\n\n\t/**\n\t * Generate a URL to get all details for a specific instruction.\n\t * \n\t * @param {number} instructionId the instruction ID to get\n\t * @returns {string} the URL\n\t */\n\tviewInstructionUrl(instructionId) {\n\t\treturn (this.baseUrl() +'/instr/view?id=' +encodeURIComponent(instructionId));\n\t}\n\n\t/**\n\t * Generate a URL for viewing active instructions.\n\t * \n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @returns {string} the URL\n\t */\n\tviewActiveInstructionsUrl(nodeId) {\n\t\treturn (this.baseUrl() +'/instr/viewActive?nodeId=' \n\t\t\t+(nodeId || this.nodeId));\n\t}\n\n\t/**\n\t * Generate a URL for viewing pending instructions.\n\t * \n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @returns {string} the URL\n\t */\n\tviewPendingInstructionsUrl(nodeId) {\n\t\treturn (this.baseUrl() +'/instr/viewPending?nodeId=' \n\t\t\t+(nodeId || this.nodeId));\n\t}\n\n\t/**\n\t * Generate a URL for changing the state of an instruction.\n\t * \n\t * @param {number} instructionId the instruction ID to update\n\t * @param {InstructionState} state the instruction state to set\n\t * @returns {string} the URL\n\t * @see the {@link InstructionStates} enum for possible state values\n\t */\n\tupdateInstructionStateUrl(instructionId, state) {\n\t\treturn (this.baseUrl()\n\t\t\t+'/instr/updateState?id=' +encodeURIComponent(instructionId)\n\t\t\t+'&state=' +encodeURIComponent(state.name));\n\t}\n\n\t/**\n\t * Generate a URL for posting an instruction request.\n\t *\n\t * @param {string} topic the instruction topic.\n\t * @param {Object[]} [parameters] an array of parameter objects in the form <code>{name:n1, value:v1}</code>.\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the <code>nodeId</code> property of this class will be used\n\t * @returns {string} the URL\n\t */\n\tqueueInstructionUrl(topic, parameters, nodeId) {\n\t\tvar url = (this.baseUrl()\n\t\t\t+'/instr/add?nodeId=' +(nodeId || this.nodeId)\n\t\t\t+'&topic=' +encodeURIComponent(topic));\n\t\tvar i, len;\n\t\tif ( Array.isArray(parameters) ) {\n\t\t\tfor ( i = 0, len = parameters.length; i < len; i++ ) {\n\t\t\t\turl += '&' +encodeURIComponent('parameters['+i+'].name') +'=' +encodeURIComponent(parameters[i].name)\n\t\t\t\t\t+ '&' +encodeURIComponent('parameters['+i+'].value') +'=' +encodeURIComponent(parameters[i].value);\n\t\t\t}\n\t\t}\n\t\treturn url;\n\t}\n\n\t/**\n\t * Create an instruction parameter suitable to passing to {@link NodeInstructionUrlHelperMixin#queueInstructionUrl}.\n\t * \n\t * @param {string} name the parameter name \n\t * @param {*} value the parameter value\n\t * @returns {object} with <code>name</code> and <code>value</code> properties\n\t */\n\tstatic instructionParameter(name, value) {\n\t\treturn {name:name, value:value};\n\t}\n};\n\n/**\n * A concrete {@link UrlHelper} with the {@link module:net~NodeInstructionUrlHelperMixin},  \n * {@link module:net~UserUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n * \n * @mixes module:net~NodeInstructionUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeInstructionUrlHelper\n */\nclass NodeInstructionUrlHelper extends NodeInstructionUrlHelperMixin(UserUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))) {\n\n}\n\n/**\n * The static {@link NodeInstructionUrlHelperMixin#instructionParameter} method so it can be imported directly.\n * \n * @alias module:net~instructionParameter\n */\nconst instructionParameter = NodeInstructionUrlHelper.instructionParameter;\n\nexport default NodeInstructionUrlHelperMixin;\nexport { instructionParameter, NodeInstructionUrlHelper };","import Pagination from '../domain/pagination';\nimport SortDescriptor from '../domain/sortDescriptor';\nimport UrlHelper from './urlHelper';\nimport NodeUrlHelperMixin from './nodeUrlHelperMixin';\nimport UserUrlHelperMixin from './userUrlHelperMixin'\n\n/**\n * Create a NodeMetadataUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~NodeMetadataUrlHelperMixin} the mixin class\n */\nconst NodeMetadataUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds SolarNode metadata support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~NodeMetadataUrlHelperMixin\n */\nclass extends superclass {\n\n\t/**\n\t * Generate a URL for viewing the configured node's metadata.\n\t *\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t * @returns {string} the URL\n\t */\n\tviewNodeMetadataUrl(nodeId) {\n\t\treturn (this.baseUrl() +'/nodes/meta/' \n\t\t\t+(nodeId || this.nodeId));\n\t}\n\n\t/**\n\t * Generate a URL for adding metadata to a node via a `POST` request.\n\t *\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t * @returns {string} the URL\n\t */\n\taddNodeMetadataUrl(nodeId) {\n\t\treturn this.viewNodeMetadataUrl(nodeId);\n\t}\n\n\t/**\n\t * Generate a URL for setting the metadata of a node via a `PUT` request.\n\t *\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t * @returns {string} the URL\n\t */\n\treplaceNodeMetadataUrl(nodeId) {\n\t\treturn this.viewNodeMetadataUrl(nodeId);\n\t}\n\n\t/**\n\t * Generate a URL for deleting the metadata of a node via a `DELETE` request.\n\t *\n\t * @param {number} [nodeId] a specific node ID to use; if not provided the `nodeId` property of this class will be used\n\t * @returns {string} the URL\n\t */\n\tdeleteNodeMetadataUrl(nodeId) {\n\t\treturn this.viewNodeMetadataUrl(nodeId);\n\t}\n\n\t/**\n\t * Generate a URL for searching for node metadata.\n\t * \n\t * @param {number|number[]} [nodeId] a specific node ID, or array of node IDs, to use; if not provided the \n\t *                                   `nodeIds` property of this class will be used, unless `null`\n\t *                                   is passed in which case no node IDs will be added to the URL so that all available\n\t *                                   node metadata objects will be returned\n\t * @param {module:domain~SortDescriptor[]} [sorts] optional sort settings to use\n\t * @param {module:domain~Pagination} [pagination] optional pagination settings to use\n\t * @returns {string} the URL\n\t */\n\tfindNodeMetadataUrl(nodeId, sorts, pagination) {\n\t\tconst nodeIds = (Array.isArray(nodeId) ? nodeId : nodeId ? [nodeId] : nodeId !== null ? this.nodeIds : undefined);\n\t\tlet result = this.baseUrl() + '/nodes/meta';\n\t\tlet params = '';\n\t\tif ( Array.isArray(nodeIds) ) {\n\t\t\tparams += 'nodeIds=' +nodeIds.join(',');\n\t\t}\n\t\tif ( Array.isArray(sorts) ) {\n\t\t\tsorts.forEach((sort, i) => {\n\t\t\t\tif ( sort instanceof SortDescriptor ) {\n\t\t\t\t\tif ( params.length > 0 ) {\n\t\t\t\t\t\tparams += '&';\n\t\t\t\t\t}\n\t\t\t\t\tparams += sort.toUriEncoding(i);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tif ( pagination instanceof Pagination ) {\n\t\t\tif ( params.length > 0 ) {\n\t\t\t\tparams += '&';\n\t\t\t}\n\t\t\tparams += pagination.toUriEncoding();\n\t\t}\n\t\tif ( params.length > 0 ) {\n\t\t\tresult += '?' + params;\n\t\t}\n\t\treturn result;\n\t}\n\n};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~NodeMetadataUrlHelperMixin},  \n * {@link module:net~UserUrlHelperMixin}, and {@link module:net~NodeUrlHelperMixin} mixins.\n * \n * @mixes module:net~NodeMetadataUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @mixes module:net~NodeUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~NodeMetadataUrlHelper\n */\nclass NodeMetadataUrlHelper extends NodeMetadataUrlHelperMixin(UserUrlHelperMixin(NodeUrlHelperMixin(UrlHelper))) {\n\n}\n\nexport default NodeMetadataUrlHelperMixin;\nexport { NodeMetadataUrlHelper };\n","import UrlHelper from './urlHelper';\nimport UserUrlHelperMixin from './userUrlHelperMixin'\n\n/**\n * Create a UserAuthTokenUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserAuthTokenUrlHelperMixin} the mixin class\n */\nconst UserAuthTokenUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds security token support to a SolarUser {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~UserAuthTokenUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n     * Generate a URL for listing all available auth tokens.\n     * \n\t * @returns {string} the URL\n     */\n    listAllAuthTokensUrl() {\n        return this.baseUrl() + '/user/auth-tokens';\n    }\n\n    /**\n     * Generate a URL for creating a new auth token, via a `POST` request.\n     * \n     * The request body accepts a {@link module:domain~SecurityPolicy} JSON document.\n     * \n     * @param {AuthTokenType} type the auth token type to generate\n\t * @returns {string} the URL\n     */\n    generateAuthTokenUrl(type) {\n        return this.baseUrl() + '/user/auth-tokens/generate/' +type.name;\n    }\n\n    /**\n     * Generate a URL for accessing an auth token.\n     * \n     * @param {string} tokenId the token ID\n\t * @returns {string} the URL\n     * @private\n     */\n    authTokenUrl(tokenId) {\n        return this.baseUrl() + '/user/auth-tokens/' +encodeURIComponent(tokenId);\n    }\n\n    /**\n     * Generate a URL for deleting an auth token, via a `DELETE` request.\n     * \n     * @param {string} tokenId the token ID to delete\n\t * @returns {string} the URL\n     */\n    deleteAuthTokenUrl(tokenId) {\n        return this.authTokenUrl(tokenId);\n    }\n\n    /**\n     * Generate a URL for updating (merging) a security policy on an auth token,\n     * via a `PATCH` request.\n     * \n     * The request body accepts a {@link module:net~SecurityPolicy} JSON document.\n     * \n     * @param {string} tokenId the ID of the token to update\n\t * @returns {string} the URL\n     */\n    updateAuthTokenSecurityPolicyUrl(tokenId) {\n        return this.authTokenUrl(tokenId);\n    }\n\n    /**\n     * Generate a URL for replacing a security policy on an auth token,\n     * via a `PUT` request.\n     * \n     * The request body accepts a {@link module:domain~SecurityPolicy} JSON document.\n     * \n     * @param {string} tokenId the ID of the token to update\n\t * @returns {string} the URL\n     */\n    replaceAuthTokenSecurityPolicyUrl(tokenId) {\n        return this.authTokenUrl(tokenId);\n    }\n\n    /**\n     * Generate a URL for updating the status of an auth token,\n     * via a `POST` request.\n     * \n     * @param {string} tokenId the ID of the token to update\n     * @param {AuthTokenStatus} status the status to change to\n\t * @returns {string} the URL\n     */\n    updateAuthTokenStatusUrl(tokenId, status) {\n        return this.authTokenUrl(tokenId) + '?status=' +encodeURIComponent(status.name);\n    }\n}\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~UserAuthTokenUrlHelperMixin} and  \n * {@link module:net~UserUrlHelperMixin} mixins.\n * \n * @mixes module:net~UserAuthTokenUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~UserAuthTokenUrlHelper\n */\nclass UserAuthTokenUrlHelper extends UserAuthTokenUrlHelperMixin(UserUrlHelperMixin(UrlHelper)) {\n\n }\n\nexport default UserAuthTokenUrlHelperMixin;\nexport { UserAuthTokenUrlHelper };\n","import UrlHelper from './urlHelper';\nimport UserUrlHelperMixin from './userUrlHelperMixin'\n\n/**\n * Create a UserMetadataUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~UserMetadataUrlHelperMixin} the mixin class\n */\nconst UserMetadataUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds user metadata support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~UserMetadataUrlHelperMixin\n */\nclass extends superclass {\n\n    /**\n\t * Generate a URL for viewing the configured user's metadata via a <code>GET</code> request.\n\t *\n\t * @param {module:domain~UserMetadataFilter} filter the search criteria\n\t * @returns {string} the URL\n\t */\n\tfindUserMetadataUrl(filter) {\n        let result = this.baseUrl() +'/users/meta';\n        if ( filter ) {\n            const params = filter.toUriEncoding();\n            if ( params.length > 0 ) {\n                result += '?' + params;\n            }\n        }\n        return result;\n    }\n    \n    userMetadataUrl(userId) {\n        let result = this.baseUrl() +'/users/meta';\n        let userParam = (userId || this.userId);\n        if ( Array.isArray(userParam) ) {\n            if ( userParam.length > 0 ) {\n                userParam = userParam[0];\n            } else {\n                userParam = null;\n            }\n        }\n        if ( userParam && userId !== null ) {\n            result += '/' +userParam;\n        }\n        return result;\n    }\n\n    /**\n\t * Generate a URL for viewing a specific user's metadata via a <code>GET</code> request.\n\t *\n\t * @param {number|null} [userId] a specific user ID;\n     *                               if not provided the <code>userId</code> property of this class will be used;\n     *                               if <code>null</code> then view metadata of the requesting user\n\t * @returns {string} the URL\n\t */\n    viewUserMetadataUrl(userId) {\n        return this.userMetadataUrl(userId);\n    }\n\n    /**\n\t * Generate a URL for adding user metadata via a <code>POST</code> request.\n\t *\n\t * @param {number|null} [userId] a specific user ID;\n     *                               if not provided the <code>userId</code> property of this class will be used;\n     *                               if <code>null</code> then add metadata to the requesting user\n\t * @returns {string} the URL\n\t */\n\taddUserMetadataUrl(userId) {\n        return this.userMetadataUrl(userId);\n    }\n    \n    /**\n\t * Generate a URL for replacing user metadata via a <code>PUT</code> request.\n\t *\n\t * @param {number|null} [userId] a specific user ID;\n     *                               if not provided the <code>userId</code> property of this class will be used;\n     *                               if <code>null</code> then add metadata to the requesting user\n\t * @returns {string} the URL\n\t */\n\treplaceUserMetadataUrl(userId) {\n        return this.userMetadataUrl(userId);\n\t}\n    \n    /**\n\t * Generate a URL for deleting user metadata via a <code>DELETE</code> request.\n\t *\n\t * @param {number|null} [userId] a specific user ID;\n     *                               if not provided the <code>userId</code> property of this class will be used;\n     *                               if <code>null</code> then add metadata to the requesting user\n\t * @returns {string} the URL\n\t */\n\tdeleteUserMetadataUrl(userId) {\n        return this.userMetadataUrl(userId);\n\t}\n};\n\n/**\n * A concrete {@link module:net~UrlHelper} with the {@link module:net~UserMetadataUrlHelperMixin}\n * and {@link module:net~UserUrlHelperMixin} mixins.\n * \n * @mixes module:net~UserMetadataUrlHelperMixin\n * @mixes module:net~UserUrlHelperMixin\n * @extends module:net~UrlHelper\n * @alias module:net~UserMetadataUrlHelper\n */\nclass UserMetadataUrlHelper extends UserMetadataUrlHelperMixin(UserUrlHelperMixin(UrlHelper)) {\n\n}\n\nexport default UserMetadataUrlHelperMixin;\nexport { UserMetadataUrlHelper };\n","/**\n * Get an appropriate multiplier value for scaling a given value to a more display-friendly form.\n * \n * This will return values suitable for passing to {@link module:format~displayUnitsForScale}.\n * \n * @param {number} value the value to get a display scale factor for, for example the maximum value\n *                       in a range of values\n * @return {number} the display scale factor\n * @alias module:format~displayScaleForValue\n */\nexport function displayScaleForValue(value) {\n    var result = 1,\n        num = Math.abs(Number(value));\n\tif ( isNaN(num) === false ) {\n\t\tif ( num >= 1000000000 ) {\n\t\t\tresult = 1000000000;\n\t\t} else if ( num >= 1000000 ) {\n\t\t\tresult = 1000000;\n\t\t} else if ( num >= 1000 ) {\n\t\t\tresult = 1000;\n\t\t}\n\t}\n\treturn result;\n}\n\n/**\n * Get an appropriate display unit for a given base unit and scale factor.\n * \n * Use this method to render scaled data value units. Typically you would first call\n * {@link module:module:format~displayScaleForValue}, passing in the largest expected value\n * in a set of data, and then pass the result to this method to generate a display unit\n * for the base unit for that data.\n * \n * For example, given a base unit of `W` (watts) and a maximum data value of `10000`:\n * \n * ```\n * const fmt = import { * } from 'format/scale';\n * const displayScale = fmt.displayScaleForValue(10000);\n * const displayUnit = fmt.displayUnitForScale('W', displayScale);\n * ```\n * \n * The `displayUnit` result in that example would be `kW`.\n *\n * @param {string} baseUnit the base unit, for example `W` or `Wh`\n * @param {number} scale the unit scale, which must be a recognized SI scale, such \n *                       as `1000` for `k`\n * @return {string} the display unit value\n * @alias module:format~displayUnitsForScale\n */\nexport function displayUnitsForScale(baseUnit, scale) {\n\treturn (scale === 1000000000 ? 'G' \n\t\t\t: scale === 1000000 ? 'M' \n\t\t\t: scale === 1000 ? 'k' \n\t\t\t: '') + baseUnit;\n}\n","import { dateFormat } from '../format/date'\n\n/**\n * Create a AuthTokenUrlHelperMixin class.\n *\n * @exports net\n * @param {module:net~UrlHelper} superclass the UrlHelper class to mix onto\n * @return {module:net~AuthTokenUrlHelperMixin} the mixin class\n */\nconst AuthTokenUrlHelperMixin = (superclass) => \n\n/**\n * A mixin class that adds authentication token support to {@link module:net~UrlHelper}.\n * \n * @mixin\n * @alias module:net~AuthTokenUrlHelperMixin\n */\nclass extends superclass {\n\n\t/**\n\t * Generate a URL to refresh the signing key of an authentication token.\n     * \n     * **Note** this method only works against the `/sec` version of the API endpoint.\n\t * \n\t * @param {date} date the signing date to use, or `null` for the current date\n\t * @returns {string} the URL\n\t */\n\trefreshTokenV2Url(date) {\n\t\treturn (this.baseUrl() +'/auth-tokens/refresh/v2?date=' +encodeURIComponent(dateFormat(date || new Date())));\n\t}\n\n}\n\nexport default AuthTokenUrlHelperMixin;\n"]}